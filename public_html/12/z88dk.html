<!doctype html>
<html lang="es">
    <head>
        <title>Magazine ZX</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

        <link rel="stylesheet" href="../css/magazine.css" type="text/css">
    </head>
    <body><!-- Google Tag Manager --> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-W5DD5R" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-W5DD5R');</script> <!-- End Google Tag Manager -->


            <table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
                <tr>
                    <td>
<a name="arriba"></a>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
	<tr align="center" valign="center">
		<td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0" /></a></td>
	</tr>
</table>
                    </td>

                </tr>
                <tr>
                    <td>
<script language="JavaScript">
function RecargarCabecera(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">
        <tr><td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>

        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('el-aventurero.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
        <option value="index.html">Portada</option>
        <option value="editorial.html">Índice - Editorial</option>
        <option value="panorama.html">Panorama</option>
        <option value="analisis.html">Análisis</option>

        <option value="al-descubierto.html">Al Descubierto</option>
        <option value="hardware.html">Hardware</option>
        <option value="basic.html">Programación BASIC</option>
        <option value="el-aventurero.html">El Aventurero</option>
        <option value="z88dk.html" selected>Programación Z88DK</option>
        <option value="input.html">INPUT</option>

        <option value="ensamblador.html">Programación Ensamblador</option>
        <option value="opinion.html">Opinión</option>
    </select>
    <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">" />
</td>
            <td align="center" class="texto">Número 12 - Septiembre 2005</td>
            <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX" onClick="window.open(this.href); return false;"><img src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0" alt="ZX Certified webmaster"></a>&nbsp;<a href="http://www.speccy.org/" onClick="window.open(this.href); return false;"><img src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a></td>
        </tr>

    </form>
</table>
</a>
                    </td>
                </tr>
                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td>
<table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
    <tr>

        <td>
<div align="justify">
<p align="center"><font size="5">¡MIS SPRITES SE MUEVEN!</font></p>
<p>En el artículo anterior aprendimos cómo definir sprites y dibujarlos en pantalla utilizando la librería z88dk sin recurrir a ninguna otra herramienta externa (a menos que quisiéramos dibujar los sprites utilizando algún programa como los mostrados en el número anterior). En esta entrega vamos a ir un poco más allá y vamos a permitir que el usuario pueda mover algún sprite por la pantalla,  y que este sprite pueda interaccionar con otros elementos, colisionando con ellos.</p>
<p><b>¿Qué vamos a hacer?</b></p>
<p>Para aprender los conceptos que necesitamos vamos a programar lo que podría ser el código inicial de un juego de carreras de coches, tipo Super Sprint, en los que desde una vista cenital podemos ver el circuito y los distintos participantes. Crearemos un coche utilizando diversos sprites, según hacia donde se esté moviendo el mismo, y crearemos una pista por donde el coche podrá moverse. Evidentemente, esta pista marcará el límite de movimiento de nuestro bólido, por lo que deberemos implementar también algún mecanismo para colisiones, de tal manera que al vehículo le pase algo al contactar con los límites del circuito. Sin más, empecemos.</p>
<p><b>Definiendo los sprites</b></p>
<p>Hasta ahora hemos visto como crear sprites de un tamaño límite de 8x8. Sin embargo, por mucho que lo intentemos, va a ser un poco difícil crear un sprite que represente algo aproximado a un coche con una rejilla tan pequeña. Si nos fijamos en la siguiente imagen, observaremos que tanto para representar al coche en todas las posibles orientaciones, así como los neumáticos que van a formar parte de los límites de la pista, necesitamos utilizar sprites de 10x10. ¿Cómo creamos sprites mayores de 8x8 usando z88dk?</p>

<table border="0" cellspacing="0" cellpadding="2" width="400">

	<tr align="right">
		<td><img src="img/z88dk7_1.png" width="400" height="400"  alt="Figura 1: Los sprites que vamos a utilizar en nuestro juego. Representan todas las posibles orientaciones del coche, excepto el último de todos, que representa un neumático. Todos ellos tienen un tamaño de 10x10" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Figura 1: Los sprites que vamos a utilizar en nuestro juego. Representan todas las posibles orientaciones del coche, excepto el último de todos, que representa un neumático. Todos ellos tienen un tamaño de 10x10</td>
	</tr>
</table>

<p>Según vimos anteriormente, un sprite se definía en z88dk como un array de char del tipo:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
char sprite0[] = { 8, 8, 0x18 , 0x24 , 0x42 , 0x81 , 0xA5 , 0x81 , 0x7E , 0x00 };
</pre>
    </p></td></tr>
</table>
<p>donde los dos primeros valores indicaban la altura y la anchura, respectivamente, y los siguientes valores representaban a cada una de las filas del sprite. Si cada columna tenía asignado un valor hexadecimal (estos valores eran, para una anchura de 8, y de derecha a izquierda, los siguientes: 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80), el valor para cada fila era la suma de los valores hexadecimales para los que el pixel correspondiente valía 1.</p>
<p>Para sprites de más de anchura 8, y hata una anchura de 16, en ese array de caracteres cada fila se va a representar por un par de números hexadecimales. El primer valor de esa pareja se va a corresponder con los 8 primeros píxeles empezando por la izquierda de la columna, y el segundo con el resto.</p>
<p>En el caso de los sprites que vemos en la figura anterior, donde cada columna tiene una anchura de diez píxeles, cada fila se representaría también por una pareja de valores hexadecimales. Con la primera pareja codificamos los ocho píxeles de la izquierda, de la misma forma en que lo hacemos con sprites de anchura hasta 8, y con la segunda pareja codificamos los otros dos pixeles que quedan a la derecha (siendo el valor 0x80 el correspondiente al primero y el valor 0x40 el correspondiente al segundo. Si hubiese más de dos, seguiríamos asignando los valores 0x20, 0x10, 0x08, 0x04 y etc. a los siguientes). En la siguiente imagen vemos un ejemplo.</p>

<table border="0" cellspacing="0" cellpadding="2" width="576">

	<tr align="right">
		<td><img src="img/z88dk7_2.png" width="576" height="377"  alt="Figura 2: cálculo de los valores hexadecimales correspondientes a cada una de las filas del sprite 0" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Figura 2: cálculo de los valores hexadecimales correspondientes a cada una de las filas del sprite 0</td>
	</tr>
</table>

<p>Podríamos ser malvados y dejar como ejercicio al lector que calcule cómo se codificarían el resto de sprites, pero vamos a ahorrarle el mal trago. A continuación incluímos el código que codifica todos los sprites anteriores, que deberemos introducir dentro de un archivo de cabecera llamado <b>coches.h</b>:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
char sprite0[] = { 10, 10, 0x00 , 0x00 , 0x73 , 0x80 , 0xFF , 0x40 , 0xB9 ,
     0xC0 , 0xB9 , 0xC0 , 0xB9 , 0xC0 , 0xB9 , 0xC0 , 0xFF , 0x40 , 0x73 ,
     0x80 , 0x00 , 0x00  };
char sprite1[] = { 10, 10, 0x3F , 0x00 , 0x5E , 0x80 , 0x7F , 0x80 , 0x61 ,
     0x80 , 0x21 , 0x00 , 0x3F , 0x00 , 0x7F , 0x80 , 0x7F , 0x80 , 0x61 ,
     0x80 , 0x3F , 0x00  };
char sprite2[] = { 10, 10, 0x00 , 0x00 , 0x73 , 0x80 , 0xBF , 0xC0 , 0xE7 ,
     0x40 , 0xE7 , 0x40 , 0xE7 , 0x40 , 0xE7 , 0x40 , 0xBF , 0xC0 , 0x73 ,
     0x80 , 0x00 , 0x00  };
char sprite3[] = { 10, 10, 0x3F , 0x00 , 0x61 , 0x80 , 0x7F , 0x80 , 0x7F ,
     0x80 , 0x3F , 0x00 , 0x21 , 0x00 , 0x61 , 0x80 , 0x7F , 0x80 , 0x5E ,
     0x80 , 0x3F , 0x00  };
char sprite4[] = { 10, 10, 0x0F , 0x00 , 0x1D , 0x80 , 0x13 , 0xC0 , 0x79 ,
     0x40 , 0xFC , 0xC0 , 0xBE , 0xC0 , 0xDF , 0x80 , 0x6E , 0x00 , 0x36 ,
     0x00 , 0x1C , 0x00  };
char sprite5[] = { 10, 10, 0x1C , 0x00 , 0x36 , 0x00 , 0x6E , 0x00 , 0xDF ,
     0x80 , 0xBE , 0xC0 , 0xFC , 0xC0 , 0x79 , 0x40 , 0x13 , 0xC0 , 0x1D ,
     0x80 , 0x0F , 0x00  };
char sprite6[] = { 10, 10, 0x3C , 0x00 , 0x6E , 0x00 , 0xF2 , 0x00 , 0xA7 ,
     0x80 , 0xCF , 0xC0 , 0xDF , 0x40 , 0x7E , 0xC0 , 0x1D , 0x80 , 0x1B ,
     0x00 , 0x0E , 0x00  };
char sprite7[] = { 10, 10, 0x0E , 0x00 , 0x1B , 0x00 , 0x1D , 0x80 , 0x7E ,
     0xC0 , 0xDF , 0x40 , 0xCF , 0xC0 , 0xA7 , 0x80 , 0xF2 , 0x00 , 0x6E ,
     0x00 , 0x3C , 0x00  };
char sprite8[] = { 10, 10, 0x1E , 0x00 , 0x7F , 0x80 , 0x7F , 0x80 , 0xF3 ,
     0xC0 , 0xE1 , 0xC0 , 0xE1 , 0xC0 , 0xF3 , 0xC0 , 0x7F , 0x80 , 0x7F ,
     0x80 , 0x1E , 0x00  };
</pre>
    </p></td></tr>
</table>
<p>Y a continuación indicamos el código de un pequeño programa, que llamaremos <b>coches.c</b>, que lo único que hará será mostrar por pantalla todos los sprites para comprobar que quedan bonitos. Para ello hacemos uso de la función <i>putsprite</i>, cuya sintaxis se explicó en el artículo anterior:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
#include "games.h"
#include "coches.h"

void main(void)
{
        putsprite(spr_or,1,41,sprite0);
        putsprite(spr_or,21,41,sprite1);
        putsprite(spr_or,41,41,sprite2);
        putsprite(spr_or,61,41,sprite3);
        putsprite(spr_or,1,61,sprite4);
        putsprite(spr_or,21,61,sprite5);
        putsprite(spr_or,41,61,sprite6);
        putsprite(spr_or,61,61,sprite7);
        putsprite(spr_or,1,81,sprite8);
}
</pre>
    </p></td></tr>
</table>
<p>El archivo de cabecera <i>games.h</i> debe ser incluido si queremos utilizar <i>putsprite</i>. En la siguiente imagen vemos la salida de este programa.</p>

<table border="0" cellspacing="0" cellpadding="2" width="320">
	<tr align="right">

		<td><img src="img/z88dk7_3.png" width="320" height="240"  alt="Figura 3. Los sprites mostrándose en la pantalla de nuestro Spectrum (o de nuestro emulador)" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Figura 3. Los sprites mostrándose en la pantalla de nuestro Spectrum (o de nuestro emulador)</td>
	</tr>
</table>

<p><b>Añadiendo movimiento</b></p>
<p>Hacer que un sprite se mueva por pantalla es tan sencillo como borrarlo de donde se encontraba anteriormente y volver a dibujarlo en una nueva posición. Lo interesante será hacer que nuestro coche cambie de aspecto según la orientación en la que se esté moviendo.</p>

<p>Para conseguir esto último, es decir, que se nos muestre un sprite distinto del coche según se esté moviendo hacia arriba, hacia abajo, etc., debemos añadir un par de cambios al archivo <b>coches.h</b>. Lo primero que vamos a hacer es almacenar todos los sprites en un único array de arrays de chars (es decir, en un único array de sprites). Esto lo hacemos colocando después de la definición de los diferentes sprites en <i>coches.h</i> una línea como la siguiente:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
char *sprites[9] = { sprite0 , sprite1 , sprite2 , sprite3 , sprite4 , sprite5 ,
    sprite6 , sprite7 , sprite8 };
</pre>
    </p></td></tr>
</table>
<p>De tal forma que podremos acceder al sprite <i>i</i> utilizando, por ejemplo, <i>sprites[i]</i> en lugar de <i>spritei</i>, lo cual nos va a ser de mucha utilidad. Justo después de esta línea, introducimos las dos líneas siguientes en <i>coches.h</i>:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
int izquierda[] = {4,6,7,5,1,0,2,3};
int derecha[] = {5,4,6,7,0,3,1,2};
</pre>
    </p></td></tr>
</table>
<p>Estos dos arrays los utilizaremos para saber, cada vez que giramos, cuál es el sprite que debemos dibujar en la pantalla. Si los sprites están numerados según la primera figura de este artículo, y ahora mismo se nos muestra en la pantalla el sprite 0, si giramos a la izquierda el que se debería mostrar es el 4. Si volvemos a girar a la izquierda, el que debería dibujarse entonces en la pantalla es el 1, etc. Si por el contrario, estamos mostrando el sprite 0 en la pantalla y giramos a la derecha, se nos debería mostrar el sprite 5. Si volvemos a girar a la derecha, se nos debería mostrar el sprite 3, etc. </p>
<p>¿Cómo representamos esto con los arrays indicados anteriormente? Para cada uno de estos dos arrays, la posición <i>i</i> representa, para el <i>sprite i</i>, cual debería ser el sprite que se debería dibujar si giramos hacia la izquierda, en el caso del primer array, o hacia la derecha, en el caso del segundo. Así, por ejemplo, si estamos mostrando el sprite 1 (el coche hacia arriba) y giramos a la izquierda, el valor para la posición 1 (recordemos que en C la primera posición de los arrays es el 0) en el array izquierda es 6, por lo que deberemos mostrar el sprite 6, correspondiente al coche dirigiéndose en diagonal hacia arriba a la izquierda. Sin embargo, si lo que hacemos es girar hacia la derecha, el valor almacenado en la posición 1 del array derecha es el 4, por lo que deberemos mostrar el sprite 4, correspondiente al coche dirigiéndose hacia arriba a la derecha.</p>

<p>Habiendo hecho estas dos modificaciones, ya podemos incluir aquí el código de un programa que llamaremos <b>movimiento.c</b>, que nos pondrá a los mandos de un coche que se mostrará en la pantalla, el cual podremos mover hacia donde queramos, sin ninguna restricción. </p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

void main(void)
{
        int x = 100;
        int y = 100;
        int posicion = 0;

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                switch(toupper(getk()))
                {
                       case 'O':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = izquierda[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                        case 'P':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = derecha[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                }
        }
}
</pre>
    </p></td></tr>
</table>
<p>De momento vamos a comenzar con los giros, y ya surcaremos después la pantalla a toda velocidad. El código anterior nos dibuja el coche en una zona cercana al centro de la pantalla, y nos permite girarlo hacia la izquierda y hacia la derecha empleando las teclas <i>o</i> y <i>p</i> respectivamente. Explicamos el código y más adelante indicamos un problema que se muestra durante la ejecuciñón y cómo solucionarlo.</p>

<p>Lo primero que hacemos es incluir algunos archivos de cabecera correspondientes a la librería z88dk para poder hacer uso de algunas funcionalidades de la librería. El segundo de ellos, <i>ctype.h</i> permite utilizar la función <i>toupper</i>, que devuelve la cadena que se le pasa como parámetro pasada a mayúsculas. El tercero que incluimos, <i>games.h</i>, es el que hemos utilizado hasta ahora para poder utilizar <i>putsprite</i>, que ya sabemos de sobra lo que hace. Y finalmente, el primero de ellos, <i>stdio.h</i>, lo incluimos para poder leer de teclado con la función <i>getk</i>. Evidentemente, también debemos incluir <i>coches.h</i>, pues es donde se definen nuestros sprites, el array que los contiene a todos ellos, y los arrays <i>izquierda</i> y <i>derecha</i> cuyo funcionamiento hemos explicado anteriormente.</p>

<p>Una vez que comienza el programa principal, empezamos a definir variables. En el caso de <i>x</i> e <i>y</i>, su cometido es tan simple como indicarnos en que posición de la pantalla se va a encontrar el coche. Ahora que vamos a tener el coche fijo girando a lo mejor no parece de utilidad, pero luego, más tarde, cuando lo movamos, sí que va a serasí. La última variable que definimos es <i>posicion</i> encargada de indicarnos que sprite estamos dibujando en pantalla. Si el array <i>sprites</i> contiene todos los sprites definidos, al hacer un <i>putsprite</i> de <i>sprites[posicion]</i>, lo que estaremos haciendo es dibujar por pantalla el sprite almacenado en la posición <i>posicion</i> de dicho array. En nuestro caso, esta variable comienza valiendo 0, por lo que cuando ejecutemos el programa, veremos que el coche, nada más empezar, se encuentra preparado para correr orientado hacia la derecha.</p>

<p>Y una vez dibujamos el coche por primera vez, utilizando <i>putsprite</i>, ya estamos preparados para entrar en el bucle principal. Es muy importante fijarse que para el modo de dibujado (primer parámetro de <i>putsprite</i>) estamos utilizando <b>spr_xor</b>, correspondiente a la operación lógica <i>OR EXCLUSIVA</i>. Usamos este modo para poder borrar sprites de una forma muy cómoda. De forma intuitiva, lo único que debemos saber es que si dibujamos un sprite usando or exclusiva en una zona de la pantalla que esté vacía, el sprite se dibujará tal cual en la pantalla. Si dibujamos el sprite usando or exclusiva en una zona de la pantalla donde ese sprite ya estuviera dibujado, se borrará sin modificar el resto de los píxeles de por alrededor, solo se borrarán los píxeles que formen parte del coche.</p>
<p>Por lo tanto, para mover, lo que haremos será dibujar el sprite usando or exclusiva en la misma posición en la que se encontrara anteriormente, y después vovler a dibujar usando or exclusiva en su nueva posición. </p>
<p>El bucle principal se va a ejecutar de forma indefinida (<i>while (1)</i>). En el mismo, leeremos constantemente lo que el usuario introduzca por el teclado utilizando <i>getk</i>. Hemos de tener en cuenta dos cosas: la función <i>getk</i> es no bloqueante, lo cual quiere decir que si el usuario no pulsa ninguna tecla, el programa no se queda detenido en esa instrucción, y utilizamos <i>getk</i> combinado con <i>toupper</i>, que transforma lo que se le pasa como parámetro a mayúsculas, para que el movimiento funcione igual tanto si el usuario pulsa las teclas con el bloqueo mayúsculas activado o sin el. Por eso, dentro del switch, a la hora de comprobar que tecla se ha pulsado, comparamos la entrada con 'O' y 'P' en lugar de con 'o' y 'p'.</p>

<p>Si la tecla que se ha pulsado es la 'o', deseamos girar hacia la izquierda. Dibujamos el coche en la posición actualusando or exclusiva, de tal forma que se borra. Con la línea <i>posicion = izquierda[posicion]</i> lo que hacemos es averiguar que sprite es el que tenemos que dibujar a continuación, según la orientación en la que nos encontremos. Finalmente volvemos a dibujar el coche con las mismas coordenadas (x,y), pero utilizando un sprite distinto, correspondiente a haber girado el coche a la izquierda. En el caso de que se hubiera pulsado la tecla 'p' se realizaría la misma operación, pero utilizando el array <i>derecha</i>.</p>
<p>Ahora ya podemos compilar y ejecutar y comprobaremos como podemos girar nuestro coche pulsando las teclas 'o' y 'p'- Sin embargo, veremos que se produce un efecto extraño. Al mantener una tecla pulsada durante un tiempo, es como si estuviéramos escribiendo en BASIC: se gira una vez, y tras un breve tiempo, ya se gira sin interrupción. Más tarde averiguaremos como resolver este pequeño contratiempo. Antes, veamos como podemos hacer que nuestro coche acelere y frene.</p>
<p>Queremos que pulsando la tecla 'q' el coche vaya acelerando hasta una velocidad máxima (y por lo tanto, que se vaya moviendo conforme a esa velocidad) y que al pulsar la tecla 'a', el coche vaya frenando hasta detenerse. A continuación vemos como lo hemos resuelto, en el siguiente programa, que sustituirá a nuestro anterior <b>movimiento.c</b> (el código en rojo es nuevo):</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

<font color="red">#define CICLOS_BASE 300;</font>

void main(void)
{
        int x = 100;
        int y = 100;
        int posicion = 0;

<font color="red">        int velocidad = 0;
        int ciclos = CICLOS_BASE;</font>

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                switch(toupper(getk()))
                {
<font color="red">                        case 'Q':
                                if (velocidad < 50)
                                {
                                        velocidad = velocidad + 5;
                                }
                                break;
                        case 'A':
                                if (velocidad > 0)
                                {
                                        velocidad = velocidad - 5;
                               }
                                break;</font>
                        case 'O':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = izquierda[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                        case 'P':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = derecha[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                }


<font color="red">                if (velocidad > 0)
                {
                        ciclos = ciclos - velocidad;
                        if (ciclos < 0)
                        {
                                ciclos = CICLOS_BASE;
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                switch(posicion)
                                {
                                        case 0:
                                                x = x + 1;
                                                break;
                                        case 1:
                                y = y - 1;
                                                break;
                                        case 2:
                                                x = x - 1;
                                                break;
                                        case 3:
                                                y = y + 1;
                                                break;
                                        case 4:
                                                x = x + 1;
                                                y = y - 1;
                                              break;
                                        case 5:
                                                x = x + 1;
                                                y = y + 1;
                                                break;
                                        case 6:
                                                x = x - 1;
                                                y = y - 1;
                                                break;
                                        case 7:
                                                x = x - 1;
                                                y = y + 1;
                                                break;
                                }
                                putsprite(spr_xor,x,y,sprites[posicion]);
                        }
                }
        }</font>
}
</pre>
    </p></td></tr>
</table>
<p>Lo más evidente es que necesitaremos una variable, en este caso llamada <i>velocidad</i>, que nos permita almacenar la velocidad del coche en un momento dado. Es importante tener en cuenta que en un principio el coche estará parado, por lo que esta velocidad valdrá cero. Hemos añadido también código que hará que nuestra velocidad aumente o disminuya, hasta una velocidad máxima o mínima, al pulsar las teclas 'q' y 'a', respectivamente (este código es el que se ha añadido dentro del switch).</p>
<p>Lo que a lo mejor queda un poco más esotérico es ver cómo hacemos que el coche, una vez que adquiere velocidad, pueda moverse. La parte del código encargada de esto es la que se encuentra al final. Este código, como es obvio, solo se ejecutará si el coche tiene velocidad. El coche se moverá cuando una variable, llamada <i>ciclos</i>, y a la que se le va restando el valor de la velocidad en cada iteración del bucle principal, llegue a cero. Evidentemente, cuanta mayor sea la velocidad, más rápido llegará <i>ciclos</i> a 0 y cada menos iteraciones del bucle principal se moverá el coche. </p>

<p>Si los ciclos llegan a cero, nos disponemos a mover el coche. Lo primero es volver a hacer que ciclos valga su valor inicial, para volver a comenzar el proceso al terminar de mover. Lo siguiente es borrar el coche de su posición anterior, dibujándolo en dicha posición usando el modo or exclusiva. Y después, con un switch, cambiamos el valor de la coordenada <i>x</i> y/o <i>y</i> según la orientación del coche, dada por la variable <i>posicion</i>. Así, por ejemplo, si <i>posicion</i> vale 0, eso quiere decir que el coche está orientado hacia la derecha, por lo que aumentamos el valor de la coordenada x. Si <i>posicion</i> valiera 4, el coche estaría orientado hacia arriba a la derecha, por lo que disminuiríamos el valor de <i>y</i> y aumentaríamos el de <i>x</i>. Y así con el total de las 8 orientaciones. Finalmente, dibujamos el coche en su nueva posición <i>x</i> e <i>y</i>.</p>

<p>Aquí encontramos varias ventajas con respecto al BASIC. Primero, que los gráficos definidos por el usuario (en este caso, sprites) no tienen por qué estar limitados a un tamaño de 8 por 8, y segundo, que estos sprites pueden moverse utilizando incrementos que sean cualquier múltiplo de un pixel, mientras que en basic debemos mover los UDGs de 8 en 8.</p>
<p>Al ejecutar este programa, veremos como podemos acelerar y frenar, y el coche se moverá, sin ninguna restricción. Si el coche sale de la pantalla, observaremos como este entra por el extremo opuesto y el programa seguirá funcionando sin problemas. Sin embargo, se sigue produciendo el mismo efecto que comentábamos antes, el teclado parece comportarse como si estuviéramos en BASIC... vamos a solucionarlo dándole valor a dos variables del sistema, ¡pero que no se asuste nadie!.</p>
<p>Las variables del sistema se podrían entender como determinadas direcciones de memoría que modifican el comportamiento del sistema según su valor (más información en la Microhobby especial nº2). En nuestro caso concreto, las variables del sistema que vamos a modificar son REPDEL y REPPER, correspondientes a las direcciones de memoria 23561 y 23562. La primera de ellas indica el tiempo en cincuentavos de segundo que se debe tener pulsada una tecla para que esta se comience a repetir, y la segunda indica el tiempo en cincuentavos de segundo que tarda en producirse esta repetición una vez que se comienza. Si le damos un valor de 1 a estas variables, conseguiremos una respuesta dle teclado rápida, y nos desharemos del efecto tan fastidioso que hemos comentado antes.</p>
<p>En el siguiente código se muestran, en rojo, los cambios que deberíamos realizar al comienzo del programa <b>movimiento.c</b>:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

#define CICLOS_BASE 300;

void main(void)
{
        int x = 100;
        int y = 100;
        int posicion = 0;

<font color="red">        char *puntero1 = (char *) 23561;
        char *puntero2 = (char *) 23562;</font>


        int velocidad = 0;
        int ciclos = CICLOS_BASE;

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
<font color="red">                *puntero1 = 1;
                *puntero2 = 1;</font>
                switch(toupper(getk()))
                {
</pre>
    </p></td></tr>
</table>
<p>Al mejorar la respuesta del teclado nos ha surgido un nuevo problema... ¡el coche gira demasiado rápido!. </p>
<p>Será conveniente añadir un contador para que el coche no gire nada más pulsar la tecla correspondiente; mejor que gire cuando la tecle lleve un rato pulsada. A continuación mostramos, en rojo, el código que deberíamos añadir:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
<font color="red">        int girando = 0;
        int contador_izquierda = 0;
        int contador_derecha = 0;</font>
        int velocidad = 0;
        int ciclos = CICLOS_BASE;

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                *puntero1 = 1;
                *puntero2 = 1;

        girando = 0;

                switch(toupper(getk()))
                {
                        case 'Q':
                                if (velocidad < 50)
                                {
                                        velocidad = velocidad + 5;
                                }
                                break;
                        case 'A':
                                if (velocidad > 0)
                                {
                                        velocidad = velocidad - 5;
                                }
                                break;
                        case 'O':
<font color="red">                                contador_derecha = 0;
                                contador_izquierda = contador_izquierda + 1;
                                girando = 1;
                                if (contador_izquierda == 3)
                                {</font>
                                        putsprite(spr_xor,x,y,sprites[posicion]);
                                        posicion = izquierda[posicion];
                                        putsprite(spr_xor,x,y,sprites[posicion]);
<font color="red">                                        contador_izquierda = 0;
                                }</font>

                                break;
                       case 'P':
<font color="red">                                contador_izquierda = 0;
                                contador_derecha = contador_derecha + 1;
                                girando = 1;
                                if (contador_derecha == 3)
                                {</font>
                                        putsprite(spr_xor,x,y,sprites[posicion]);
                                        posicion = derecha[posicion];
                                        putsprite(spr_xor,x,y,sprites[posicion]);
<font color="red">                                        contador_derecha = 0;
                                 }</font>
                                 break;
                }

<font color="red">                if (girando == 0)
                {
                        contador_izquierda = 0;
                        contador_derecha = 0;
                }</font>


                if (velocidad > 0)
                {
</pre>
    </p></td></tr>
</table>
<p>Nos vamos a basar en tres nuevas variables, <i>girando</i>, <i>contador_izquierda</i> y <i>contador_derecha</i>. Las dos últimas son las que nos van a indicar cuándo hacer el giro. Cada vez que le demos a la tecla de giro a la izquierda, aumentará el valor de <i>contador_izquierda</i>, y cada vez que le demos a la tecla de giro a la derecha, aumentará el valor de <i>contador_derecha</i>. Cuando alguna de ellas valga 3, giraremos a la izquierda o a la derecha, respectivamente. </p>

<p>Una medida que tomamos es que al girar hacia la izquierda, ponemos a cero la variable <i>contador_derecha</i>, que nos dice cuanto tiempo hemos estado girando a la derecha, y viceversa, cuando giramos a la derecha, ponemos a cero la variable <i>contador_izquierda</i>, que nos dice cuánto hemos girado hasta la izquierda hasta el momento. Así evitamos que, en el caso de haber estado girando hacia la izquierda durante un tiempo, por ejemplo, empecemos a girar a la derecha, y que tan solo haga falta rozar la tecla de giro izquierda para volver a girar a la izquierda, lo cual no es demasiado real. </p>
<p>Otra medida que tomamos está relacionada con la variable <i>girando</i>. Si dejamos de pulsar las teclas de giro, no es demasiado real que si volvemos a pulsarlas otra vez pasado un rato y durante muy poco tiempo, giremos. Para solucionar esto, lo que hacemos simplemente es: darle a la variable <i>girando</i> el valor 0 cada vez que entramos en el bucle, darle el valor 1 en el caso de que pulsemos giro izquierda o giro derecha, y por último, poner <i>contador_izquierda</i> y <i>contador_derecha</i> a cero en el caso de que no se haya girado en esa iteración, y por lo tanto, en el caso de que <i>girando</i> valga cero... es bastante sencillo de comprender.</p>

<p>¿Y ya está? ¡No! Más problemas se interponen entre nosotros y un sprite en movimiento. Si ejecutamos el código anterior veremos como el coche... ¡no gira! ¿Es que hemos hecho algo mal? No, la algoritmia está bien, pero tenemos un problema de interrupciones. El programa no espera a que pulsemos una tecla, por lo que a lo mejor nosotros estamos pulsando la tecla P todo el rato, pero el programa no llega a leer el teclado a tiempo y <i>girando</i> vuelve a valer 0.</p>
<p>Vamos a hacer que el bucle principal solo avance cuando se produzca una interrupción. Dichas interrupciones se producirán en dos casos, cuando pulsemos una tecla (lo cual es lo que queremos) y cuando vaya a comenzar el refresco de la pantalla (cuando el haz de electrones se sitúe de nuevo en el punto 0,0 de la pantalla para empezar a dibujar, de izquierda a derecha y de arriba a abajo). Para ello tendremos que utilizar... ¡ensamblador!. Pero no hay que preocuparse, porque lo solucionaremos todo con una línea de código.</p>
<p>La instrucción en ensamblador que detiene la ejecución hasta que se produce una interrupción es <i>HALT</i>. Y en z88dk, ejecutar una instrucción en ensamblador en cualquier momento es tan sencillo como hacer uso de la función <b>asm</b>, que recibe como parámetro una cadena conteniendo la instrucción que deseamos ejecutar. Por lo tanto, resolver de una vez por todas nuestros problemas de movimiento es tan simple como colocar la instrucción <i>asm("HALT")</i> en los lugares adecuados. A continuación se muestra todo el código de <b>movimiento.c</b> tal como quedaría después de los cambios (marcados en rojo).</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

#define CICLOS_BASE <font color="red">20</font>;

void main(void)
{
    int x = 100;
    int y = 100;
    int posicion = 0;

    char *puntero1 = (char *) 23561;
    char *puntero2 = (char *) 23562;


    int girando = 0;
    int contador_izquierda = 0;
    int contador_derecha = 0;
    int velocidad = 0;
    int ciclos = CICLOS_BASE;

    putsprite(spr_xor,x,y,sprites[0]);

    while(1)
    {
        *puntero1 = 1;
        *puntero2 = 1;
        <font color="red">asm("halt");</font>

        girando = 0;

        switch(toupper(getk()))
        {
            case 'Q':
                if (velocidad < <font color="red">30</font>)
                {
                    velocidad = velocidad + <font color="red">1</font>;
                }
                break;
            case 'A':
                if (velocidad > 0)
                {
                    velocidad = velocidad - <font color="red">1</font>;
                }
                break;
            case 'O':
                contador_derecha = 0;
                contador_izquierda = contador_izquierda + 1;
                girando = 1;
                if (contador_izquierda == 3)
                {
                    <font color="red">asm("halt");</font>

                    putsprite(spr_xor,x,y,sprites[posicion]);
                    posicion = izquierda[posicion];
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    contador_izquierda = 0;
                }
                break;
            case 'P':
                contador_izquierda = 0;
                                contador_derecha = contador_derecha + 1;
                                girando = 1;
                                if (contador_derecha == 3)
                                {
                    <font color="red">asm("halt");</font>
                                    putsprite(spr_xor,x,y,sprites[posicion]);
                                    posicion = derecha[posicion];
                                    putsprite(spr_xor,x,y,sprites[posicion]);
                                        contador_derecha = 0;
                                 }
                                 break;
        }

                if (girando == 0)
            {
                contador_izquierda = 0;
                contador_derecha = 0;
        }


        if (velocidad > 0)
        {
            ciclos = ciclos - velocidad;
            if (ciclos < 0)
            {
                ciclos = CICLOS_BASE;
                <font color="red">asm("halt");</font>
                putsprite(spr_xor,x,y,sprites[posicion]);
                switch(posicion)
                {
                    case 0:
                        x = x + 1;
                        break;
                    case 1:
                y = y - 1;
                        break;
                    case 2:
                        x = x - 1;
                        break;
                    case 3:
                        y = y + 1;
                        break;
                    case 4:
                        x = x + 1;
                        y = y - 1;
                        break;
                    case 5:
                        x = x + 1;
                        y = y + 1;
                        break;
                    case 6:
                        x = x - 1;
                        y = y - 1;
                        break;
                    case 7:
                        x = x - 1;
                        y = y + 1;
                        break;
                }
                putsprite(spr_xor,x,y,sprites[posicion]);
            }
        }
    }
}
</pre>
    </p></td></tr>
</table>
<p>Como se puede comprobar, se ha incluido un <i>halt</i> antes de la lectura de teclado, para detener el programa hasta que se pulse una tecla, y después se ha incluido un <i>halt</i> antes de borrar y volver a dibujar el sprite, para esperar el refresco de la pantalla. Como consecuencia, el coche irá más lento, es por ello que también hemos modificado el valor de <i>CICLOS_BASE</i>, la velocidad máxima, y el incremento y decremento de la velocidad. ¿Y os habeis fijado? Gracias a que hemos sincronizado el movimiento del coche con el refresco de la pantalla... ¡este ha dejado de parpadear al moverse!</p>

<p>Por último, una cosa curiosa: si mientras movemos el coche pasamos por encima de donde pone <i>Bytes: movimiento</i> (correspondiente a la carga desde cinta) veremos como el borrado y la escritura del sprite del coche no afecta en lo mas mínimo a los píxeles que forman parte de ese texto; esto es sin duda otra de las grandes ventajas de usar el modo de dibujado de sprites or exclusiva.</p>
<p><b>Y ahora, pongamos el coche en una pista</b></p>
<p>Por último vamos a dibujar una pista de neumáticos para limitar un poco el movimiento de nuestro bólido. Vamos además a hacerlo de tal forma que sea muy fácil modificar el trazado, y así la diversión se multiplique durante meses. Si recordamos, el último de los sprites que habíamos definido era el correspondiente a un neumático. Este sprite, com todos los anteriores, tiene un tamaño de 10x10 (quizá un poco grande, para hacer circuitos más complicados quizas no hubiera estado mal utilizar sprites de neumáticos más pequeños). </p>
<p>Dentro de <b>coches.h</b> es donde definiremos el trazado de la pista. Si consideramos la pantalla como un array de 18x24 casillas de tamaño 10x10 (el mismo que los neumáticos), podemos indicar el recorrido de la pista creando un array, donde colocaremos ceros en aquellas casillas donde no vaya a haber neumático, y unos en las casillas en las que sí. Al principio de <b>coches.h</b> definimos unas constantes para el tamaño del circuito:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
#define ALTURA_CIRCUITO 18
#define ANCHURA_CIRCUITO 24
</pre>
    </p></td></tr>
</table>
<p>y al final del mismo archivo incluimos el siguiente array:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
short circuito1[] =  { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0 };
short circuito2[] =  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 0, 0, 0, 0 };
short circuito3[] =  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 0, 0 };
short circuito4[] =  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0 };
short circuito5[] =  { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito6[] =  { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito7[] =  { 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito8[] =  { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito9[] =  { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito10[] = { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 1, 0 };
short circuito11[] = { 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 1, 0, 0 };
short circuito12[] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0 };
short circuito13[] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0 };
short circuito14[] = { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0 };
short circuito15[] = { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 0 };
short circuito16[] = { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 0, 0, 0, 0, 0 };
short circuito17[] = { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0 };
short circuito18[] = { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0 };

short int *circuito[ALTURA_CIRCUITO] = {circuito1, circuito2, circuito3, circuito4,
    circuito5, circuito6, circuito7, circuito8, circuito9, circuito10, circuito11,
    circuito12, circuito13, circuito14, circuito15, circuito16, circuito17,
    circuito18};
</pre>

    </p></td></tr>
</table>
<p>Con un poco de imaginación podemos vislumbrar en ese array un circuito cerrado en forma de O. Si ahora creamos un fichero llamado <b>juego.c</b>, que contenga el mismo código que <i>movimiento.c</i>, pero añadiéndole el que aperece en color rojo a continuación, podremos por fin ver nuestor circuito en la pantalla, tal como se ve en la siguiente imagen:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
void main(void)
{
        int x = 100;
        int y = <font color="red">140</font>;
        int posicion = 0;
<font color="red">        short int i;
        short int j;</font>

        char *puntero1 = (char *) 23561;
        char *puntero2 = (char *) 23562;

        int girando = 0;
        int contador_izquierda = 0;
        int contador_derecha = 0;
        int velocidad = 0;
        int ciclos = CICLOS_BASE;

<font color="red">        for (i=0;i<30;i++)
                printf("\n");

        for (i=0;i&lt;ALTURA_CIRCUITO;i++)
                for (j=0;j&lt;ANCHURA_CIRCUITO;j++)
                        if (circuito[i][j] == 1)
                                putsprite(spr_xor,j*10+1,i*10+1,sprites[8]);
</font>

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                *puntero1 = 1;
                *puntero2 = 1;
                asm("halt");
</pre>
    </p></td></tr>
</table>


<table border="0" cellspacing="0" cellpadding="2" width="320">
	<tr align="right">
		<td><img src="img/z88dk7_4.png" width="320" height="240"  alt="Figura 4. Nuestro coche dispuesto a ser el rey de la pista" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Figura 4. Nuestro coche dispuesto a ser el rey de la pista</td>
	</tr>
</table>


<p>Hay que tener en cuenta que hemos cambiado el valor inicial de la coordenada y del coche para que éste quede dentro de la pista. También hemos creado dos variables, <i>i</i> y <i>j</i> que nos van a servir de contadores en un par de bucles.</p>
<p>Este par de bucles son los dos que se muestran en rojo. En el primero lo único que hacemos es escribir en la pantalla 30 líneas en blanco para borrarla (es por eso que en la captura anterior ya no se ve lo de <i>Bytes: juego.tap</i> que molestaba tanto). Es en el segundo en el que dibujamos el circuito.</p>
<p>Si hemos decidido anteriormente que el array <i>circuito</i> nos iba a indicar si en cada celda de 10x10 píxeles en las que dividíamos la pantalla había o no un neumático, lo que haremos para dibujar la pista no es más que recorrer todas las posiciones del array y dibujar en la pantalla un neumático en la posición <i>i*10+1</i>, <i>j*10+1</i>, siendo <i>i</i> y <i>j</i> las coordenadas dentro del array donde hemos leído un 1.</p>

<p>De acuerdo, ya tenemos un coche moviéndose y un circuito... pero cuando el coche llega hasta alguno de los neumáticos, en lugar de producirse una espectacular explosión, lo atraviesa como si nada y sigue su camino. Tenemos, sin duda, que añadir colisiones.</p>
<p>Para detectar cuando nuestro coche colisiona con uno de los neumáticos que forman parte de los límites de la pista, deberemos añadir una condición <i>if</i> antes de cada desplazamiento del mismo, de tal forma que si ese desplazamiento va a provocar que coche y neumático entren en contacto, el coche se pare totalmente (dada la poca velocidad a la que se ha programado el coche en nuestro programa, y a nuestra incapacidad de momento para crear grandes explosiones usando z88dk en el Spectrum, vamos a suponer que al contactar con un neumático el coche solamente queda parado).</p>
<p>A continuación mostrmos lo que sería el código <i>completo</i> de <b>juego.c</b>, con las partes nuevas en color rojo, como siempre:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

#define CICLOS_BASE 20;

void main(void)
{
    int x = 100;
    int y = 140;
    int posicion = 0;
    short int i;
    short int j;

    char *puntero1 = (char *) 23561;
    char *puntero2 = (char *) 23562;

    int girando = 0;
    int contador_izquierda = 0;
    int contador_derecha = 0;
    int velocidad = 0;
    int ciclos = CICLOS_BASE;

    for (i=0;i<30;i++)
        printf("\n");

    for (i=0;i<ALTURA_CIRCUITO;i++)
        for (j=0;j<ANCHURA_CIRCUITO;j++)
            if (circuito[i][j] == 1)
                putsprite(spr_xor,j*10+1,i*10+1,sprites[8]);


    putsprite(spr_xor,x,y,sprites[0]);

    while(1)
    {
        *puntero1 = 1;
        *puntero2 = 1;
        asm("halt");

        girando = 0;

        switch(toupper(getk()))
        {
            case 'Q':
                if (velocidad < 30)
                {
                    velocidad = velocidad + 1;
                }
                break;
            case 'A':
                if (velocidad > 0)
                {
                    velocidad = velocidad - 1;
                }
                break;
            case 'O':
                contador_derecha = 0;
                contador_izquierda = contador_izquierda + 1;
                girando = 1;
                if (contador_izquierda == 3)
                {
                    asm("halt");
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    posicion = izquierda[posicion];
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    contador_izquierda = 0;
                }
                break;
            case 'P':
                contador_izquierda = 0;
                contador_derecha = contador_derecha + 1;
                girando = 1;
                if (contador_derecha == 3)
                {
                    asm("halt");
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    posicion = derecha[posicion];
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    contador_derecha = 0;
                }
                break;
        }

        if (girando == 0)
        {
            contador_izquierda = 0;
            contador_derecha = 0;
        }

        if (velocidad > 0)
        {
            ciclos = ciclos - velocidad;
            if (ciclos < 0)
            {
                ciclos = CICLOS_BASE;
                asm("halt");
                putsprite(spr_xor,x,y,sprites[posicion]);
                switch(posicion)
                {
                    case 0:
<font color="red">
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1))

                            velocidad = 0;
                        else</font>
                            x = x + 1;
                        break;
                    case 1:
<font color="red">
                        if (circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else</font>

                            y = y - 1;
                        break;
                    case 2:
<font color="red">
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1))

                            velocidad = 0;
                        else</font>
                            x = x - 1;
                        break;
                    case 3:
<font color="red">
                        if (circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else</font>
                            y = y + 1;
                        break;
                    case 4:

<font color="red">
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {</font>
                            x = x + 1;
                            y = y - 1;
<font color="red">                        }</font>
                        break;
                    case 5:
<font color="red">
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {</font>

                            x = x + 1;
                            y = y + 1;
<font color="red">                        }</font>
                        break;
                    case 6:
<font color="red">
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                            circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {</font>
                            x = x - 1;
                            y = y - 1;

<font color="red">                        }</font>
                        break;
                    case 7:
<font color="red">
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                            circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {            </font>
                            x = x - 1;
                            y = y + 1;
<font color="red">                        }</font>

                        break;
                }
                putsprite(spr_xor,x,y,sprites[posicion]);
            }
        }
    }
}
</pre>
    </p></td></tr>
</table>
<p>Simplemente, antes de mover el coche, en la última parte del bucle principal, comprobamos si va a haber una colisión con alguno de los neumáticos. En el caso de que sea así ponemos la velocidad a cero, y en caso contrario realizamos el movimiento de forma normal. En todas las comprobaciones miramos a ver si en la posición del array circuito correspondiente a donde estaría mas o menos situado el coche (recordemos que en <i>circuito</i> cada posición se corresponde con 10x10 píxeles de la pantalla) hay un 1. </p>
<p>Analicemos, por ejemplo, para el <i>case 0</i>, que se corresponde con el coche moviéndose hacia la derecha, y el resto de condiciones se podrá sacar de la misma forma (hemos de aclarar que en los cuatro últimos <i>case</i>, al tratarse de movimientos diagonales, la comprobación debe ser en los dos sentidos, eje <i>x</i> y eje <i>y</i>):</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
if (circuito[y/10][(x + 9)/10] == 1 ||
    (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1))
</pre>
    </p></td></tr>
</table>
<p>Básicamente la comprobación se compone de dos partes, la que está a la izquierda del OR (que en C, recordemos, se codifica con ||) y la que está a la derecha. Si en el array <i>circuito</i> decíamos que cada posición se correspondía con una región de 10x10 píxeles de la pantalla, cuando el coche está en las coordenadas <i>(y,x)</i>, tendríamos que comprobar en la posición <i>(y/10,x/10)</i> del array <i>circuito</i> (en C, las divisiones enteras se redondean hacia abajo). </p>

<p>La anchura y la altura del coche es 10, por lo tanto, si queremos movernos hacia la derecha, aumentando el valor de <i>x</i> en 1, debemos comprobar si el pixel situado en el extremo derecho, es decir, el pixel situado en <i>x+11</i> , estará en contacto con algún pixel de algún neumático. Esto es equivalente a comprobar si en la posición <i>[y/10][(x+11)/10]</i> de <i>circuito</i> hay almacenado un 1. Si es así habrá colisión, por lo que no nos interesará avanzar, se cumplirá la condición, y <i>velocidad</i> pasará a valer 0. Lo que ocurre es que en nuestro caso, en lugar de <i>x+11</i> hemos usado <i>x+9</i> ya que, por ensayo y error hemos comprobado que con este valor el coche solo colisionara cuando este totalmente pegado al neumático (nuestros sprites son de 10x10, pero algunos de ellos no ocupan toda la anchura o toda la altura).</p>

<p>Esto estaría bien si el coche solo pudiera moverse en el eje <i>y</i> en múltiplos de 10, pero esto no siempre es así. Si el coche estuviera en <i>(12,12)</i> (valiendo 12 la coordenada <i>y</i>, por lo tanto), al movernos a la derecha, podríamos colisionar con un neumático almacenado en el array <i>circuito</i> en <i>(1,2)</i>, pero también con el que estuviera en <i>(2,2)</i> (el de abajo). Por lo tanto, la segunda condición comprueba si, en el caso de que la coordenada <i>y</i> no tenga un valor múltiplo de 10 (es decir, cuando el resultado de la operación resto, especifacada en C con % y que calcula el resto de la división entera, devuelva un valor distinto de cero), habría colisión con un neumático situado abajo a la derecha. Como en el caso de la <i>x</i>, en lugar de sumar 11 a <i>y</i>, añadimos un valor calculado a ojo que nos asegura que el coche quedaría pegadito en el caso de una colisión vertical.</p>

<p>Se podrían cumplir las dos condiciones a la vez, pero nos es indiferente, con que se cumpla una de las dos ya hay colisión.</p>
<p>En el caso de movernos hacia la izquierda, en lugar de sumar a <i>x</i> restamos, y en el caso de movernos hacia arriba o hacia abajo, hacemos lo mismo pero cambiando lo que sumamos o restamos a <i>x</i> por lo que sumamos o restamos a <i>y</i> y viceversa. </p>
<p>¿Y eso es todo? Bueno... hemos de ser sinceros y admitir que debido a la inclusión del código que detecta las colisiones, ha vuelto el parpadeo del coche al moverse, sobre todo por la parte superior de la pantalla. No le da tiempo al programa a sincronizar el movimiento con el refresco de la pantalla, debido a lo complejo de los cálculos. Esto, a grandes rasgos, se puede mejorar, aunque solo sea un poco, creando dos nuevas variables, <i>x_anterior</i> e <i>y_anterior</i>, y dejando el código de detección de colisiones de la siguiente manera (calculando las colisiones antes de esperar el refresco de la pantalla y borrar y dibujar el sprite):</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
        if (velocidad > 0)
        {
            ciclos = ciclos - velocidad;
            if (ciclos < 0)
            {
                ciclos = CICLOS_BASE;
<font color="red">                y_anterior = y;
                x_anterior = x;</font>
                switch(posicion)
                {
                    case 0:
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1))

                            velocidad = 0;
                        else
                            x = x + 1;
                        break;
                    case 1:
                        if (circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                            y = y - 1;
                        break;
                    case 2:
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1))

                            velocidad = 0;
                        else
                            x = x - 1;
                        break;
                    case 3:
                        if (circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                            y = y + 1;
                        break;
                    case 4:
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x + 1;
                            y = y - 1;
                        }
                        break;
                    case 5:
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x + 1;
                            y = y + 1;
                        }
                        break;
                    case 6:
                        if (circuito[y/10][(x-2)/10] == 1 ||
                        (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                        circuito[(y-2)/10][x/10] == 1 ||
                        (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x - 1;
                            y = y - 1;
                        }
                        break;
                    case 7:
                        if (circuito[y/10][(x-2)/10] == 1 ||
                        (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                        circuito[(y+9)/10][x/10] == 1 ||
                        (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x - 1;
                            y = y + 1;
                        }
                        break;
                }

<font color="red">                asm("halt");
                putsprite(spr_xor,x_anterior,y_anterior,sprites[posicion]);</font>
                putsprite(spr_xor,x,y,sprites[posicion]);
            }
        }
</pre>
    </p></td></tr>
</table>
<p><b>¿Y ahora qué?</b></p>
<p>Bueno, parece que al final lo hemos conseguido: tenemos un coche moviéndose por la pista, que se choca con los bordes del circuito y puede acelerar y frenar... tomando este código como base, podríamos crear nuestro fantástico juego de coches, añadir nuevas pistas, contrincantes, etc. Sin embargo, hemos comprobado ciertas limitaciones en el código de dibujado de sprites que se suministra con z88dk, sobre todo en <i>juego.c</i>, donde se produce un ligero parpadeo del coche cuando este se mueve por la parte superior. En próximos artículos estudiaremos alguna librería que nos puede ayudar a superar el trance... pero mientras, ¡a conducir!.</p>
<p>Me gustaría agradecer tanto a Horace como a NoP por los comentarios realizados y la ayuda que me han prestado durante la realización de este artículo.</p>

<b>LINKS</b>
</p>
<ul>
    <li><a href="src/z88dk_coches.zip" onClick="window.open(this.href); return false;">Código fuente de los ejemplos</a></li>
</ul>
</div>
        </td>
    </tr>
    <tr>
        <td align="right"><br><br>SIEW</td>

    </tr>
</table>
                    </td>
                </tr>
                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td>
<script language="JavaScript">
function RecargarPie(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">

        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('el-aventurero.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
        <option value="index.html">Portada</option>
        <option value="editorial.html">Índice - Editorial</option>
        <option value="panorama.html">Panorama</option>
        <option value="analisis.html">Análisis</option>

        <option value="al-descubierto.html">Al Descubierto</option>
        <option value="hardware.html">Hardware</option>
        <option value="basic.html">Programación BASIC</option>
        <option value="el-aventurero.html">El Aventurero</option>
        <option value="z88dk.html" selected>Programación Z88DK</option>
        <option value="input.html">INPUT</option>

        <option value="ensamblador.html">Programación Ensamblador</option>
        <option value="opinion.html">Opinión</option>
    </select>
    <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">" />
</td>
            <td align="right" class="texto">
                <a href="#arriba">Volver arriba</a>
            </td>

        </tr>
        <tr><td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>
    </form>
</table>
                    </td>
                </tr>
                <tr>

                    <td>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
	<tr align="center" valign="center">
		<td>2003-2009 Magazine ZX</td>
	</tr>
</table>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-8018503-4");
pageTracker._trackPageview();
} catch(err) {}</script>
                    </td>

                </tr>
            </table>

    </body>
</html>
