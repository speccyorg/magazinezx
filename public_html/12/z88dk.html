<!doctype html>
<html lang="es">
<head>
    <title>Programación Z88DK - Magazine ZX número 12 - Septiembre 2005</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/magazine.css" type="text/css">
</head>
<body>
<table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
    <tr>
        <td>
            <a name="arriba"></a>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
                <tr align="center" valign="center">
                    <td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0"/></a></td>
                </tr>
            </table>
        </td>

    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarCabecera(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>

                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('el-aventurero.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>

                                <option value="al-descubierto.html">Al Descubierto</option>
                                <option value="hardware.html">Hardware</option>
                                <option value="basic.html">Programación BASIC</option>
                                <option value="el-aventurero.html">El Aventurero</option>
                                <option value="z88dk.html" selected>Programación Z88DK</option>
                                <option value="input.html">INPUT</option>

                                <option value="ensamblador.html">Programación Ensamblador</option>
                                <option value="opinion.html">Opinión</option>
                            </select>
                            <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                        </td>
                        <td align="center" class="texto">Número 12 - Septiembre 2005</td>
                        <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX"
                                             onClick="window.open(this.href); return false;"><img
                                src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0"
                                alt="ZX Certified webmaster"></a> <a href="http://www.speccy.org/"
                                                                     onClick="window.open(this.href); return false;"><img
                                src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a>
                        </td>
                    </tr>

                </form>
            </table>
            </a>
        </td>
    </tr>
    <tr>
        <td> </td>
    </tr>
    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
                <tr>

                    <td>
                        <div align="justify">
                            <p align="center"><font size="5">¡MIS SPRITES SE MUEVEN!</font></p>
                            <p>En el artículo anterior aprendimos cómo definir sprites y dibujarlos en pantalla
                                utilizando la librería z88dk sin recurrir a ninguna otra herramienta externa (a menos
                                que quisiéramos dibujar los sprites utilizando algún programa como los mostrados en el
                                número anterior). En esta entrega vamos a ir un poco más allá y vamos a permitir que el
                                usuario pueda mover algún sprite por la pantalla, y que este sprite pueda interaccionar
                                con otros elementos, colisionando con ellos.</p>
                            <p><b>¿Qué vamos a hacer?</b></p>
                            <p>Para aprender los conceptos que necesitamos vamos a programar lo que podría ser el código
                                inicial de un juego de carreras de coches, tipo Super Sprint, en los que desde una vista
                                cenital podemos ver el circuito y los distintos participantes. Crearemos un coche
                                utilizando diversos sprites, según hacia donde se esté moviendo el mismo, y crearemos
                                una pista por donde el coche podrá moverse. Evidentemente, esta pista marcará el límite
                                de movimiento de nuestro bólido, por lo que deberemos implementar también algún
                                mecanismo para colisiones, de tal manera que al vehículo le pase algo al contactar con
                                los límites del circuito. Sin más, empecemos.</p>
                            <p><b>Definiendo los sprites</b></p>
                            <p>Hasta ahora hemos visto como crear sprites de un tamaño límite de 8x8. Sin embargo, por
                                mucho que lo intentemos, va a ser un poco difícil crear un sprite que represente algo
                                aproximado a un coche con una rejilla tan pequeña. Si nos fijamos en la siguiente
                                imagen, observaremos que tanto para representar al coche en todas las posibles
                                orientaciones, así como los neumáticos que van a formar parte de los límites de la
                                pista, necesitamos utilizar sprites de 10x10. ¿Cómo creamos sprites mayores de 8x8
                                usando z88dk?</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="400">

                                <tr align="right">
                                    <td><img src="img/z88dk7_1.png" width="400" height="400"
                                             alt="Figura 1: Los sprites que vamos a utilizar en nuestro juego. Representan todas las posibles orientaciones del coche, excepto el último de todos, que representa un neumático. Todos ellos tienen un tamaño de 10x10"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Figura 1: Los sprites que vamos a utilizar en
                                        nuestro juego. Representan todas las posibles orientaciones del coche, excepto
                                        el último de todos, que representa un neumático. Todos ellos tienen un tamaño de
                                        10x10
                                    </td>
                                </tr>
                            </table>

                            <p>Según vimos anteriormente, un sprite se definía en z88dk como un array de char del
                                tipo:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
char sprite0[] = { 8, 8, 0x18 , 0x24 , 0x42 , 0x81 , 0xA5 , 0x81 , 0x7E , 0x00 };
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>donde los dos primeros valores indicaban la altura y la anchura, respectivamente, y los
                                siguientes valores representaban a cada una de las filas del sprite. Si cada columna
                                tenía asignado un valor hexadecimal (estos valores eran, para una anchura de 8, y de
                                derecha a izquierda, los siguientes: 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80), el
                                valor para cada fila era la suma de los valores hexadecimales para los que el pixel
                                correspondiente valía 1.</p>
                            <p>Para sprites de más de anchura 8, y hata una anchura de 16, en ese array de caracteres
                                cada fila se va a representar por un par de números hexadecimales. El primer valor de
                                esa pareja se va a corresponder con los 8 primeros píxeles empezando por la izquierda de
                                la columna, y el segundo con el resto.</p>
                            <p>En el caso de los sprites que vemos en la figura anterior, donde cada columna tiene una
                                anchura de diez píxeles, cada fila se representaría también por una pareja de valores
                                hexadecimales. Con la primera pareja codificamos los ocho píxeles de la izquierda, de la
                                misma forma en que lo hacemos con sprites de anchura hasta 8, y con la segunda pareja
                                codificamos los otros dos pixeles que quedan a la derecha (siendo el valor 0x80 el
                                correspondiente al primero y el valor 0x40 el correspondiente al segundo. Si hubiese más
                                de dos, seguiríamos asignando los valores 0x20, 0x10, 0x08, 0x04 y etc. a los
                                siguientes). En la siguiente imagen vemos un ejemplo.</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="576">

                                <tr align="right">
                                    <td><img src="img/z88dk7_2.png" width="576" height="377"
                                             alt="Figura 2: cálculo de los valores hexadecimales correspondientes a cada una de las filas del sprite 0"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Figura 2: cálculo de los valores hexadecimales
                                        correspondientes a cada una de las filas del sprite 0
                                    </td>
                                </tr>
                            </table>

                            <p>Podríamos ser malvados y dejar como ejercicio al lector que calcule cómo se codificarían
                                el resto de sprites, pero vamos a ahorrarle el mal trago. A continuación incluímos el
                                código que codifica todos los sprites anteriores, que deberemos introducir dentro de un
                                archivo de cabecera llamado <b>coches.h</b>:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
char sprite0[] = { 10, 10, 0x00 , 0x00 , 0x73 , 0x80 , 0xFF , 0x40 , 0xB9 ,
     0xC0 , 0xB9 , 0xC0 , 0xB9 , 0xC0 , 0xB9 , 0xC0 , 0xFF , 0x40 , 0x73 ,
     0x80 , 0x00 , 0x00  };
char sprite1[] = { 10, 10, 0x3F , 0x00 , 0x5E , 0x80 , 0x7F , 0x80 , 0x61 ,
     0x80 , 0x21 , 0x00 , 0x3F , 0x00 , 0x7F , 0x80 , 0x7F , 0x80 , 0x61 ,
     0x80 , 0x3F , 0x00  };
char sprite2[] = { 10, 10, 0x00 , 0x00 , 0x73 , 0x80 , 0xBF , 0xC0 , 0xE7 ,
     0x40 , 0xE7 , 0x40 , 0xE7 , 0x40 , 0xE7 , 0x40 , 0xBF , 0xC0 , 0x73 ,
     0x80 , 0x00 , 0x00  };
char sprite3[] = { 10, 10, 0x3F , 0x00 , 0x61 , 0x80 , 0x7F , 0x80 , 0x7F ,
     0x80 , 0x3F , 0x00 , 0x21 , 0x00 , 0x61 , 0x80 , 0x7F , 0x80 , 0x5E ,
     0x80 , 0x3F , 0x00  };
char sprite4[] = { 10, 10, 0x0F , 0x00 , 0x1D , 0x80 , 0x13 , 0xC0 , 0x79 ,
     0x40 , 0xFC , 0xC0 , 0xBE , 0xC0 , 0xDF , 0x80 , 0x6E , 0x00 , 0x36 ,
     0x00 , 0x1C , 0x00  };
char sprite5[] = { 10, 10, 0x1C , 0x00 , 0x36 , 0x00 , 0x6E , 0x00 , 0xDF ,
     0x80 , 0xBE , 0xC0 , 0xFC , 0xC0 , 0x79 , 0x40 , 0x13 , 0xC0 , 0x1D ,
     0x80 , 0x0F , 0x00  };
char sprite6[] = { 10, 10, 0x3C , 0x00 , 0x6E , 0x00 , 0xF2 , 0x00 , 0xA7 ,
     0x80 , 0xCF , 0xC0 , 0xDF , 0x40 , 0x7E , 0xC0 , 0x1D , 0x80 , 0x1B ,
     0x00 , 0x0E , 0x00  };
char sprite7[] = { 10, 10, 0x0E , 0x00 , 0x1B , 0x00 , 0x1D , 0x80 , 0x7E ,
     0xC0 , 0xDF , 0x40 , 0xCF , 0xC0 , 0xA7 , 0x80 , 0xF2 , 0x00 , 0x6E ,
     0x00 , 0x3C , 0x00  };
char sprite8[] = { 10, 10, 0x1E , 0x00 , 0x7F , 0x80 , 0x7F , 0x80 , 0xF3 ,
     0xC0 , 0xE1 , 0xC0 , 0xE1 , 0xC0 , 0xF3 , 0xC0 , 0x7F , 0x80 , 0x7F ,
     0x80 , 0x1E , 0x00  };
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Y a continuación indicamos el código de un pequeño programa, que llamaremos
                                <b>coches.c</b>, que lo único que hará será mostrar por pantalla todos los sprites para
                                comprobar que quedan bonitos. Para ello hacemos uso de la función <i>putsprite</i>, cuya
                                sintaxis se explicó en el artículo anterior:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
#include "games.h"
#include "coches.h"

void main(void)
{
        putsprite(spr_or,1,41,sprite0);
        putsprite(spr_or,21,41,sprite1);
        putsprite(spr_or,41,41,sprite2);
        putsprite(spr_or,61,41,sprite3);
        putsprite(spr_or,1,61,sprite4);
        putsprite(spr_or,21,61,sprite5);
        putsprite(spr_or,41,61,sprite6);
        putsprite(spr_or,61,61,sprite7);
        putsprite(spr_or,1,81,sprite8);
}
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>El archivo de cabecera <i>games.h</i> debe ser incluido si queremos utilizar
                                <i>putsprite</i>. En la siguiente imagen vemos la salida de este programa.</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="320">
                                <tr align="right">

                                    <td><img src="img/z88dk7_3.png" width="320" height="240"
                                             alt="Figura 3. Los sprites mostrándose en la pantalla de nuestro Spectrum (o de nuestro emulador)"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Figura 3. Los sprites mostrándose en la pantalla
                                        de nuestro Spectrum (o de nuestro emulador)
                                    </td>
                                </tr>
                            </table>

                            <p><b>Añadiendo movimiento</b></p>
                            <p>Hacer que un sprite se mueva por pantalla es tan sencillo como borrarlo de donde se
                                encontraba anteriormente y volver a dibujarlo en una nueva posición. Lo interesante será
                                hacer que nuestro coche cambie de aspecto según la orientación en la que se esté
                                moviendo.</p>

                            <p>Para conseguir esto último, es decir, que se nos muestre un sprite distinto del coche
                                según se esté moviendo hacia arriba, hacia abajo, etc., debemos añadir un par de cambios
                                al archivo <b>coches.h</b>. Lo primero que vamos a hacer es almacenar todos los sprites
                                en un único array de arrays de chars (es decir, en un único array de sprites). Esto lo
                                hacemos colocando después de la definición de los diferentes sprites en <i>coches.h</i>
                                una línea como la siguiente:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
char *sprites[9] = { sprite0 , sprite1 , sprite2 , sprite3 , sprite4 , sprite5 ,
    sprite6 , sprite7 , sprite8 };
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>De tal forma que podremos acceder al sprite <i>i</i> utilizando, por ejemplo, <i>sprites[i]</i>
                                en lugar de <i>spritei</i>, lo cual nos va a ser de mucha utilidad. Justo después de
                                esta línea, introducimos las dos líneas siguientes en <i>coches.h</i>:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
int izquierda[] = {4,6,7,5,1,0,2,3};
int derecha[] = {5,4,6,7,0,3,1,2};
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Estos dos arrays los utilizaremos para saber, cada vez que giramos, cuál es el sprite que
                                debemos dibujar en la pantalla. Si los sprites están numerados según la primera figura
                                de este artículo, y ahora mismo se nos muestra en la pantalla el sprite 0, si giramos a
                                la izquierda el que se debería mostrar es el 4. Si volvemos a girar a la izquierda, el
                                que debería dibujarse entonces en la pantalla es el 1, etc. Si por el contrario, estamos
                                mostrando el sprite 0 en la pantalla y giramos a la derecha, se nos debería mostrar el
                                sprite 5. Si volvemos a girar a la derecha, se nos debería mostrar el sprite 3,
                                etc. </p>
                            <p>¿Cómo representamos esto con los arrays indicados anteriormente? Para cada uno de estos
                                dos arrays, la posición <i>i</i> representa, para el <i>sprite i</i>, cual debería ser
                                el sprite que se debería dibujar si giramos hacia la izquierda, en el caso del primer
                                array, o hacia la derecha, en el caso del segundo. Así, por ejemplo, si estamos
                                mostrando el sprite 1 (el coche hacia arriba) y giramos a la izquierda, el valor para la
                                posición 1 (recordemos que en C la primera posición de los arrays es el 0) en el array
                                izquierda es 6, por lo que deberemos mostrar el sprite 6, correspondiente al coche
                                dirigiéndose en diagonal hacia arriba a la izquierda. Sin embargo, si lo que hacemos es
                                girar hacia la derecha, el valor almacenado en la posición 1 del array derecha es el 4,
                                por lo que deberemos mostrar el sprite 4, correspondiente al coche dirigiéndose hacia
                                arriba a la derecha.</p>

                            <p>Habiendo hecho estas dos modificaciones, ya podemos incluir aquí el código de un programa
                                que llamaremos <b>movimiento.c</b>, que nos pondrá a los mandos de un coche que se
                                mostrará en la pantalla, el cual podremos mover hacia donde queramos, sin ninguna
                                restricción. </p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

void main(void)
{
        int x = 100;
        int y = 100;
        int posicion = 0;

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                switch(toupper(getk()))
                {
                       case 'O':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = izquierda[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                        case 'P':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = derecha[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                }
        }
}
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>De momento vamos a comenzar con los giros, y ya surcaremos después la pantalla a toda
                                velocidad. El código anterior nos dibuja el coche en una zona cercana al centro de la
                                pantalla, y nos permite girarlo hacia la izquierda y hacia la derecha empleando las
                                teclas <i>o</i> y <i>p</i> respectivamente. Explicamos el código y más adelante
                                indicamos un problema que se muestra durante la ejecuciñón y cómo solucionarlo.</p>

                            <p>Lo primero que hacemos es incluir algunos archivos de cabecera correspondientes a la
                                librería z88dk para poder hacer uso de algunas funcionalidades de la librería. El
                                segundo de ellos, <i>ctype.h</i> permite utilizar la función <i>toupper</i>, que
                                devuelve la cadena que se le pasa como parámetro pasada a mayúsculas. El tercero que
                                incluimos, <i>games.h</i>, es el que hemos utilizado hasta ahora para poder utilizar <i>putsprite</i>,
                                que ya sabemos de sobra lo que hace. Y finalmente, el primero de ellos, <i>stdio.h</i>,
                                lo incluimos para poder leer de teclado con la función <i>getk</i>. Evidentemente,
                                también debemos incluir <i>coches.h</i>, pues es donde se definen nuestros sprites, el
                                array que los contiene a todos ellos, y los arrays <i>izquierda</i> y <i>derecha</i>
                                cuyo funcionamiento hemos explicado anteriormente.</p>

                            <p>Una vez que comienza el programa principal, empezamos a definir variables. En el caso de
                                <i>x</i> e <i>y</i>, su cometido es tan simple como indicarnos en que posición de la
                                pantalla se va a encontrar el coche. Ahora que vamos a tener el coche fijo girando a lo
                                mejor no parece de utilidad, pero luego, más tarde, cuando lo movamos, sí que va a
                                serasí. La última variable que definimos es <i>posicion</i> encargada de indicarnos que
                                sprite estamos dibujando en pantalla. Si el array <i>sprites</i> contiene todos los
                                sprites definidos, al hacer un <i>putsprite</i> de <i>sprites[posicion]</i>, lo que
                                estaremos haciendo es dibujar por pantalla el sprite almacenado en la posición <i>posicion</i>
                                de dicho array. En nuestro caso, esta variable comienza valiendo 0, por lo que cuando
                                ejecutemos el programa, veremos que el coche, nada más empezar, se encuentra preparado
                                para correr orientado hacia la derecha.</p>

                            <p>Y una vez dibujamos el coche por primera vez, utilizando <i>putsprite</i>, ya estamos
                                preparados para entrar en el bucle principal. Es muy importante fijarse que para el modo
                                de dibujado (primer parámetro de <i>putsprite</i>) estamos utilizando <b>spr_xor</b>,
                                correspondiente a la operación lógica <i>OR EXCLUSIVA</i>. Usamos este modo para poder
                                borrar sprites de una forma muy cómoda. De forma intuitiva, lo único que debemos saber
                                es que si dibujamos un sprite usando or exclusiva en una zona de la pantalla que esté
                                vacía, el sprite se dibujará tal cual en la pantalla. Si dibujamos el sprite usando or
                                exclusiva en una zona de la pantalla donde ese sprite ya estuviera dibujado, se borrará
                                sin modificar el resto de los píxeles de por alrededor, solo se borrarán los píxeles que
                                formen parte del coche.</p>
                            <p>Por lo tanto, para mover, lo que haremos será dibujar el sprite usando or exclusiva en la
                                misma posición en la que se encontrara anteriormente, y después vovler a dibujar usando
                                or exclusiva en su nueva posición. </p>
                            <p>El bucle principal se va a ejecutar de forma indefinida (<i>while (1)</i>). En el mismo,
                                leeremos constantemente lo que el usuario introduzca por el teclado utilizando
                                <i>getk</i>. Hemos de tener en cuenta dos cosas: la función <i>getk</i> es no
                                bloqueante, lo cual quiere decir que si el usuario no pulsa ninguna tecla, el programa
                                no se queda detenido en esa instrucción, y utilizamos <i>getk</i> combinado con <i>toupper</i>,
                                que transforma lo que se le pasa como parámetro a mayúsculas, para que el movimiento
                                funcione igual tanto si el usuario pulsa las teclas con el bloqueo mayúsculas activado o
                                sin el. Por eso, dentro del switch, a la hora de comprobar que tecla se ha pulsado,
                                comparamos la entrada con 'O' y 'P' en lugar de con 'o' y 'p'.</p>

                            <p>Si la tecla que se ha pulsado es la 'o', deseamos girar hacia la izquierda. Dibujamos el
                                coche en la posición actualusando or exclusiva, de tal forma que se borra. Con la línea
                                <i>posicion = izquierda[posicion]</i> lo que hacemos es averiguar que sprite es el que
                                tenemos que dibujar a continuación, según la orientación en la que nos encontremos.
                                Finalmente volvemos a dibujar el coche con las mismas coordenadas (x,y), pero utilizando
                                un sprite distinto, correspondiente a haber girado el coche a la izquierda. En el caso
                                de que se hubiera pulsado la tecla 'p' se realizaría la misma operación, pero utilizando
                                el array <i>derecha</i>.</p>
                            <p>Ahora ya podemos compilar y ejecutar y comprobaremos como podemos girar nuestro coche
                                pulsando las teclas 'o' y 'p'- Sin embargo, veremos que se produce un efecto extraño. Al
                                mantener una tecla pulsada durante un tiempo, es como si estuviéramos escribiendo en
                                BASIC: se gira una vez, y tras un breve tiempo, ya se gira sin interrupción. Más tarde
                                averiguaremos como resolver este pequeño contratiempo. Antes, veamos como podemos hacer
                                que nuestro coche acelere y frene.</p>
                            <p>Queremos que pulsando la tecla 'q' el coche vaya acelerando hasta una velocidad máxima (y
                                por lo tanto, que se vaya moviendo conforme a esa velocidad) y que al pulsar la tecla
                                'a', el coche vaya frenando hasta detenerse. A continuación vemos como lo hemos
                                resuelto, en el siguiente programa, que sustituirá a nuestro anterior
                                <b>movimiento.c</b> (el código en rojo es nuevo):</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

<font color="red">#define CICLOS_BASE 300;</font>

void main(void)
{
        int x = 100;
        int y = 100;
        int posicion = 0;

<font color="red">        int velocidad = 0;
        int ciclos = CICLOS_BASE;</font>

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                switch(toupper(getk()))
                {
<font color="red">                        case 'Q':
                                if (velocidad < 50)
                                {
                                        velocidad = velocidad + 5;
                                }
                                break;
                        case 'A':
                                if (velocidad > 0)
                                {
                                        velocidad = velocidad - 5;
                               }
                                break;</font>
                        case 'O':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = izquierda[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                        case 'P':
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                posicion = derecha[posicion];
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                break;
                }


<font color="red">                if (velocidad > 0)
                {
                        ciclos = ciclos - velocidad;
                        if (ciclos < 0)
                        {
                                ciclos = CICLOS_BASE;
                                putsprite(spr_xor,x,y,sprites[posicion]);
                                switch(posicion)
                                {
                                        case 0:
                                                x = x + 1;
                                                break;
                                        case 1:
                                y = y - 1;
                                                break;
                                        case 2:
                                                x = x - 1;
                                                break;
                                        case 3:
                                                y = y + 1;
                                                break;
                                        case 4:
                                                x = x + 1;
                                                y = y - 1;
                                              break;
                                        case 5:
                                                x = x + 1;
                                                y = y + 1;
                                                break;
                                        case 6:
                                                x = x - 1;
                                                y = y - 1;
                                                break;
                                        case 7:
                                                x = x - 1;
                                                y = y + 1;
                                                break;
                                }
                                putsprite(spr_xor,x,y,sprites[posicion]);
                        }
                }
        }</font>
}
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Lo más evidente es que necesitaremos una variable, en este caso llamada <i>velocidad</i>,
                                que nos permita almacenar la velocidad del coche en un momento dado. Es importante tener
                                en cuenta que en un principio el coche estará parado, por lo que esta velocidad valdrá
                                cero. Hemos añadido también código que hará que nuestra velocidad aumente o disminuya,
                                hasta una velocidad máxima o mínima, al pulsar las teclas 'q' y 'a', respectivamente
                                (este código es el que se ha añadido dentro del switch).</p>
                            <p>Lo que a lo mejor queda un poco más esotérico es ver cómo hacemos que el coche, una vez
                                que adquiere velocidad, pueda moverse. La parte del código encargada de esto es la que
                                se encuentra al final. Este código, como es obvio, solo se ejecutará si el coche tiene
                                velocidad. El coche se moverá cuando una variable, llamada <i>ciclos</i>, y a la que se
                                le va restando el valor de la velocidad en cada iteración del bucle principal, llegue a
                                cero. Evidentemente, cuanta mayor sea la velocidad, más rápido llegará <i>ciclos</i> a 0
                                y cada menos iteraciones del bucle principal se moverá el coche. </p>

                            <p>Si los ciclos llegan a cero, nos disponemos a mover el coche. Lo primero es volver a
                                hacer que ciclos valga su valor inicial, para volver a comenzar el proceso al terminar
                                de mover. Lo siguiente es borrar el coche de su posición anterior, dibujándolo en dicha
                                posición usando el modo or exclusiva. Y después, con un switch, cambiamos el valor de la
                                coordenada <i>x</i> y/o <i>y</i> según la orientación del coche, dada por la variable
                                <i>posicion</i>. Así, por ejemplo, si <i>posicion</i> vale 0, eso quiere decir que el
                                coche está orientado hacia la derecha, por lo que aumentamos el valor de la coordenada
                                x. Si <i>posicion</i> valiera 4, el coche estaría orientado hacia arriba a la derecha,
                                por lo que disminuiríamos el valor de <i>y</i> y aumentaríamos el de <i>x</i>. Y así con
                                el total de las 8 orientaciones. Finalmente, dibujamos el coche en su nueva posición <i>x</i>
                                e <i>y</i>.</p>

                            <p>Aquí encontramos varias ventajas con respecto al BASIC. Primero, que los gráficos
                                definidos por el usuario (en este caso, sprites) no tienen por qué estar limitados a un
                                tamaño de 8 por 8, y segundo, que estos sprites pueden moverse utilizando incrementos
                                que sean cualquier múltiplo de un pixel, mientras que en basic debemos mover los UDGs de
                                8 en 8.</p>
                            <p>Al ejecutar este programa, veremos como podemos acelerar y frenar, y el coche se moverá,
                                sin ninguna restricción. Si el coche sale de la pantalla, observaremos como este entra
                                por el extremo opuesto y el programa seguirá funcionando sin problemas. Sin embargo, se
                                sigue produciendo el mismo efecto que comentábamos antes, el teclado parece comportarse
                                como si estuviéramos en BASIC... vamos a solucionarlo dándole valor a dos variables del
                                sistema, ¡pero que no se asuste nadie!.</p>
                            <p>Las variables del sistema se podrían entender como determinadas direcciones de memoría
                                que modifican el comportamiento del sistema según su valor (más información en la
                                Microhobby especial nº2). En nuestro caso concreto, las variables del sistema que vamos
                                a modificar son REPDEL y REPPER, correspondientes a las direcciones de memoria 23561 y
                                23562. La primera de ellas indica el tiempo en cincuentavos de segundo que se debe tener
                                pulsada una tecla para que esta se comience a repetir, y la segunda indica el tiempo en
                                cincuentavos de segundo que tarda en producirse esta repetición una vez que se comienza.
                                Si le damos un valor de 1 a estas variables, conseguiremos una respuesta dle teclado
                                rápida, y nos desharemos del efecto tan fastidioso que hemos comentado antes.</p>
                            <p>En el siguiente código se muestran, en rojo, los cambios que deberíamos realizar al
                                comienzo del programa <b>movimiento.c</b>:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

#define CICLOS_BASE 300;

void main(void)
{
        int x = 100;
        int y = 100;
        int posicion = 0;

<font color="red">        char *puntero1 = (char *) 23561;
        char *puntero2 = (char *) 23562;</font>


        int velocidad = 0;
        int ciclos = CICLOS_BASE;

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
<font color="red">                *puntero1 = 1;
                *puntero2 = 1;</font>
                switch(toupper(getk()))
                {
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Al mejorar la respuesta del teclado nos ha surgido un nuevo problema... ¡el coche gira
                                demasiado rápido!. </p>
                            <p>Será conveniente añadir un contador para que el coche no gire nada más pulsar la tecla
                                correspondiente; mejor que gire cuando la tecle lleve un rato pulsada. A continuación
                                mostramos, en rojo, el código que deberíamos añadir:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="red">        int girando = 0;
        int contador_izquierda = 0;
        int contador_derecha = 0;</font>
        int velocidad = 0;
        int ciclos = CICLOS_BASE;

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                *puntero1 = 1;
                *puntero2 = 1;

        girando = 0;

                switch(toupper(getk()))
                {
                        case 'Q':
                                if (velocidad < 50)
                                {
                                        velocidad = velocidad + 5;
                                }
                                break;
                        case 'A':
                                if (velocidad > 0)
                                {
                                        velocidad = velocidad - 5;
                                }
                                break;
                        case 'O':
<font color="red">                                contador_derecha = 0;
                                contador_izquierda = contador_izquierda + 1;
                                girando = 1;
                                if (contador_izquierda == 3)
                                {</font>
                                        putsprite(spr_xor,x,y,sprites[posicion]);
                                        posicion = izquierda[posicion];
                                        putsprite(spr_xor,x,y,sprites[posicion]);
<font color="red">                                        contador_izquierda = 0;
                                }</font>

                                break;
                       case 'P':
<font color="red">                                contador_izquierda = 0;
                                contador_derecha = contador_derecha + 1;
                                girando = 1;
                                if (contador_derecha == 3)
                                {</font>
                                        putsprite(spr_xor,x,y,sprites[posicion]);
                                        posicion = derecha[posicion];
                                        putsprite(spr_xor,x,y,sprites[posicion]);
<font color="red">                                        contador_derecha = 0;
                                 }</font>
                                 break;
                }

<font color="red">                if (girando == 0)
                {
                        contador_izquierda = 0;
                        contador_derecha = 0;
                }</font>


                if (velocidad > 0)
                {
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Nos vamos a basar en tres nuevas variables, <i>girando</i>, <i>contador_izquierda</i> y
                                <i>contador_derecha</i>. Las dos últimas son las que nos van a indicar cuándo hacer el
                                giro. Cada vez que le demos a la tecla de giro a la izquierda, aumentará el valor de <i>contador_izquierda</i>,
                                y cada vez que le demos a la tecla de giro a la derecha, aumentará el valor de <i>contador_derecha</i>.
                                Cuando alguna de ellas valga 3, giraremos a la izquierda o a la derecha,
                                respectivamente. </p>

                            <p>Una medida que tomamos es que al girar hacia la izquierda, ponemos a cero la variable <i>contador_derecha</i>,
                                que nos dice cuanto tiempo hemos estado girando a la derecha, y viceversa, cuando
                                giramos a la derecha, ponemos a cero la variable <i>contador_izquierda</i>, que nos dice
                                cuánto hemos girado hasta la izquierda hasta el momento. Así evitamos que, en el caso de
                                haber estado girando hacia la izquierda durante un tiempo, por ejemplo, empecemos a
                                girar a la derecha, y que tan solo haga falta rozar la tecla de giro izquierda para
                                volver a girar a la izquierda, lo cual no es demasiado real. </p>
                            <p>Otra medida que tomamos está relacionada con la variable <i>girando</i>. Si dejamos de
                                pulsar las teclas de giro, no es demasiado real que si volvemos a pulsarlas otra vez
                                pasado un rato y durante muy poco tiempo, giremos. Para solucionar esto, lo que hacemos
                                simplemente es: darle a la variable <i>girando</i> el valor 0 cada vez que entramos en
                                el bucle, darle el valor 1 en el caso de que pulsemos giro izquierda o giro derecha, y
                                por último, poner <i>contador_izquierda</i> y <i>contador_derecha</i> a cero en el caso
                                de que no se haya girado en esa iteración, y por lo tanto, en el caso de que
                                <i>girando</i> valga cero... es bastante sencillo de comprender.</p>

                            <p>¿Y ya está? ¡No! Más problemas se interponen entre nosotros y un sprite en movimiento. Si
                                ejecutamos el código anterior veremos como el coche... ¡no gira! ¿Es que hemos hecho
                                algo mal? No, la algoritmia está bien, pero tenemos un problema de interrupciones. El
                                programa no espera a que pulsemos una tecla, por lo que a lo mejor nosotros estamos
                                pulsando la tecla P todo el rato, pero el programa no llega a leer el teclado a tiempo y
                                <i>girando</i> vuelve a valer 0.</p>
                            <p>Vamos a hacer que el bucle principal solo avance cuando se produzca una interrupción.
                                Dichas interrupciones se producirán en dos casos, cuando pulsemos una tecla (lo cual es
                                lo que queremos) y cuando vaya a comenzar el refresco de la pantalla (cuando el haz de
                                electrones se sitúe de nuevo en el punto 0,0 de la pantalla para empezar a dibujar, de
                                izquierda a derecha y de arriba a abajo). Para ello tendremos que utilizar...
                                ¡ensamblador!. Pero no hay que preocuparse, porque lo solucionaremos todo con una línea
                                de código.</p>
                            <p>La instrucción en ensamblador que detiene la ejecución hasta que se produce una
                                interrupción es <i>HALT</i>. Y en z88dk, ejecutar una instrucción en ensamblador en
                                cualquier momento es tan sencillo como hacer uso de la función <b>asm</b>, que recibe
                                como parámetro una cadena conteniendo la instrucción que deseamos ejecutar. Por lo
                                tanto, resolver de una vez por todas nuestros problemas de movimiento es tan simple como
                                colocar la instrucción <i>asm("HALT")</i> en los lugares adecuados. A continuación se
                                muestra todo el código de <b>movimiento.c</b> tal como quedaría después de los cambios
                                (marcados en rojo).</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

#define CICLOS_BASE <font color="red">20</font>;

void main(void)
{
    int x = 100;
    int y = 100;
    int posicion = 0;

    char *puntero1 = (char *) 23561;
    char *puntero2 = (char *) 23562;


    int girando = 0;
    int contador_izquierda = 0;
    int contador_derecha = 0;
    int velocidad = 0;
    int ciclos = CICLOS_BASE;

    putsprite(spr_xor,x,y,sprites[0]);

    while(1)
    {
        *puntero1 = 1;
        *puntero2 = 1;
        <font color="red">asm("halt");</font>

        girando = 0;

        switch(toupper(getk()))
        {
            case 'Q':
                if (velocidad < <font color="red">30</font>)
                {
                    velocidad = velocidad + <font color="red">1</font>;
                }
                break;
            case 'A':
                if (velocidad > 0)
                {
                    velocidad = velocidad - <font color="red">1</font>;
                }
                break;
            case 'O':
                contador_derecha = 0;
                contador_izquierda = contador_izquierda + 1;
                girando = 1;
                if (contador_izquierda == 3)
                {
                    <font color="red">asm("halt");</font>

                    putsprite(spr_xor,x,y,sprites[posicion]);
                    posicion = izquierda[posicion];
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    contador_izquierda = 0;
                }
                break;
            case 'P':
                contador_izquierda = 0;
                                contador_derecha = contador_derecha + 1;
                                girando = 1;
                                if (contador_derecha == 3)
                                {
                    <font color="red">asm("halt");</font>
                                    putsprite(spr_xor,x,y,sprites[posicion]);
                                    posicion = derecha[posicion];
                                    putsprite(spr_xor,x,y,sprites[posicion]);
                                        contador_derecha = 0;
                                 }
                                 break;
        }

                if (girando == 0)
            {
                contador_izquierda = 0;
                contador_derecha = 0;
        }


        if (velocidad > 0)
        {
            ciclos = ciclos - velocidad;
            if (ciclos < 0)
            {
                ciclos = CICLOS_BASE;
                <font color="red">asm("halt");</font>
                putsprite(spr_xor,x,y,sprites[posicion]);
                switch(posicion)
                {
                    case 0:
                        x = x + 1;
                        break;
                    case 1:
                y = y - 1;
                        break;
                    case 2:
                        x = x - 1;
                        break;
                    case 3:
                        y = y + 1;
                        break;
                    case 4:
                        x = x + 1;
                        y = y - 1;
                        break;
                    case 5:
                        x = x + 1;
                        y = y + 1;
                        break;
                    case 6:
                        x = x - 1;
                        y = y - 1;
                        break;
                    case 7:
                        x = x - 1;
                        y = y + 1;
                        break;
                }
                putsprite(spr_xor,x,y,sprites[posicion]);
            }
        }
    }
}
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Como se puede comprobar, se ha incluido un <i>halt</i> antes de la lectura de teclado,
                                para detener el programa hasta que se pulse una tecla, y después se ha incluido un <i>halt</i>
                                antes de borrar y volver a dibujar el sprite, para esperar el refresco de la pantalla.
                                Como consecuencia, el coche irá más lento, es por ello que también hemos modificado el
                                valor de <i>CICLOS_BASE</i>, la velocidad máxima, y el incremento y decremento de la
                                velocidad. ¿Y os habeis fijado? Gracias a que hemos sincronizado el movimiento del coche
                                con el refresco de la pantalla... ¡este ha dejado de parpadear al moverse!</p>

                            <p>Por último, una cosa curiosa: si mientras movemos el coche pasamos por encima de donde
                                pone <i>Bytes: movimiento</i> (correspondiente a la carga desde cinta) veremos como el
                                borrado y la escritura del sprite del coche no afecta en lo mas mínimo a los píxeles que
                                forman parte de ese texto; esto es sin duda otra de las grandes ventajas de usar el modo
                                de dibujado de sprites or exclusiva.</p>
                            <p><b>Y ahora, pongamos el coche en una pista</b></p>
                            <p>Por último vamos a dibujar una pista de neumáticos para limitar un poco el movimiento de
                                nuestro bólido. Vamos además a hacerlo de tal forma que sea muy fácil modificar el
                                trazado, y así la diversión se multiplique durante meses. Si recordamos, el último de
                                los sprites que habíamos definido era el correspondiente a un neumático. Este sprite,
                                com todos los anteriores, tiene un tamaño de 10x10 (quizá un poco grande, para hacer
                                circuitos más complicados quizas no hubiera estado mal utilizar sprites de neumáticos
                                más pequeños). </p>
                            <p>Dentro de <b>coches.h</b> es donde definiremos el trazado de la pista. Si consideramos la
                                pantalla como un array de 18x24 casillas de tamaño 10x10 (el mismo que los neumáticos),
                                podemos indicar el recorrido de la pista creando un array, donde colocaremos ceros en
                                aquellas casillas donde no vaya a haber neumático, y unos en las casillas en las que sí.
                                Al principio de <b>coches.h</b> definimos unas constantes para el tamaño del circuito:
                            </p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
#define ALTURA_CIRCUITO 18
#define ANCHURA_CIRCUITO 24
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>y al final del mismo archivo incluimos el siguiente array:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
short circuito1[] =  { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0 };
short circuito2[] =  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 0, 0, 0, 0 };
short circuito3[] =  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 0, 0 };
short circuito4[] =  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0 };
short circuito5[] =  { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito6[] =  { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito7[] =  { 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito8[] =  { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito9[] =  { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 1 };
short circuito10[] = { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 1, 0 };
short circuito11[] = { 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 1, 0, 0 };
short circuito12[] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0 };
short circuito13[] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0 };
short circuito14[] = { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0 };
short circuito15[] = { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 0 };
short circuito16[] = { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 0, 0, 0, 0, 0 };
short circuito17[] = { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0 };
short circuito18[] = { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0 };

short int *circuito[ALTURA_CIRCUITO] = {circuito1, circuito2, circuito3, circuito4,
    circuito5, circuito6, circuito7, circuito8, circuito9, circuito10, circuito11,
    circuito12, circuito13, circuito14, circuito15, circuito16, circuito17,
    circuito18};
</pre>

                                        </p></td>
                                </tr>
                            </table>
                            <p>Con un poco de imaginación podemos vislumbrar en ese array un circuito cerrado en forma
                                de O. Si ahora creamos un fichero llamado <b>juego.c</b>, que contenga el mismo código
                                que <i>movimiento.c</i>, pero añadiéndole el que aperece en color rojo a continuación,
                                podremos por fin ver nuestor circuito en la pantalla, tal como se ve en la siguiente
                                imagen:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
void main(void)
{
        int x = 100;
        int y = <font color="red">140</font>;
        int posicion = 0;
<font color="red">        short int i;
        short int j;</font>

        char *puntero1 = (char *) 23561;
        char *puntero2 = (char *) 23562;

        int girando = 0;
        int contador_izquierda = 0;
        int contador_derecha = 0;
        int velocidad = 0;
        int ciclos = CICLOS_BASE;

<font color="red">        for (i=0;i<30;i++)
                printf("\n");

        for (i=0;i<ALTURA_CIRCUITO;i++)
                for (j=0;j<ANCHURA_CIRCUITO;j++)
                        if (circuito[i][j] == 1)
                                putsprite(spr_xor,j*10+1,i*10+1,sprites[8]);
</font>

        putsprite(spr_xor,x,y,sprites[0]);

        while(1)
        {
                *puntero1 = 1;
                *puntero2 = 1;
                asm("halt");
</pre>
                                        </p></td>
                                </tr>
                            </table>


                            <table border="0" cellspacing="0" cellpadding="2" width="320">
                                <tr align="right">
                                    <td><img src="img/z88dk7_4.png" width="320" height="240"
                                             alt="Figura 4. Nuestro coche dispuesto a ser el rey de la pista"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Figura 4. Nuestro coche dispuesto a ser el rey de
                                        la pista
                                    </td>
                                </tr>
                            </table>


                            <p>Hay que tener en cuenta que hemos cambiado el valor inicial de la coordenada y del coche
                                para que éste quede dentro de la pista. También hemos creado dos variables, <i>i</i> y
                                <i>j</i> que nos van a servir de contadores en un par de bucles.</p>
                            <p>Este par de bucles son los dos que se muestran en rojo. En el primero lo único que
                                hacemos es escribir en la pantalla 30 líneas en blanco para borrarla (es por eso que en
                                la captura anterior ya no se ve lo de <i>Bytes: juego.tap</i> que molestaba tanto). Es
                                en el segundo en el que dibujamos el circuito.</p>
                            <p>Si hemos decidido anteriormente que el array <i>circuito</i> nos iba a indicar si en cada
                                celda de 10x10 píxeles en las que dividíamos la pantalla había o no un neumático, lo que
                                haremos para dibujar la pista no es más que recorrer todas las posiciones del array y
                                dibujar en la pantalla un neumático en la posición <i>i*10+1</i>, <i>j*10+1</i>, siendo
                                <i>i</i> y <i>j</i> las coordenadas dentro del array donde hemos leído un 1.</p>

                            <p>De acuerdo, ya tenemos un coche moviéndose y un circuito... pero cuando el coche llega
                                hasta alguno de los neumáticos, en lugar de producirse una espectacular explosión, lo
                                atraviesa como si nada y sigue su camino. Tenemos, sin duda, que añadir colisiones.</p>
                            <p>Para detectar cuando nuestro coche colisiona con uno de los neumáticos que forman parte
                                de los límites de la pista, deberemos añadir una condición <i>if</i> antes de cada
                                desplazamiento del mismo, de tal forma que si ese desplazamiento va a provocar que coche
                                y neumático entren en contacto, el coche se pare totalmente (dada la poca velocidad a la
                                que se ha programado el coche en nuestro programa, y a nuestra incapacidad de momento
                                para crear grandes explosiones usando z88dk en el Spectrum, vamos a suponer que al
                                contactar con un neumático el coche solamente queda parado).</p>
                            <p>A continuación mostrmos lo que sería el código <i>completo</i> de <b>juego.c</b>, con las
                                partes nuevas en color rojo, como siempre:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
#include "stdio.h"
#include "ctype.h"
#include "games.h"
#include "coches.h"

#define CICLOS_BASE 20;

void main(void)
{
    int x = 100;
    int y = 140;
    int posicion = 0;
    short int i;
    short int j;

    char *puntero1 = (char *) 23561;
    char *puntero2 = (char *) 23562;

    int girando = 0;
    int contador_izquierda = 0;
    int contador_derecha = 0;
    int velocidad = 0;
    int ciclos = CICLOS_BASE;

    for (i=0;i<30;i++)
        printf("\n");

    for (i=0;i<ALTURA_CIRCUITO;i++)
        for (j=0;j<ANCHURA_CIRCUITO;j++)
            if (circuito[i][j] == 1)
                putsprite(spr_xor,j*10+1,i*10+1,sprites[8]);


    putsprite(spr_xor,x,y,sprites[0]);

    while(1)
    {
        *puntero1 = 1;
        *puntero2 = 1;
        asm("halt");

        girando = 0;

        switch(toupper(getk()))
        {
            case 'Q':
                if (velocidad < 30)
                {
                    velocidad = velocidad + 1;
                }
                break;
            case 'A':
                if (velocidad > 0)
                {
                    velocidad = velocidad - 1;
                }
                break;
            case 'O':
                contador_derecha = 0;
                contador_izquierda = contador_izquierda + 1;
                girando = 1;
                if (contador_izquierda == 3)
                {
                    asm("halt");
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    posicion = izquierda[posicion];
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    contador_izquierda = 0;
                }
                break;
            case 'P':
                contador_izquierda = 0;
                contador_derecha = contador_derecha + 1;
                girando = 1;
                if (contador_derecha == 3)
                {
                    asm("halt");
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    posicion = derecha[posicion];
                    putsprite(spr_xor,x,y,sprites[posicion]);
                    contador_derecha = 0;
                }
                break;
        }

        if (girando == 0)
        {
            contador_izquierda = 0;
            contador_derecha = 0;
        }

        if (velocidad > 0)
        {
            ciclos = ciclos - velocidad;
            if (ciclos < 0)
            {
                ciclos = CICLOS_BASE;
                asm("halt");
                putsprite(spr_xor,x,y,sprites[posicion]);
                switch(posicion)
                {
                    case 0:
<font color="red">
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1))

                            velocidad = 0;
                        else</font>
                            x = x + 1;
                        break;
                    case 1:
<font color="red">
                        if (circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else</font>

                            y = y - 1;
                        break;
                    case 2:
<font color="red">
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1))

                            velocidad = 0;
                        else</font>
                            x = x - 1;
                        break;
                    case 3:
<font color="red">
                        if (circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else</font>
                            y = y + 1;
                        break;
                    case 4:

<font color="red">
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {</font>
                            x = x + 1;
                            y = y - 1;
<font color="red">                        }</font>
                        break;
                    case 5:
<font color="red">
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {</font>

                            x = x + 1;
                            y = y + 1;
<font color="red">                        }</font>
                        break;
                    case 6:
<font color="red">
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                            circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {</font>
                            x = x - 1;
                            y = y - 1;

<font color="red">                        }</font>
                        break;
                    case 7:
<font color="red">
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                            circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {            </font>
                            x = x - 1;
                            y = y + 1;
<font color="red">                        }</font>

                        break;
                }
                putsprite(spr_xor,x,y,sprites[posicion]);
            }
        }
    }
}
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Simplemente, antes de mover el coche, en la última parte del bucle principal, comprobamos
                                si va a haber una colisión con alguno de los neumáticos. En el caso de que sea así
                                ponemos la velocidad a cero, y en caso contrario realizamos el movimiento de forma
                                normal. En todas las comprobaciones miramos a ver si en la posición del array circuito
                                correspondiente a donde estaría mas o menos situado el coche (recordemos que en <i>circuito</i>
                                cada posición se corresponde con 10x10 píxeles de la pantalla) hay un 1. </p>
                            <p>Analicemos, por ejemplo, para el <i>case 0</i>, que se corresponde con el coche
                                moviéndose hacia la derecha, y el resto de condiciones se podrá sacar de la misma forma
                                (hemos de aclarar que en los cuatro últimos <i>case</i>, al tratarse de movimientos
                                diagonales, la comprobación debe ser en los dos sentidos, eje <i>x</i> y eje <i>y</i>):
                            </p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
if (circuito[y/10][(x + 9)/10] == 1 ||
    (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1))
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Básicamente la comprobación se compone de dos partes, la que está a la izquierda del OR
                                (que en C, recordemos, se codifica con ||) y la que está a la derecha. Si en el array
                                <i>circuito</i> decíamos que cada posición se correspondía con una región de 10x10
                                píxeles de la pantalla, cuando el coche está en las coordenadas <i>(y,x)</i>, tendríamos
                                que comprobar en la posición <i>(y/10,x/10)</i> del array <i>circuito</i> (en C, las
                                divisiones enteras se redondean hacia abajo). </p>

                            <p>La anchura y la altura del coche es 10, por lo tanto, si queremos movernos hacia la
                                derecha, aumentando el valor de <i>x</i> en 1, debemos comprobar si el pixel situado en
                                el extremo derecho, es decir, el pixel situado en <i>x+11</i> , estará en contacto con
                                algún pixel de algún neumático. Esto es equivalente a comprobar si en la posición <i>[y/10][(x+11)/10]</i>
                                de <i>circuito</i> hay almacenado un 1. Si es así habrá colisión, por lo que no nos
                                interesará avanzar, se cumplirá la condición, y <i>velocidad</i> pasará a valer 0. Lo
                                que ocurre es que en nuestro caso, en lugar de <i>x+11</i> hemos usado <i>x+9</i> ya
                                que, por ensayo y error hemos comprobado que con este valor el coche solo colisionara
                                cuando este totalmente pegado al neumático (nuestros sprites son de 10x10, pero algunos
                                de ellos no ocupan toda la anchura o toda la altura).</p>

                            <p>Esto estaría bien si el coche solo pudiera moverse en el eje <i>y</i> en múltiplos de 10,
                                pero esto no siempre es así. Si el coche estuviera en <i>(12,12)</i> (valiendo 12 la
                                coordenada <i>y</i>, por lo tanto), al movernos a la derecha, podríamos colisionar con
                                un neumático almacenado en el array <i>circuito</i> en <i>(1,2)</i>, pero también con el
                                que estuviera en <i>(2,2)</i> (el de abajo). Por lo tanto, la segunda condición
                                comprueba si, en el caso de que la coordenada <i>y</i> no tenga un valor múltiplo de 10
                                (es decir, cuando el resultado de la operación resto, especifacada en C con % y que
                                calcula el resto de la división entera, devuelva un valor distinto de cero), habría
                                colisión con un neumático situado abajo a la derecha. Como en el caso de la <i>x</i>, en
                                lugar de sumar 11 a <i>y</i>, añadimos un valor calculado a ojo que nos asegura que el
                                coche quedaría pegadito en el caso de una colisión vertical.</p>

                            <p>Se podrían cumplir las dos condiciones a la vez, pero nos es indiferente, con que se
                                cumpla una de las dos ya hay colisión.</p>
                            <p>En el caso de movernos hacia la izquierda, en lugar de sumar a <i>x</i> restamos, y en el
                                caso de movernos hacia arriba o hacia abajo, hacemos lo mismo pero cambiando lo que
                                sumamos o restamos a <i>x</i> por lo que sumamos o restamos a <i>y</i> y viceversa. </p>
                            <p>¿Y eso es todo? Bueno... hemos de ser sinceros y admitir que debido a la inclusión del
                                código que detecta las colisiones, ha vuelto el parpadeo del coche al moverse, sobre
                                todo por la parte superior de la pantalla. No le da tiempo al programa a sincronizar el
                                movimiento con el refresco de la pantalla, debido a lo complejo de los cálculos. Esto, a
                                grandes rasgos, se puede mejorar, aunque solo sea un poco, creando dos nuevas variables,
                                <i>x_anterior</i> e <i>y_anterior</i>, y dejando el código de detección de colisiones de
                                la siguiente manera (calculando las colisiones antes de esperar el refresco de la
                                pantalla y borrar y dibujar el sprite):</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
        if (velocidad > 0)
        {
            ciclos = ciclos - velocidad;
            if (ciclos < 0)
            {
                ciclos = CICLOS_BASE;
<font color="red">                y_anterior = y;
                x_anterior = x;</font>
                switch(posicion)
                {
                    case 0:
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1))

                            velocidad = 0;
                        else
                            x = x + 1;
                        break;
                    case 1:
                        if (circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                            y = y - 1;
                        break;
                    case 2:
                        if (circuito[y/10][(x-2)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1))

                            velocidad = 0;
                        else
                            x = x - 1;
                        break;
                    case 3:
                        if (circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                            y = y + 1;
                        break;
                    case 4:
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y-2)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x + 1;
                            y = y - 1;
                        }
                        break;
                    case 5:
                        if (circuito[y/10][(x + 9)/10] == 1 ||
                            (y%10 != 0 && circuito[(y+7)/10][(x+9)/10] == 1) ||
                            circuito[(y+9)/10][x/10] == 1 ||
                            (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x + 1;
                            y = y + 1;
                        }
                        break;
                    case 6:
                        if (circuito[y/10][(x-2)/10] == 1 ||
                        (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                        circuito[(y-2)/10][x/10] == 1 ||
                        (x%10 != 0 && circuito[(y-2)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x - 1;
                            y = y - 1;
                        }
                        break;
                    case 7:
                        if (circuito[y/10][(x-2)/10] == 1 ||
                        (y%10 != 0 && circuito[(y+7)/10][(x-2)/10] == 1) ||
                        circuito[(y+9)/10][x/10] == 1 ||
                        (x%10 != 0 && circuito[(y+9)/10][(x+7)/10] == 1))

                            velocidad = 0;
                        else
                        {
                            x = x - 1;
                            y = y + 1;
                        }
                        break;
                }

<font color="red">                asm("halt");
                putsprite(spr_xor,x_anterior,y_anterior,sprites[posicion]);</font>
                putsprite(spr_xor,x,y,sprites[posicion]);
            }
        }
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p><b>¿Y ahora qué?</b></p>
                            <p>Bueno, parece que al final lo hemos conseguido: tenemos un coche moviéndose por la pista,
                                que se choca con los bordes del circuito y puede acelerar y frenar... tomando este
                                código como base, podríamos crear nuestro fantástico juego de coches, añadir nuevas
                                pistas, contrincantes, etc. Sin embargo, hemos comprobado ciertas limitaciones en el
                                código de dibujado de sprites que se suministra con z88dk, sobre todo en <i>juego.c</i>,
                                donde se produce un ligero parpadeo del coche cuando este se mueve por la parte
                                superior. En próximos artículos estudiaremos alguna librería que nos puede ayudar a
                                superar el trance... pero mientras, ¡a conducir!.</p>
                            <p>Me gustaría agradecer tanto a Horace como a NoP por los comentarios realizados y la ayuda
                                que me han prestado durante la realización de este artículo.</p>

                            <b>LINKS</b>
                            </p>
                            <ul>
                                <li><a href="src/z88dk_coches.zip" onClick="window.open(this.href); return false;">Código
                                    fuente de los ejemplos</a></li>
                            </ul>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td align="right"><br><br>SIEW</td>

                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td> </td>
    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarPie(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">

                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('el-aventurero.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>

                                <option value="al-descubierto.html">Al Descubierto</option>
                                <option value="hardware.html">Hardware</option>
                                <option value="basic.html">Programación BASIC</option>
                                <option value="el-aventurero.html">El Aventurero</option>
                                <option value="z88dk.html" selected>Programación Z88DK</option>
                                <option value="input.html">INPUT</option>

                                <option value="ensamblador.html">Programación Ensamblador</option>
                                <option value="opinion.html">Opinión</option>
                            </select>
                            <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                        </td>
                        <td align="right" class="texto">
                            <a href="#arriba">Volver arriba</a>
                        </td>

                    </tr>
                    <tr>
                        <td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>
                </form>
            </table>
        </td>
    </tr>
    <tr>

        <td>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
                <tr align="center" valign="center">
                    <td>2003-2009 Magazine ZX</td>
                </tr>
            </table>
        </td>

    </tr>
</table>
</body>
</html>
