<!doctype html>
<html lang="es">
    <head>
        <title>Magazine ZX</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

        <link rel="stylesheet" href="../css/magazine.css" type="text/css">
    </head>
    <body><!-- Google Tag Manager --> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-W5DD5R" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-W5DD5R');</script> <!-- End Google Tag Manager -->


            <table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
                <tr>
                    <td>
<a name="arriba"></a>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
	<tr align="center" valign="center">
		<td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0" /></a></td>
	</tr>
</table>
                    </td>

                </tr>
                <tr>
                    <td>
<script language="JavaScript">
function RecargarCabecera(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">
        <tr><td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>

        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('al-descubierto.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
        <option value="index.html">Portada</option>
        <option value="editorial.html">Índice - Editorial</option>
        <option value="panorama.html">Panorama</option>
        <option value="la-historia-del-spectrum.html">La historia del Spectrum</option>

        <option value="el-aventurero.html">El Aventurero</option>
        <option value="analisis.html">Análisis</option>
        <option value="computone.html">Computone</option>
        <option value="al-descubierto.html">Al Descubierto</option>
        <option value="basic.html" selected>Programación BASIC</option>
        <option value="z88dk.html">Programación Z88DK</option>

        <option value="ensamblador.html">Programación Ensamblador</option>
        <option value="128k-mode.html">128K MODE</option>
        <option value="input.html">INPUT</option>
        <option value="tira-comica.html">Tira cómica</option>
        <option value="opinion.html">Opinión</option>
    </select>

    <input type="button" onclick="RecargarCabecera('z88dk.html');" name="siguiente" value=">" />
</td>
            <td align="center" class="texto">Número 17 - Marzo 2009</td>
            <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX" onClick="window.open(this.href); return false;"><img src="http://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0" alt="ZX Certified webmaster"></a>&nbsp;<a href="http://www.speccy.org/" onClick="window.open(this.href); return false;"><img src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a></td>
        </tr>
    </form>
</table>
</a>
                    </td>
                </tr>

                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td>
<table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
    <tr>
        <td>
<div align="justify">
<p align="center"><font size="5">ZX BASIC. Un sueño hecho real...</font></p>
<p><em>Este artículo trata sobre ZX BASIC, un compilador cruzado que permite crear en tu PC programas para tu ZX Spectrum. Lo que hace es traducir las instrucciones de un programa en BASIC a código máquina del Z80 que luego puedes ejecutar en un emulador o en un Spectrum real.</em></p>
<p><strong>Hace mucho tiempo...</strong></p>

<p>Ejem... ¿En una galaxia muy muy lejana? Bueno, no. No tanto.</p>
<p>Al igual que muchos de vosotros, de niño quería hacer otras cosas con mi ZX Spectrum aparte de jugar: quería experimentar. Programar era una forma de hacerlo, sin duda. La electrónica no era mi fuerte y siendo un crío como era y con tan poca experiencia (había tenido algún que otro susto con la electricidad anteriormente) la programación era la mejor forma de experimentar. Era como ser un dios en miniatura dentro del universo de posibilidades que el ZX Spectrum ofrecía por aquel entonces. Compraba MicroHobby (y las primeras Micromanía); me dedicaba -como creo que todos hicimos- horas y horas a teclear los listados publicados; a hacer mis propios códigos en BASIC; a cargar algunos de los programas y modificarlos (hoy diríamos hackearlos) y en definitiva a probar muchas otras cosas de esta pequeña pero maravillosa máquina.</p>
<p>Pronto una limitación se hizo evidente: el BASIC del ZX Spectrum era ciertamente lento. Cuando nos picábamos mis amigos y yo con nuestros respectivmos micros, el ZX Spectrum siempre llevaba las de perder. Un simple bucle FOR n = 1 TO 1000: NEXT n tardaba algo más de 4 segundos en ejecutarse aunque no hiciera nada. En otros microordenadores esto no era así (en el Dragon 64 tardaba menos de un segundo, creo recordar).</p>
<p>Pese a todo, el BASIC de Sinclair era extremadamente rico en general. Aprendí programación con él y muchas de esas cosas me ayudaron en la carrera de informática. Esa riqueza del lenguaje no parecían tenerla los otras implementaciones BASIC de los años 80 (o esa fue mi impresión). Un ejemplo típico es el COMMODORE, cuyo BASIC emplea muchos POKES para realizar determinadas tareas. Es por esto que creo que es uno de los micros con mayor cantidad de programas BASIC creados (todavía a día de hoy).</p>
<p>Para vencer la limitación de la velocidad, muchos intentamos programar en ensamblador. Mis escasos conocimientos en general y particularmente sobre todo de aritmética binaria y hexadecimal, la escasa bibliografía -gracias de nuevo a MicroHobby y a sus fichas- y, sobre todo, de un ensamblador decente (nunca tuve GENS ni MONS) hicieron que el sueño de crear un juego y otras muchas cosas nunca se cumplieran.</p>
<p>Llegué a hacer en BASIC un intérprete de lenguaje Prolog muy simple. Otro de LOGO y otro de un lenguaje que me inventé. Desde luego, no tenía el conocimiento sobre la programación de lenguajes de ordenador que tengo hoy día, pero como ya os imagináis, si el BASIC de ZX era lento, un intérprete de un lenguaje realizado en BASIC era aún más lento. Exasperante. A pesar de todo, esa pequeña frustración fue la semilla que fijó claramente mi vocación (como supongo que muchos de vosotros).</p>
<p>Si estás leyendo esto es porque muy probablemente también tuviste estas inquietudes. Ahora volvamos al presente...</p>
<p><strong>Un poco de teoría</strong></p>
<p>Antes de comenzar a explicar el uso del compilador, está bien echar un vistazo por encima a qué es un compilador y su diseño interno por dos motivos:</p>

<ul>
  <li>Hay personas que saben programar pero no comprenden que hay cosas que un compilador no podrá hacer jamás.</li>
  <li>También puede que te interese expandir el compilador de alguna manera, o contribuir al desarrollo del lenguaje o a muchas otras cosas.</li>
</ul>
<p>Para empezar, un traductor no es más que un programa capaz de convertir de alguna manera un código escrito en un lenguaje de programación a otro. Por ejemplo puedes tener un programa en BASIC y traducirlo a LOGO (suponiendo que sea factible) o a C. Un compilador va un paso más allá. Es un traductor que traduce un lenguaje fuente a código objeto (binario) que es directamente ejecutable por la máquina.</p>
<p>Un intérprete, por contra, lo que hace es ir leyendo un programa fuente instrucción por instrucción y representarlas ejecutando una serie de acciones equivalentes a cada una de ellas. Si usaste un ZX Spectrum ya conoces un intérprete: la ROM del ZX Spectrum. La ROM es en su mayor parte un intérprete de Sinclair BASIC. Los programas interpretados, por lo general, son más lentos que los compilados (en algunos pocos casos se puede conseguir una velocidad casi similar).</p>
<p>ZX BASIC es un compilador cruzado. Los compiladores cruzados son aquellos que se ejecutan en una máquina pero producen código objeto para otra. En este caso, vamos a usar ZX BASIC en nuestro PC (ya sea sobre Windows o Linux) para producir un programa compilado para ZX Spectrum (en realidad para Z80). De esa manera ahorraremos memoria -que en el Spectrum es muy escasa- al no tener que alojar el compilador junto con el programa compilado. Además, la velocidad de compilación será mayor (generalmente unos segundos).</p>
<p>La velocidad de un programa compilado estriba en que se calcula de antemano toda la información posible sobre el código fuente que se va a ejecutar. Por eso un compilador necesita obtener determinada información sobre el programa durante la fase de compilación (por ejemplo, el tipo de dato que almacena una variable, si es numérica o de cadena, dónde se va a guardar en memoria, etc). Un intérprete no necesita esto ya que lo hace durante la ejecución. Por eso hay cosas que un compilador no puede hacer y un intérprete sí. El ejemplo más claro es el de la función VAL del Sinclair BASIC. Es una instrucción muy potente. LET a$ = "x+x": LET b = VAL a$ almacena en la variable b el resultado de la expresión "x+x". Dado que la variable a$ puede cambiar su valor durante la ejecución del programa, es imposible saber en tiempo de compilación que tipo de dato se va a guardar en b (un valor de punto flotante, un número entero, etc) ni cómo calcularlo. De hecho, muy pocas implementaciones de BASIC tienen esta potencia, ni siquiera en la actualidad. En las competiciones de BASIC entre distintas marcas de micros antes mencionadas, el ZX perdía en velocidad pero por contra la capacidad de VAL resultaba devastadora.</p>
<p>En definitiva, esto era posible porque el BASIC de la ROM cada vez que evalúa una expresión le hace un análisis (con la consiguiente lentitud): se gana versatilidad, pero se pierde velocidad.</p>

<p>Los compiladores modernos (y ZX BASIC lo es) se basan en capas:</p>
<ul>
  <li>La primera capa es la de análisis de código (que a su vez se suele descomponer en dos: una capa de análisis léxico y otra de análisis sintáctico). Esta capa intenta comprender el programa y verificar que la sintaxis es correcta construyendo una representación en memoria del programa llamada Árbol Sintáctico Abstracto (AST en inglés).</li>
  <li>La segunda capa es la de análisis semántico, que realiza una primera traducción y además algunas comprobaciones extra que la capa anterior no puede realizar. También se realizan las primeras optimaciones de código. En general, lo que hace es traducir el programa a un ensamblador ficticio llamado código intermedio. Esta capa y la anterior suelen ir juntas en el código (muchas veces son la misma capa en realidad) y se les llama frontend.</li>
  <li>Este código intermedio será nuevamente traducido a ensamblador de la arquitectura de destino (en nuestro caso Z80). Al contrario que el lenguaje BASIC, el código intermedio es muy rígido y muy fácil de analizar. No es necesario crear otro traductor para esta fase. A esta capa y a las que siguen se las suele llamar backend.</li>
  <li>Finalmente, un ensamblador (el ZX BASIC contiene uno propio) y un enlazador de código objeto (el ZX BASIC no usa ninguno: por ahora todo se trabaja en ensamblador y se compila a binario directamente) realizan el resto del trabajo produciendo el binario final.</li>
</ul>

<table border="1">
  <tr>
    <td rowspan="5">Frontend</td>
    <td>Análisis Léxico</td>
    <td>Convertir letras a palabras y símbolos</td>
  </tr>
  <tr>
    <td>Análisis Sintáctico</td>

    <td>	Comprobar la sintaxis y las frases</td>
  </tr>
  <tr>
    <td>Análisis Semántico</td>
    <td>	Comprobar los tipos de variable, declaraciones duplicadas o fuera de contexto. Construcción del Árbol Sintáctico.</td>
  </tr>

  <tr>
    <td colspan="2">Optimización del Árbol</td>
  </tr>
  <tr>
    <td colspan="2">Generación de Código Intermedio</td>
  </tr>
  <tr>
    <td rowspan="3">Backend para ZX Spectrum</td>

    <td colspan="2">Traducción a Ensamblador (Z80)</td>
  </tr>
  <tr>
    <td colspan="2">Optimización de Código Ensamblador (reordenación de registros, etc)</td>
  </tr>
  <tr>
    <td colspan="2">Ensamblado: Traducción a Código Máquina (o Código Objeto)</td>

  </tr>
</table>

<p>Prácticamente todos los compiladores actuales trabajan de forma similar. La ventaja de esto es que se pueden cambiar las capas de backend de manera que es posible compilar el mismo programa para distintas arquitecturas: se podría hacer que un programa en ZX BASIC compilara para Windows, Linux, Nintendo DS, teléfono móvil, PlayStation o cualquier otra plataforma. Evidentemente cada plataforma tiene su limitación, pero dado que el ZX es la más limitada de todas sin duda, esto no debería suponer problema alguno. Los compiladores de este tipo se llaman retargeable compilers (compiladores reorientables).</p>
<p>También se podría cambiar el frontend. Podrías crear un traductor para otro lenguaje (C, PASCAL, LOGO...) que pasara a código intermedio, y usar el mismo backend. Esta filosofía es la que usa .NET, por ejemplo, donde distintos lenguajes fuentes compilan a CIL (Common Intermediate Language) que es luego interpretado por el .NET Framework que tengas instalado en Windows (si es que usas ese sistema operativo).</p>
<p>Resumiendo: ZX BASIC es un compilador cruzado reorientable de 3 capas.</p>

<p><strong>Instalación</strong></p>
<p>El compilador ZX BASIC está hecho en Python (un lenguaje interpretado de scripting). Esto lo hace portable a todas aquellas plataformas donde esté python (actualmente incluso para telefonos Nokia con Symbian, y para Windows Mobile). Es posible en teoría compilar programas en ZX BASIC para nuestro Spectrum en cualquier sitio donde esté python. Lo único que se requiere es que la versión de Python instalada sea igual o superior a la 2.5. En el caso de Windows, además, hay una versión instalable (.MSI) que ni siquiera requiere python. Si usas Windows y tienes dudas, te recomiendo que uses esta versión.</p>
<p>Puedes descargarte la última versión del compilador desde http://www.boriel.com/files/zxb/ . Verás que hay varias versiones. Descárgate siempre la más reciente. Hay un alias llamado latest version que siempre apunta a la última versión (en el momento de escribir esto, la 1.0.3). El archivo con extensión .MSI es el archivo de instalación de Windows antes mencionado. Si no estás familiarizado con todo lo que has leído hasta ahora, usa esta versión.</p>

<p>Para Linux y otras plataformas, descomprime la versión .zip (o .tar.gz, la que te sea más cómoda) en algún sitio de tu PATH. Para desinstalar el compilador, sólo tienes que borrar la carpeta donde lo has descomprimido. Si usaste la versión .MSI de windows, desinstálalo desde el Panel de Control (Agregar o Quitar Programas).</p>
<p>Para comprobar que se ha instalado correctamente, abre una consola y teclea zxb.py --version. Si usaste la versión autoinstalable de Windows, abre una ventana nueva de consola de comandos MS-DOS porque las variables de entorno han cambiado, y teclea: zxb --version (fíjate que no tiene la extensión .py). En ambos casos, se debería imprimir la versión del compilador (1.0.5).</p>
<p>A partir de ahora todos los ejemplos usarán la orden zxb (usa zxb.py si instalaste el compilador descomprimiéndolo en una carpeta).</p>

<p><strong>Nuestro primer programa</strong></p>
<p>El ritual a la hora de probar un nuevo lenguaje es el programa Hola Mundo, que básicamente imprime ese mensaje por pantalla. Vamos a hacer lo mismo, para familiarizarnos con todo el proceso de creación y compilación de un programa.</p>
<p>El código fuente de ZX BASIC tiene que estar en un archivo de texto ASCII. Usa tu editor de texto favorito, y escribe el siguiente programa:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>

  10 PRINT "Hola Mundo!"
</pre>
    </p></td></tr>
</table>
<p>Como puedes ver, es una sentencia BASIC de toda la vida. Ahora graba el programa como hola.bas. Nunca grabes tus programas en el directorio de instalación del compilador. Hazlo en un directorio propio y evita que tu código se mezcle con el del compilador. De esa forma, cuando salgan nuevas versiones no tendrás problemas borrando el directorio del compilador para instalar la nueva versión.</p>
<p>Ahora abre una consola de comandos y posiciónate en el directorio donde has grabado el programa hola.bas. Vamos a realizar la compilación:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
zxb -T -B -a hola.bas
</pre>
    </p></td></tr>

</table>
<p>Te recomiendo que dejes de leer aquí y hagas todo esto en el computador antes de seguir. Si todo ha ido bien no aparecerá nada por pantalla. Se tiene que haber creado el programa hola.tzx (que es tu programa compilado en formato .tzx) en el mismo directorio donde tienes el código fuente hola.bas. Este programa se puede ejecutar directamente en cualquier emulador (yo utilizo EMUZWIN) que admite el formato .TZX. También hay programas que convierten los archivos .TZX a archivos de sonido .MP3 que son los que se usarían para cargar en un ZX Spectrum real. De todas formas se pueden generar otros formatos.</p>
<p>Recuerda que tu programa es compilado en código máquina. Normalmente el ZX Spectrum necesita un cargador en BASIC que cargue el código máquina y lo ejecute. Si cargas el programa a velocidad normal verás que primero aparecerá en pantalla Program: "hola.bas". Es el cargador en BASIC. Este cargador a continuación cargará el código máquina y lo ejecutará con un RANDOMIZE USR. Si interrumpes la carga verás que es un cargador muy simple y sin ninguna protección y que el código máquina de tu programa se carga y ejecuta a partir de la dirección de memoria 32768 (8000h en hexadecimal).</p>
<p>Si todo esto te ha funcionado, enhorabuena: ya estás listo para empezar a programar. ZX BASIC intenta ser lo más parecido al Sinclair BASIC, de manera que te sea cómodo empezar a programar si ya conoces éste último. Sin embargo, existen algunas limitaciones por ser un programa compilado (como ya se comentó antes). Algunas instrucciones como VAL no se comportan igual. Otras no existen porque no tienen sentido (LIST, LLIST). Y algunas otras están expandidas o admiten parámetros extra para aprovechar la potencia que ahora tenemos. Además, hay instrucciones nuevas que te ahorrarán trabajo: sentencias de bucles más potentes y subrutinas con variables privadas son sólo un ejemplo de ello.</p>

<p><strong>Parámetros de compilación</strong></p>
<p>El compilador ZX BASIC, por defecto, lee el código fuente y genera un archivo binario con la extensión .bin que contiene el código máquina (es decir, los bytes del código objeto directamente). Este código máquina no es reubicable, y tiene que ser cargado a partir de la dirección 32768. Como puedes suponer, esto puede ser de poca utilidad si no disponemos de algún método para pasar este código máquina a un emulador o un ZX Spectrum real. Además, puede que queramos que nuestro código empiece en la dirección 28000 (para ganar algo más de memoria que tan escasa es en nuestro ZX). Todo esto y mucho más se puede cambiar con las opciones de compilación.</p>
<p>ZX Basic tiene bastantes parámetros. Sólo veremos los más importantes. Si tecleas zxb -h tendrás una escueta ayuda. Puedes buscar más información en la Wiki del compilador, que está en http://www.boriel.com/wiki/en/index.php/ZXBasic en inglés. Los parámetros tienen una versión larga que empieza con doble guión (por ej. --tzx) y una versión corta equivalente (en este caso, -T). Los parámetros más importantes son:</p>
<ul>
  <li>-T o --tzx hace que el formato de salida sea un archivo de cinta .tzx</li>

  <li>-t o --tap hace que el formato de salida sea un archivo de cinta .tap. Esta opción y la anterior son excluyentes.</li>
  <li>-B o --BASIC hace que se genere un cargador BASIC que cargue nuestro programa. Si usas esta opción, necesariamente tienes que haber usado una de las anteriores.</li>
  <li>-a o --autorun hace que nuestro programa se ejecute automáticamente tras ser cargado. Esta opción obliga a que se use la opción --BASIC, ya que se requiere un cargador BASIC para que el programa se autoejecute.</li>
  <li>-o &lt;fichero de salida&gt;. Permite especificar un nombre de archivo distinto para el programa resultante. Generalmente se usará el mismo nombre que el programa de código fuente (.bas), pero con una extensión distinta (.bin, .tap o .tzx)</li>
  <li>-A o --asm Hace que no se genere el código objeto. En lugar de eso obtendremos el código ensamblador de todo nuestro programa (un archivo ASCII con extensión .asm). Esta opción es útil si queremos optimizar a mano nuestro programa. Se ha intentado que el código ensamblador generado sea bastante legible y con comentarios incluidos.</li>

  <li>-S o --ORG cambia la dirección de comienzo de ejecución del código máquina. Como se dijo antes, por defecto es 32768, pero podemos hacer que se ejecute a partir de una dirección distinta (por ej. 28000) para obtener más memoria.</li>
</ul>

<p><strong>El Lenguaje ZX BASIC</strong></p>
<p>He intentado que el lenguaje ZX BASIC sea lo más similar posible al de Sinclair. Como ya expliqué en el apartado anterior, hay instrucciones que no tienen sentido en un programa compilado y otras que son prácticamente imposibles de implementar. Pero también es cierto que se puede expandir el lenguaje y crear nuevas instrucciones para hacer cosas con la potencia que ahora tenemos. Para llegar a un consenso, se han tomado palabras reservadas del lenguaje FreeBASIC. En general, lo mejor es ir a la Wiki del compilador ZX BASIC ya mencionada pues allí hay una referencia de las palabras clave así como multitud de ejemplos.</p>
<p>Algunas cosas importantes:</p>
<ul>
  <li><p>ZX BASIC distingue en entre mayúsculas y minúsculas en los nombres de variables y funciones. Una variable llamada A es diferente de otra llamada a. Sin embargo en lo que se refiere a palabras reservadas (por ejemplo PRINT o FOR), éstas se pueden escribir como se deseen. La distinción entre mayúsculas y minúsculas para los identificadores de usuario podrá ser configurable en futuras versiones del compilador, pero no actualmente.</p>
  <p>Ejemplo.- Las siguientes palabras reservadas son todas equivalentes</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
PRINT print Print PrInT
</pre>
    </p></td></tr>
</table>
</li>
  <li><p>Como en el Spectrum, el ZX BASIC está orientado a líneas: no puedes partir una línea en medio de una sentencia BASIC. Si deseas hacerlo, usa el carácter de subrayado (_), al final de la línea partida para indicar que ésta continúa en la siguiente.</p>
  <p>Ejemplo.- La siguiente línea partida no dará error, porque lleva un caracter de subguión (o subrayado) al final
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
10 PRINT _
    "Hola Mundo"
</pre>
    </p></td></tr>
</table>
  </p></li>
  <li><p>Los números de línea del BASIC ya no son obligatorios. Son opcionales y se usan como etiquetas. También puedes usar identificadores como etiquetas. De todas maneras, si quieres puedes seguir usando líneas numeradas como en el BASIC tradicional del ZX Spectrum, si te puede la nostalgia (a mí a veces me puede, qué demonios). ¡Además, ya no están limitadas a 9999, y ni si quiera tienen por qué estar numeradas en orden!</p>
  <p>Ejemplo.- Un bucle infinito sin usar numeración de líneas:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
BucleInfinito: REM Esto es una etiqueta.
        PRINT "Hola Mundo" : REM Esto es una línea sin numeración
        GO TO BucleInfinito : REM Esto podría ser GO TO 10 en Sinclair BASIC
</pre>
    </p></td></tr>
</table>
  </li>
</ul>
<p><strong>Los tipos de datos</strong></p>
<p>Si eres un programador de Sinclair BASIC con cierta experiencia seguramente sabrás que el BASIC del ZX Spectrum trabaja siempre en punto flotante. El formato de dicha representación puede resultar complejo y ocupa 5 preciosos bytes (una mantisa de 32 bits y un exponente de 8 en exceso 127, tal y como explica el manual del ZX). Eso se traduce en un coste enorme en tiempo y en memoria. Si solo queremos almacenar valores enteros menores que 255, podríamos usar bytes directamente. Ocuparían la quinta parte de la memoria y su procesado sería mucho más rápido (apenas una o dos instrucciones en ensamblador). Por contra, se puede perder precisión en algunos cálculos. No te preocupes: el formato de punto flotante también está disponible.</p>
<p>Está claro que según el uso que le vayamos a dar a una variable, ésta almacenará un tipo de dato determinado. Este tipo de dato le indica al compilador cómo tratarlo y el tamaño que ocupará en memoria. Así pues, usaremos tipos de datos y diremos que ZX BASIC es un lenguaje tipado. Los tipos de datos que maneja el ZX BASIC son:</p>

<table border="1">
  <tr>

    <th>Tipo</th>
    <th>Tamaño</th>
    <th>Clase de dato</th>
    <th>Intervalo</th>
  </tr>
  <tr>
    <td>Byte</td>

    <td>1 byte</td>
    <td>Entero corto con signo</td>
    <td>[-128 ... 127]</td>
  </tr>
  <tr>
    <td>UByte</td>
    <td>1 byte</td>

    <td>Entero corto sin signo</td>
    <td>[0 ... 255]</td>
  </tr>
  <tr>
    <td>Integer</td>
    <td>2 bytes</td>
    <td>Entero con signo</td>

    <td>[-32768 ... 32767]</td>
  </tr>
  <tr>
    <td>Uinteger</td>
    <td>2 bytes</td>
    <td>Entero sin signo</td>
    <td>[0 ... 65536]</td>

  </tr>
  <tr>
    <td>Long</td>
    <td>4 bytes</td>
    <td>Entero largo con signo</td>
    <td>[-2147483648 a 2147483647] (más de 2.100 millones)</td>
  </tr>

  <tr>
    <td>Ulong</td>
    <td>4 bytes</td>
    <td>Entero largo sin signo</td>
    <td>[0 .. 4294967295] (de 0 a más de 4.200 millones)</td>
  </tr>
  <tr>

    <td>Fixed</td>
    <td>4 bytes</td>
    <td>Decimal con punto fijo</td>
    <td>[-32767.9999847 .. 32767.9999847] con una precisión de 1 / 2^16 (0.000015 aprox.)</td>
  </tr>
  <tr>
    <td>Float</td>

    <td>5 bytes</td>
    <td>Decimal con punto flotante</td>
    <td>Como en el ZX Spectrum</td>
	</tr>
</table>

<p>Estos son todos los tipos de datos numéricos. Los enteros deberían estar claros. Además hay un tipo de decimal en punto fijo, llamado Fixed, muy interesante. Si vas a usar números decimales entre -32767 y 32767 quizá deberías usar este tipo de números (siempre y cuando sólo uses las 4 operaciones básicas: sumas, restas, productos y divisiones).</p>
<p>Estos tipos de datos se usan para almacenar valores y computar expresiones matemáticas. Las expresiones matemáticas usan la misma sintaxis que el Sinclair BASIC y los mismos operadores y precedencia, con la excepción del operador de potencia (^). La expresión 2^2^3 se calcula de forma distinta en un Spectrum que en la mayoría de los lenguajes. Haz la prueba... En cualqueir caso, si tienes dudas, usa paréntesis.</p>

<p><strong>Variables de Cadenas de Carácteres</strong></p>
<p>Al igual que Sinclair BASIC, ZX BASIC también es capaz de manejar cadenas alfanuméricas. Tradicionalmente, en el lenguaje BASIC las variables alfanuméricas se denotaban con el sufijo $. En ZX BASIC (y los BASIC modernos en general) esto es opcional. Además, Sinclair BASIC sólo permitía nombres de variables alfanuméricas de una letra. Aquí no existe esa limitación, pudiendo usar variables alfanuméricas como una_variable_con_nombre_muy_largo$.</p>
<p>Los valores alfanuméricos se pueden unir (concatenar) usando el operador de suma (+), al igual que en Basic de Sinclair.</p>

<p><strong>Asignando Valores a Variables</strong</p>
<p>Al igual que en Sinclair BASIC, se usa la sentencia LET para asignar un valor a una variable. Pero ahora ésta se puede omitir. Las siguientes líneas son equivalentes:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
LET a = 1
a = 1

</pre>
    </p></td></tr>
</table>

<p><strong>DIM: Declarando Variables</strong></p>
<p>Hemos visto que ZX BASIC usa distintos tipos de dato. Cuando usas una variable el compilador intenta adivinar su tipo (si es alfanumérica, entera, etc.), pero en general no va a poder hacerlo. Si no sabe qué tipo asignar, usará el punto flotante como el Sinclair Basic. Esto conlleva un desperdicio de memoria y mayor lentitud. Podemos indicarle al compilador el tipo de dato de una variable declarándola. Para declarar una variable se usa la palabra reservada DIM:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
REM Declaración de dos variables de tipo entero byte sin signo
DIM a, b uByte

REM Declaración de una variable en punto Flotante con valor inicializado
DIM longitud = 3.5 AS Float: REM longitud = 3.5 metros
</pre>
    </p></td></tr>

</table>
<p>Si vas a declarar una variable, tienes que hacerlo antes de su primer uso.</p>

<p><strong>Arrays</strong></p>
<p>Los arrays se declaran como en Sinclair BASIC, y admiten tantas dimensiones como quepan en memoria. No obstante, al contrario que en Sinclair Basic, la numeración de los índices no comienza en 1, sino en 0. Además, podemos declarar opcionalmente el tipo de elemento. Veamos un ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
DIM a(10) AS Float : REM un array de 11 flotantes, del 0 al 10, ambos inclusive
</pre>
    </p></td></tr>
</table>

<p>Podemos trabajar normalmente como en Sinclair BASIC empezando desde índice uno, pero desperdiciaremos la posición 0. No obstante, también podemos declarar el índice mínimo y máximo del array de forma explícita:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
DIM a(1 TO 10, 1 TO 5) AS Float : REM  esto es equivalente a DIM a(10, 5) en el BASIC de ZX Spectrum
</pre>
    </p></td></tr>
</table>
<p>Si queremos que por defecto los arrays comiencen en 1 (como en Sinclair BASIC) y no en 0, hay que usar la opción --array-base=1 al invocar al compilador.</p>
<p>Al contrario que en el BASIC de Sinclair, el nombre de las variables de array puede tener cualquier longitud (estaban limitados a una sola letra en el Spectrum, al igual que las variables de bucles FOR y las alfanuméricas). Existen muchas más cosas que se pueden hacer (como declarar arrays inicializados) pero no las veremos en este artículo. Pregunta en el foro de speccy.org o en del compilador, o mejor consulta la Wiki.</p>
<p>Es posible declarar arrays con valores inicializados. Esto es útil porque no existen ni READ, ni DATA, ni RESTORE. Lo haríamos así:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
REM Definimos un array de 2 filas y 8 columnas
DIM MiUdg(1, 7) AS uByte =&gt; { {60, 66, 129, 129, 129, 129, 66, 60}, _
                              {24, 60, 60, 60, 126, 251, 247, 126}}
</pre>
    </p></td></tr>
</table>
<p>Observa el caracter de subrayado "_" al final de la primera línea del array, ya que hay que partirla (si no, quedaría muy larga).</p>

<p><strong>Sentencias de Control de Flujo</strong></p>

<p><em>GO TO, GO SUB, RETURN</em></p>

<p>Idénticas al BASIC de Sinclair, aunque se desaconseja su uso. GO TO puede escribirse junto, como GOTO. Ídem para GOSUB. Se pueden usar números de línea o etiquetas como vimos en un ejemplo anterior.</p>

<p><em>FOR</em></p>

<p>La sentencia para realizar bucles FOR se comporta de la misma forma que en ZX Basic. No obstante, al ser un lenguaje compilado, tienes que tener en cuenta algunas cosas. Por ejemplo, hacer un bucle FOR usando una variable en punto flotante es bastante más lento que hacerla con una de tipo entero. Su uso es prácticamente igual al del ZX Spectrum, pero hay algunas diferencias:</p>
<ul>
  <li>Los nombres de las variables de bucle FOR pueden tener más de una letra (no así en Sinclair BASIC)</li>
  <li>El nombre de la variable se puede omitir en las sentencias NEXT. O sea, se puede escribir FOR x = 1 TO 10: NEXT : REM  se omite la 'x' en NEXT</li>

  <li>No se puede poner un NEXT en cualquier parte del programa. Tiene que ser después de un FOR. Para bucles anidados (uno dentro de otro) el NEXT interno tiene que referirse obligatoriamente al bucle más interno. Ídem para los restantes bucles.</li>
</ul>
<p>Existen además, dos sentencias de control de bucles nuevas:</p>
<ul>
  <li>EXIT FOR termina el bucle FOR y salta justo al final (solíamos usar on GOTO para esto, ¿verdad?)</li>
  <li>CONTINUE FOR que "continúa" el bucle, es decir, realiza un NEXT. En el BASIC de Sinclair poníamos un NEXT &lt;variable&gt;, pero en ZX BASIC esto no se permite. Hay que usar CONTINUE.</li>
</ul>

<p><em>IF</em></p>
<p>Esta sentencia sí difiere del BASIC tradicional de Sinclair. Es más potente. Admite varias líneas después del THEN, y además incluye la cláusula ELSE ("en otro caso"). Además es necesario terminarla con un END IF. Un ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
IF a &lt; b THEN
    PRINT "a es menor que b"
    PRINT "Esto es otra sentencia más"
ELSE : REM si no...
    PRINT "a no es menor que b"
END IF
</pre>
    </p></td></tr>
</table>
<p>En Sinclair BASIC teníamos que ingeniárnoslas haciendo algo así:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
1000 IF a &lt; b THEN PRINT "a es menor que b": PRINT "Esto es otra sentencia más" : GO TO 1030
1010 REM si no...
1020 PRINT "a no es menor que b"
1030 ...
</pre>
    </p></td></tr>
</table>
<p><em>WHILE</em></p>
<p>Esta sentencia es nueva ZX BASIC y sirve también para hacer bucles. Es más potente que FOR porque el bucle se repite mientras se dé la condición que se indique. Si al empezar el bucle la condición es falsa, entonces no se llega a ejecutar ninguna iteración. Un ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
WHILE a &lt; 10
    LET a = a + 1
END WHILE
</pre>
    </p></td></tr>
</table>
<p>La finalización del bucle tiene que terminarse con END WHILE o con WEND (son equivalentes). Al igual que con FOR, las sentencias EXIT WHILE y CONTINUE WHILE también pueden utilizarse con WHILE para terminar el bucle o continuar con la siguiente iteración.</p>

<p><em>DO ... UNTIL</em></p>
<p>Similar a la anterior, pero aquí la comprobación de la condición se hace al final del bucle y éste se repite mientras no se cumpla la misma (es decir, mientras sea falsa). Al contrario que con WHILE, el bucle se ejecutará al menos una vez. Un ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
DO
    LET a = a + 1
LOOP UNTIL a &gt;= 10
</pre>
    </p></td></tr>
</table>
<p>Igualmente podemos usar CONTINUE DO y EXIT DO para adelantar el bucle o terminarlo anticipadamente.</p>

<p><em>DO ... WHILE</em></p>
<p>Existe también la construcción DO ... WHILE, idéntica a la anterior, solo que esta repite el bucle mientras la condición se cumpla.</p>

<p><strong>Manejo de Memoria</strong></p>

<p><em>PEEK y POKE</em></p>
<p>Son idénticas al Sinclair BASIC, pero ahora, además, está extendidas. Tanto PEEK como POKE admiten especificar el tipo de dato que se guarda en memoria. Por defecto será de tipo byte sin signo (como en el ZX Spectrum). Así pues, las siguientes dos líneas son equivalentes:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
LET a = PEEK 16384
LET a = PEEK(uByte, 16384)
</pre>
    </p></td></tr>
</table>
</p>Pero a veces queremos guardar o leer un entero de 16 bits. En el mismo manual del ZX Spectrum viene un ejemplo. Estos valores, en el Z80 se leen de esta manera:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
REM Guardamos en la variable 'a' la dirección de comienzo de los GDU
LET a = PEEK 23675 + 256 * PEEK 23676 : REM Forma tradicional
LET a = PEEK(Uinteger, 16384)
</pre>
    </p></td></tr>
</table>
<p>Ambas formas son equivalentes, pero la segunda es más eficiente (por el ensamblador generado) y más legible. Si se usa la segunda forma, los paréntesis son obligatorios. Igualmente, podemos guardar con POKE valores de más de un byte:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
REM Cambiamos la dirección de los GDU según la variable 'a'

REM Forma tradicional
POKE 23675, a - INT(a / 256) * a : REM cuidado con el redondeo si a es entera.
POKE 23676, INT(a / 256)

REM Forma moderna
POKE Uinteger 23675, a
</pre>
    </p></td></tr>
</table>

<p>Claramente, la segunda forma es más legible (y preferible). Además, se traduce de forma más eficiente a ensablador. ¡Ahora ya es posible (y extraño), guardar números flotantes con POKE en memoria! Prueba a hacer POKE Float 16384, PI.</p>

<p><strong>Salida por Pantalla</strong></p>

<p><em>PRINT</em></p>
<p>Se ha intentado que PRINT sea lo más compatible posible con el original. De hecho, a nivel sintáctico funciona igual. E incluso los códigos de color de la ROM se pueden utilizar. Esta implementación de PRINT no usa la rutina de la ROM (para mayor velocidad) sino que es propia, y permite imprimir en todas las filas de pantalla. Así pues, PRINT AT 22,0; es una sentencia legal. No existen canales.</p>

<p><em>BORDER, PAPER, INK, INVERSE, BRIGHT, FLASH, OVER</em></p>
<p>Funcionan igual que en Sinclar BASIC. Para BORDER, usar un color mayor que 7 se suele ignorar, ya que sólo se toman los 3 bits más bajos. Para INK y PAPER si se puede usar el valor 8 (transparencia). Over tiene funcionalidades extra: OVER 1 actúa como en el ZX Spectrum e imprime realizando la operacion XOR. Pero se puede usar también OVER 2 y OVER 3 en conjunción con el comando PRINT. OVER 2 realiza un AND y OVER 3 realiza un OR. Esto se puede usar para crear efectos de filmation. Prueba el siguiente ejemplo de BORDER y compara su velocidad con la del Basic de la ROM:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
10 BORDER 0: BORDER 1: GOTO 10
</pre>
    </p></td></tr>
</table>
<p><em>PLOT, DRAW y CIRCLE</em></p>
<p>Funcionan igual que en el Basic original... pero más rápido. PLOT usa la rutina de la ROM, por lo que se aplican todos atributos de color que usa el comando PLOT original. La diferencia ahora es que disponemos de los 192 puntos de pantalla para pintar. La coordenada (0, 0) es ahora la esquina inferior izquierda física de la pantalla. Eso significa que si usamos un comando de dibujado cualquiera, nuestros dibujos aparecerán 16 píxeles más abajo que en el Sinclair BASIC original, pues ahora disponemos de 16 líneas de altura más.</p>
<p>DRAW y CIRCLE están optimizadas (no son las de la ROM) y emplean el algoritmo de Bresenham, por lo que son algo más rápidas (especialmente CIRCLE). También se pueden dibujar arcos, con DRAW x, y, a como en el BASIC original. La rutina está copiada de la ROM, para simular el mismo comportamiento que la original, pero modificada para dibujar también en toda la pantalla, como las anteriores. El siguiente ejemplo está sacado del manual del ZX Spectrum (el reloj), pero está escrito con la nueva sintaxis, sin usar números de línea:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
REM Del manual de ZX Spectrum 48K
REM Un programa de Reloj

REM Primero dibujamos la esfera
CLS
FOR n = 1 to 12
    PRINT AT 10 - (10 * COS(n * PI / 6) - 0.5), 16 + (0.5 + 10 * SIN(n * PI / 6)); n
NEXT n

REM Lo siguiente sería PRINT #0; en el Basic de la ROM
PRINT AT 23, 0; "PULSA UNA TECLA PARA TERMINAR";

FUNCTION t AS ULONG
    RETURN INT((65536 * PEEK (23674) + 256 * PEEK(23673) + PEEK (23672))/50)
END FUNCTION

DIM t1 as FLOAT

OVER 1
WHILE INKEY$ = ""
    LET t1 = t()
    LET a = t1 / 30 * PI: REM a es el ángulo del segundero en radianes
    LET sx = 72 * SIN a : LET sy = 72 * COS a
    PLOT 131, 107: DRAW sx, sy

    LET t2 = t()
    WHILE (t2 &lt;= t1) AND (INKEY$ = "")
        let t2 = t()
    END WHILE : REM Espera hasta el momento de moverlo

    PLOT 131, 107: DRAW sx, sy
END WHILE

</pre>
    </p></td></tr>
</table>
<p><em>SCREEN$, ATTR, POINT</em></p>
<p>Existen y se comportan como en Sinclair BASIC. Pero son funciones externas. Las funciones externas son aquellas que existen en un fichero .BAS aparte. En concreto, en el directorio library/ del compilador hay una biblioteca de funciones que irá creciendo con el tiempo. Para usarlas en tu programa, tienes que usar una directiva de preprocesador como la que sigue:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
#include &lt;screen.bas&gt;
</pre>
    </p></td></tr>

</table>
<p>Los ficheros que las contienen son SCREEN.BAS, ATTR.BAS y POINT.BAS respectivamente. Si miras en ese directorio, verás que hay otras funciones. Enseguida veremos cómo definir nuestras propias funciones.</p>

<p><strong>Sonido</strong></p>

<p><em>BEEP</em></p>
<p>Por ahora, el único soporte de sonido es el comando BEEP, que usa la rutina de la ROM y es idéntico al de Sinclair BASIC. La única ventaja es que aquí, al disponer de mayor rapidez, podemos implementar algunos trucos de sonido. Existe un comando en la versión 128K del BASIC, PLAY que se espera poder implementar en futuras versiones.</p>
<p>El siguiente ejemplo está sacado del manual el ZX Spectrum (Frere Gustav del manual de ZX Spectrum 48K, capítulo 19):</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>

10 PRINT "Frere Gustav"
20 BEEP 1,0: BEEP 1,2: BEEP .5,3: BEEP.5,2: BEEP 1,0
30 BEEP 1,0: BEEP 1,2: BEEP .5,3: BEEP.5,2: BEEP 1,0
40 BEEP 1,3: BEEP 1,5: BEEP 2,7
50 BEEP 1,3: BEEP 1,5: BEEP 2,7
60 BEEP .75,7: BEEP .25,8: BEEP .5,7: BEEP .5,5:BEEP .5,3:
       BEEP.5,2: BEEP 1,0
70 BEEP .75,7: BEEP .25,8: BEEP .5,7: BEEP .5,5: BEEP .5,3: BEEP .5,2:
       BEEP 1,0
80 BEEP 1,0: BEEP 1,-5: BEEP 2,0
90 BEEP 1,0: BEEP 1,-5: BEEP 2,0
</pre>
    </p></td></tr>
</table>
<p><strong>Funciones Matemáticas y Números aleatorios</strong></p>
<p><em>STR$, VAL, PI, SIN, COS, TAN, ASN, ACS, ATN, EXP</em></p>
<p>Estas funciones trabajan todas igual que en el BASIC original del ZX Spectrum a excepción de VAL. Como ya se dijo antes, VAL es un caso particular prácticamente imposible de compilar. Funciona como en la mayoría de los BASIC estándar: se convierte una cadena alfanumérica a punto flotante, pero esta cadena sólo puede contener un número (no una expresión). Si una cadena no se puede convertir, se devuelve 0. Luego VAL "x+x" devolverá 0 siempre, aunque la variable x esté definida.</p>
<p><em>RANDOMIZE, RND</em></p>
<p>Existen y se usan como en el ZX Spectrum con la diferencia de que la rutina de números aleatorios es más rápida ya que no usa la calculadora de punto flotante de la ROM sino registros y desplazamientos en ensamblador. Esta rutina es un generador lineal congruente (como la del ZX Spectrum) pero usa números de 32 bits, por lo que tiene un periodo de miles de millones (antes de que vuelva a repetirse la secuencia). Se ha sacado del libro Numerical Recipes in C (disponible gratuitamente en internet, aunque vale la pena comprarlo). Además, tiene una mejor dispersión. Prueba el siguiente programa en el ZX Spectrum, tanto en el BASIC de la ROM como en ZX BASIC (compilado):</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
10 LET x = INT(RND * 256): LET y = INT(RND * 175)
20 PLOT x, y
30 GOTO 10
</pre>
    </p></td></tr>
</table>
<p>Aparte de la velocidad del programa compilado, notarás que en la versión del BASIC de Sinclair aparecen líneas diagonales. Ello indica que la aleatoriedad de los números no es tan alta en el BASIC de la ROM como se podría esperar.</p>

<p><strong>Entrada y salida</strong></p>
<p><em>INKEY$, IN, OUT</em></p>
<p>También están presentes y funcionan de forma idéntica a la de Sinclair BASIC... excepto por su velocidad, que es bastante mayor  en el caso de IN y OUT.</p>

<p><strong>Caracteres gráficos, GDU y códigos de color</strong></p>

<p>Para poder introducir caracteres gráficos y códigos de color, se ha seguido el mismo convenio que BASIN (un entorno para programar y depurar programas BASIC del ZX Spectrum). Así, dentro de una cadena de caracteres, el caracter de barra invertida '\' tiene un significado especial. Así, para escribir un el GDU "A", escribiremos PRINT "\A". Si queremos escribir varios carácteres gráficos seguidos, "AB", escribiremos: PRINT "\A\B". Si queremos imprimir la barra invertida (este carácter existe en el Spectrum), usaremos doble barra: PRINT "\\"</p>
<p>Los símbolos gráficos (aquellos que tenían formas de cuadraditos y que se sacaban en con el cursor en modo gráfico y pulsando un número del 0 al 8) también pueden ponerse como en BASIN. Prueba a poner PRINT "\:.\'.". Como puedes ver, se componen de la barra invertida seguido de dos caracteres que pueden ser uno de estos: [ ][.]['][:] (espacio en blanco, punto, apóstrofe y dos puntos). Cada "puntito" del caracter representa un cuadrado del gráfico (es difícil de explicarlo, lo mejor es que lo pruebes). Estos códigos son leídos por el compilador y reemplazados por un solo byte, correspondiente al código ASCII del caracter que queramos representar. Puedes probar a hacer un programa BASIC en Basin y grabarlo como .bas (ASCII) y ver la secuencia de caracteres generada.</p>
<p>Igualmente, los códigos de color, brillo, flash e inversión de vídeo pueden especificarse "en línea", como se hacía con el ZX Spectrum, siguiendo el mismo convenio que BASIN. Para escribir por ejemplo, HOLA con tinta roja sobre fondo negro, puedes hacer: PRINT "{i2}{p0}HOLA"</p>

<p>Los códigos son:</p>

<table border="1">
  <tr>
    <th>Código</th>
    <th>Significa</th>

    <th>Valores</th>
  </tr>
  <tr>
    <td>{iN}</td>
    <td>Tinta</td>
    <td>N = 0..7</td>
  </tr>

  <tr>
    <td>{pN}</td>
    <td>Papel</td>
    <td>N = 0..7</td>
  </tr>
  <tr>
    <td>{fN}</td>

    <td>Flash</td>
    <td>N = 0..1</td>
  </tr>
  <tr>
    <td>{vN}</td>
    <td>Inverse</td>
    <td>N = 0..1</td>

  </tr>
  <tr>
    <td>{bN}</td>
    <td>Brillo</td>
    <td>N = 0..1</td>
  </tr>
</table>

<p>Además, puedes especificar cualquier caracter ASCII en decimal, usando \#xxx. Por ejemplo, el copyright puedes ponerlo como PRINT "\*" o bien como PRINT "\#127"</p>

<p><strong>Funciones y Subrutinas</strong></p>
<p>Una de las grandes diferencias del ZX BASIC respecto a sinclair BASIC es la posibilidad de definir funciones y subrutinas, y que además estas contengan variables privadas. La única posibilidad que ofrecía el BASIC de Sinclair para definir funciones era con DEF FN, que aquí ya no existe. Para definir una función, usaremos la palabra reservada FUNCTION, así:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
FUNCTION mifuncion(x AS Integer, y AS Byte) AS Integer
    REM Función que devuelve x + y
    RETURN x + y
END FUNCTION
</pre>
    </p></td></tr>
</table>
<p>Esta pequeña función recibe 2 parámetros, un entero de 16 bit en x y un byte en y, para devolver la suma de ambos (x + y).</p>

<p>Para usar la función, sólo tienes que llamarla como como si fuera una función BASIC cualquiera:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
PRINT mifuncion(3, 5) : REM Imprime 8
</pre>
    </p></td></tr>
</table>
<p>Mira el ejemplo anterior del reloj, cómo define y usa una función.</p>
<p>También se puede llamar a una función sin más, como si fuera una subrutina:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
mifuncion(3, 5) : REM suma 3 + 5 y luego los descarta y no hace nada con el resultado
</pre>
    </p></td></tr>
</table>
<p>Al igual que las funciones, también puedes definir subrutinas. Se definen usando la palabra reservada SUB. La sintaxis es muy similar a la anterior:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
SUB misubrutina(x AS Integer, y AS Byte)
    REM Función que devuelve x + y
    PRINT x + y
END SUB
</pre>
    </p></td></tr>
</table>

<p>Y la invocamos así</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
misubrutina(3, 6) : REM imprime 9
</pre>
    </p></td></tr>
</table>
<p>La diferencia principal es que SUB siempre tiene que invocarse. Nunca devuelve un resultado, al contrario que las funciones. De hecho, no puedes usar RETURN &lt;valor&gt; para salir de una subrutina, sino simplemente RETURN. Retornar de una subrutina o función y retornar de un GOSUB son cosas distintas. Al escribir simplemente RETURN, desde dentro de una función o subrutina siempre se supondrá que se retorna de la misma y no de un GOSUB.</p>
<p>Esto es así porque cada vez que se retorna, el programa tiene que hacer ciertas gestiones con la pila de código máquina antes de regresar. Así pues, no es lo mismo retornar de un GOSUB, que de una función o subrutina. Al declarar una subrutina ya le estamos indicando al compilador que no es necesario devolver ningún valor, y eso permite hacer una pequeña optimización.</p>

<p>Por último, las variables declaradas (DIM) dentro de una subrutina o función son privadas y no son accesibles desde fuera. Además, sólo usan memoria durante la ejecución de la función. Al salir de la misma, esa memoria se libera (se usa la pila de código máquina). Mira este ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
SUB Ejemplo
    DIM a as Integer: REM esta variable es privada

    LET a = 5
    PRINT "En la subrutina, a="; a
END SUB

LET a = 10
PRINT "Antes de la subrutina, a="; a
Ejemplo() :  REM  llamamos a la subrutina ejemplo e imprime la variable privada
PRINT "Despues de la subrutina, a ="; a
</pre>
    </p></td></tr>
</table>
<p><strong>ASM integrado</strong></p>
<p>Es posible meter líneas de ASM directamente. Esto es una característica de muy bajo nivel, y se sale un poco de los propósitos de este artículo. Básicamente, se puede incrustar ASM directamente en el código así:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
ASM
...
...
END ASM
</pre>
    </p></td></tr>
</table>
<p>Como ZX Basic aspira a ser multiplataforma (reorientable), el código que hagas con ASM directo sólo compilará en la arquitectura que soporte ese ensamblador (en nuestro caso, Z80). Aquí tienes un ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
ASM
ld a, 0FFh
ld (16384), a
END ASM
</pre>
    </p></td></tr>
</table>

<p>La idea de usar ASM directamente es en aquellos bucles que requieran mucha velocidad (por ejemplo, alguna subrutina de algún juego). Si miras la biblioteca de funciones, library/ verás que muchas funciones están definidas en ensamblador.</p>

<p><strong>Lo que falta...</strong></p>
<p>No todo iba a ser perfecto. ZX Basic, por ser compilado, tiene cosas que le faltan. Por ejemplo, no existe INPUT. Te la tendrás que implementar (la mayoría de los juegos se implementan su propio INPUT; fíjate en El Hobbit). Ya hay una función INPUT implementada en en la biblioteca de funciones, por si te interesa esa. Prueba a usarla.</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
REM Importamos la función input
#include &lt;input.bas&gt;

LET a$ = input(32): REM Input de una cadena de 32 caracteres como máximo
PRINT a$
</pre>

    </p></td></tr>
</table>
<p>Es muy difícil utilizar el INPUT de la ROM, que usa canales (que ya no existen aquí), y otras zonas del área de BASIC que pueden corromper el programa compilado o la pila de ejecución (aunque se supone que el CLEAR del cargador evitará esto). Tampoco tienen sentido READ, DATA y RESTORE. Son un desperdicio de memoria e imposibles de compilar tal y como las ofrece el BASIC de la ROM; aunque es probable que se implementen en un futuro con ciertas limitaciones.</p>

<p><strong>Ejemplos</strong></p>
<p>Este artículo está quedando muy extenso, así que lo cortaré aquí (si fuera para MicroHobby, daría para varios números). Quedan algunas cosas por explicar (como el alias de variables o las instrucciones de manejo de bits: rotaciones, etc.) En cuaquier caso, en el directorio examples tienes varios ejemplos que puedes compilar para aprender cómo funcionan. El ejemplo de la Bandera Inglesa está sacado del manual del ZX Spectrum y funciona tal cual está, sin ninguna modificación. Otros ejemplos, como el Snake (cortesía de Federico J. Alvarez Valero, año 2003) se han retocado para declarar explícitamente el tipo de dato de algunas variables (recordemos que trabajar con enteros es más rápido que punto flotante), y terninar los IF con sus END IF correspondientes.</p>

<p><strong>Y pasaron los años...</strong></p>
<p>¿20 años? ¡Glup! Al menos se cumplió una parte del sueño (la otra no os la digo...). ¿Fue demasiado tarde? No lo creo. Al menos no en parte.</p>
<p>El ZX Spectrum, los micros en general, y su época de alguna manera dejaron huella. Muchos pensamos que esto fue irrepetible. En aquella época la tecnología no avanzaba tan rápidamente como ahora y es por eso que micros como el ZX Spectrum duraron de media una década sin sufrir grandes cambios. Por contra las videoconsolas y sistemas actuales apenas pasan de los 3 ó 4 años de vida.</p>

<p>Hoy día estamos tan saturados y acostumbrados a los cambios que ya nada nos asombra (o al menos a mí). Miles de millones de píxeles en miles de millones de colores con un sonido envolvente no consiguen dejar esa impronta que una máquina tan simple logró en apenas unas horas. Quizá porque fue la primera, no lo sé. Pero me consta que las generaciones actuales no sienten esa pasión y ese tirón por las máquinas. La PS3, la XBOX, el iPhone o el PC. Ninguno consigue enganchar tanto a los chicos de hoy día.</p>
<p>Suena un poco nostálgico, lo sé, pero creo que hemos tenido la suerte de haberlo podido vivir.</p>

<p><br></p>
<p><strong>Enlaces y ficheros</strong></p>
<ul>
<li><a href="src/zxbexamples.zip">Ejemplos en BASIC</a> listos para compilar con ZXBasic.</li>
</ul>

</div>
        </td>

    </tr>
    <tr>
        <td align="right"><br><br>Boriel</td>
    </tr>
</table>
                    </td>
                </tr>
                <tr><td>&nbsp;</td></tr>
                <tr>

                    <td>
<script language="JavaScript">
function RecargarPie(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">
        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('al-descubierto.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
        <option value="index.html">Portada</option>

        <option value="editorial.html">Índice - Editorial</option>
        <option value="panorama.html">Panorama</option>
        <option value="la-historia-del-spectrum.html">La historia del Spectrum</option>
        <option value="el-aventurero.html">El Aventurero</option>
        <option value="analisis.html">Análisis</option>
        <option value="computone.html">Computone</option>

        <option value="al-descubierto.html">Al Descubierto</option>
        <option value="basic.html" selected>Programación BASIC</option>
        <option value="z88dk.html">Programación Z88DK</option>
        <option value="ensamblador.html">Programación Ensamblador</option>
        <option value="128k-mode.html">128K MODE</option>
        <option value="input.html">INPUT</option>

        <option value="tira-comica.html">Tira cómica</option>
        <option value="opinion.html">Opinión</option>
    </select>
    <input type="button" onclick="RecargarCabecera('z88dk.html');" name="siguiente" value=">" />
</td>
            <td align="right" class="texto">
                <a href="#arriba">Volver arriba</a>
            </td>

        </tr>
        <tr><td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>
    </form>
</table>
                    </td>
                </tr>
                <tr>

                    <td>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
	<tr align="center" valign="center">
		<td>2003-2009 Magazine ZX</td>
	</tr>
</table>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-8018503-4");
pageTracker._trackPageview();
} catch(err) {}</script>
                    </td>

                </tr>
            </table>

    </body>
</html>
