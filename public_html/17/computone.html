<!doctype html>
<html lang="es">
<head>
    <title>Computone - Magazine ZX número 17 - Marzo 2009</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/magazine.css" type="text/css">
</head>
<body>
<table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
    <tr>
        <td>
            <a name="arriba"></a>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
                <tr align="center" valign="center">
                    <td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0"/></a></td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarCabecera(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>
                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('analisis.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="la-historia-del-spectrum.html">La historia del Spectrum</option>

                                <option value="el-aventurero.html">El Aventurero</option>
                                <option value="analisis.html">Análisis</option>
                                <option value="computone.html" selected>Computone</option>
                                <option value="al-descubierto.html">Al Descubierto</option>
                                <option value="basic.html">Programación BASIC</option>
                                <option value="z88dk.html">Programación Z88DK</option>

                                <option value="ensamblador.html">Programación Ensamblador</option>
                                <option value="128k-mode.html">128K MODE</option>
                                <option value="input.html">INPUT</option>
                                <option value="tira-comica.html">Tira cómica</option>
                                <option value="opinion.html">Opinión</option>
                            </select>

                            <input type="button" onclick="RecargarCabecera('al-descubierto.html');" name="siguiente"
                                   value=">"/>
                        </td>
                        <td align="center" class="texto">Número 17 - Marzo 2009</td>
                        <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX"
                                             onClick="window.open(this.href); return false;"><img
                                src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0"
                                alt="ZX Certified webmaster"></a> <a href="http://www.speccy.org/"
                                                                     onClick="window.open(this.href); return false;"><img
                                src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a>
                        </td>
                    </tr>
                </form>
            </table>
            </a>
        </td>
    </tr>

    <tr>
        <td> </td>
    </tr>
    <tr>
        <td>
            <style type="text/css">
                table.flags {
                    background: grey;
                    margin: 0;
                    padding: 0;
                }

                table.flags td, table.flags th {
                    background: white;
                    margin: 0;
                    padding: 4px;
                }
            </style>
            <table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
                <tr>
                    <td>
                        <div align="justify">
                            <p align="center"><font size="5">Save y Load: almacenamiento en cinta</font></p>

                            <p>¿Te has preguntado alguna vez en qué formato se almacenan los datos en una cinta de
                                cassette para que el Spectrum pueda después cargar desde ellas pantallas de
                                presentación, los personajes de un juego o el código ejecutable de un programa?</p>

                            <p>En este artículo vamos a mostraros cómo se graban y estructuran los datos en las cintas,
                                y qué hace el Spectrum para acceder a ellos mediante las rutinas de que nos provee la
                                ROM. Para aquellos de vosotros que queráis dar una aplicación práctica a lo que veremos
                                hoy, se incluirá código de carga y grabación de pantallas y un ejemplo completo para
                                probar.</p>

                            <p><b>Formato de los datos en cinta</b></p>

                            <p>Supongamos que, desde BASIC, salvamos un bloque de datos en cinta con el comando SAVE. Lo
                                primero que nos interesa conocer es el <em>formato</em> o <em>estructura de los
                                    datos</em> almacenados en la cinta, es decir, ¿qué se guarda realmente en la cinta
                                (en formato de audio) cuando hacemos un SAVE?</p>

                            <p>Un SAVE produce 2 bloques de datos en la cinta:</p>

                            <ul>
                                <li>Un bloque de 19 bytes de tamaño fijo, conocido como cabecera. Este bloque es cargado
                                    muy rápidamente, debido a su pequeño tamaño. Si pensáis en los cientos ó miles de
                                    LOADs desde cinta que habréis hecho en vuestro Spectrum, recordaréis, nada más
                                    pulsar PLAY, la aparición del tono guía (líneas del borde rojas y cyan) seguido de
                                    un brevísimo momento de carga de datos (líneas del borde azules y amarillas). Es en
                                    ese momento en el que aparece en pantalla la información relativa al juego/programa
                                    que estamos cargando.
                                </li>
                                <li>Un bloque de longitud variable que contiene los datos concretos y reales a cargar.
                                </li>
                            </ul>

                            <p>Ambos bloques son en realidad "datos" con el siguiente formato:</p>

                            <ul>
                                <li>Un byte inicial, que como veremos se llama Flag Byte.</li>

                                <li>Los datos en sí mismos: 17 bytes para cabeceras, o la longitud concreta de los datos
                                    para los bloques de datos.
                                </li>
                                <li>Un byte de checksum o CRC.</li>
                            </ul>

                            <p>Profundicemos un poco más en estos 2 bloques de datos:</p>

                            <p>Cada bloque se inicia con una serie de pulsos de 2168 t-stados cada uno, que constituyen
                                el tono guía. La cantidad de pulsos (la duración) de este tono guía es de 8063 pulsos
                                para los bloques de cabecera, y 3223 pulsos para los bloques de datos. Es por eso que la
                                duración del tono guía (el famoso pitido inicial de la carga) es mayor para la carga de
                                la cabecera que para el de los datos en sí mismos. Es decir, el tono guía está presente
                                tanto para los bloques de cabecera como para los de datos, salvo que su duración es
                                menor en los bloques de datos.</p>

                            <p> Un <b>t-stado</b> (t-state) es 1 ciclo de reloj, y equivale a 1 / 3.500.000 segundos.
                            </p>


                            <p>Veamos una figura donde se muestra el estado del <b>mapa de memoria del Spectrum</b>:</p>


                            <table border="0" cellspacing="0" cellpadding="2" width="320">
                                <tr align="right">
                                    <td><img src="img/tono_guia.png" width="320" height="240"
                                             alt="Aspecto del tono guía"/>
                                    </td>
                                </tr>
                                <tr>

                                    <td class="piefoto" align="right">Aspecto del tono guía</td>
                                </tr>
                            </table>


                            <p>Tras el tono guía de la cabecera viene la cabecera en sí misma (que no dejan de ser
                                datos). Su carga, como ya hemos dicho, tarda un tiempo muy corto en realizarse, ya que
                                son sólo 19 bytes a ser leídos desde el cassette.</p>


                            <table border="0" cellspacing="0" cellpadding="2" width="320">
                                <tr align="right">
                                    <td><img src="img/header.png" width="320" height="240"
                                             alt="Una vez cargada la cabecera."/>

                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Una vez cargada la cabecera.</td>
                                </tr>
                            </table>


                            <p>En la imagen anterior podemos ver el aspecto de la pantalla una vez terminado el tono
                                guía y cargada la cabecera. Esta cabecera, mediante sus 19 bytes, le indican al Spectrum
                                la naturaleza de los datos a cargar en el bloque de datos que sigue a la misma, con el
                                siguiente formato:</p>

                            <table class="flags">

                                <tr>
                                    <th>Byte</th>
                                    <th>Longitud</th>
                                    <th>Descripción</th>
                                </tr>
                                <tr>
                                    <td>0</td>
                                    <td>1</td>
                                    <td>Byte Flag (0x00 ó 0xFFF).</td>
                                </tr>
                                <tr>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>Tipo de bloque (0-3).</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>10</td>
                                    <td>Nombre de fichero (rellenado con espacios en blanco).</td>
                                </tr>

                                <tr>
                                    <td>12</td>
                                    <td>2</td>
                                    <td>Longitud del bloque de datos a cargar.</td>
                                </tr>
                                <tr>
                                    <td>14</td>
                                    <td>2</td>
                                    <td>Parámetro 1.</td>
                                </tr>
                                <tr>
                                    <td>16</td>
                                    <td>2</td>
                                    <td>Parámetro 2.</td>
                                </tr>
                                <tr>
                                    <td>18</td>
                                    <td>1</td>
                                    <td>Checksum / Suma de comprobación.</td>
                                </tr>

                            </table>

                            <p>Pasemos a describir los diferentes campos de la cabecera:</p>

                            <p>El byte de flag (Byte 0) y el de Checksum (byte 18) no forman parte exactamente de la
                                cabecera, sino del bloque cargado en sí mismo (también están presente cuando cargamos
                                datos y no cabeceras), pero se han incluído dentro de la tabla para hacerla de lectura
                                más sencilla. Puede decirse que el byte-flag es el byte prefijo de todo bloque de datos
                                (considerando una cabecera de 17 bytes como un bloque de datos) y el checksum es el byte
                                sufijo de ese mismo bloque. Concretamente, el valor de Byte-Flag es de 0x00 para bloques
                                de cabecera y 0xFF para bloques de datos.</p>

                            <p>El byte de tipo de bloque indica qué datos se van a cargar a continuación, según los
                                siguientes valores:</pi>

                            <table class="flags">
                                <tr>
                                    <th>Valor</th>
                                    <th>Significado</th>
                                </tr>
                                <tr>
                                    <td>0</td>
                                    <td>Programa.</td>
                                </tr>

                                <tr>
                                    <td>1</td>
                                    <td>Array de números.</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>Array de caracteres.</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>CODE (datos a cargar en memoria).</td>
                                </tr>
                            </table>


                            <p>En el caso de bloques de tipo CODE, el byte "Parámetro 1" define la dirección de inicio
                                del bloque de código cuando se hizo el SAVE, y el parámetro 2 contiene el valor
                                32768.</p>

                            <p>Para bloques de tipo PROGRAM, el Parámetro 1 contiene el valor de la línea BASIC de
                                autostart (o un número mayor de 32768 si no se dio un parámetro LINE al hacer el SAVE),
                                y el Parámetro 2 contiene el inicio del área de variables relativa al inicio del
                                programa.</p>

                            <p>Un detalle: una pantalla de datos (SCREEN$) se define en esta cabecera como un bloque de
                                tipo CODE de 6912 bytes a cargar sobre la dirección 16384.</p>

                            <p>Tras la cabecera (tono guía + bloque datos) viene el bloque de datos en sí mismo, que
                                vuelve a componerse de un tono guía, el Flag Byte, los datos y el checksum.</p>


                            <table border="0" cellspacing="0" cellpadding="2" width="320">
                                <tr align="right">
                                    <td><img src="img/bloque_datos.png" width="320" height="240"
                                             alt="Aspecto de la carga del bloque de datos en sí mismo."/>
                                    </td>

                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Aspecto de la carga del bloque de datos en sí
                                        mismo.
                                    </td>
                                </tr>
                            </table>


                            <p>Ahora bien ... ¿cómo es posible que se almacenen como audio datos digitales? ¿Cómo
                                entiende el Spectrum si los datos que está cargando son unos o ceros y los agrupa en
                                bloques de bytes que podemos interpretar de forma lógica?</p>

                            <p>Como ya hemos comentado al hablar del tono guía, la clave está en la temporización
                                precisa a la hora de leer datos desde la cinta. Aparte de tonos guía y pulsos de
                                sincronización ... ¿qué es un cero en la cinta? ¿qué es un uno? ¿Cómo se almacena (y
                                lee) un byte de 8 bits? ¿Y cómo se almacena (y lee) un conjunto de bytes?</p>

                            <ul>
                                <li>Un cero (bit=0) se codifica en cinta como 2 pulsos de una duración de 855 t-stados
                                    cada uno.
                                </li>
                                <li>Un uno (bit=1) se codifica en cinta como 2 pulsos de una duración de 1710 t-stados
                                    cada uno.
                                </li>
                                <li>Para almacenar los 8 bits de un byte, se almacenan bit a bit de mayor a menor peso
                                    (primero el bit 7, luego el 6, el 5, el 4, el 3, el 2, el 1 y finalmente el LSB o
                                    bit 0).
                                </li>
                                <li>Cuando se almacena más de un byte (un bloque) se guardan primero los datos del
                                    primer byte del bloque, luego el segundo, etc.
                                </li>
                            </ul>

                            <p>Los pulsos son ondas con un aspecto como el siguiente (aspecto de un tono guía en
                                TAPER):</p>


                            <table border="0" cellspacing="0" cellpadding="2" width="237">

                                <tr align="right">
                                    <td><img src="img/pilot.png" width="237" height="293"
                                             alt="Aspecto de un tono guía (TAPER)."/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Aspecto de un tono guía (TAPER).</td>
                                </tr>
                            </table>


                            <p>Es decir, si tenemos que almacenar en cinta los siguientes bytes:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
abcdefgh ijklmnop
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Se almacenarían en cinta en este orden:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

                                <tr>
                                    <td><p class="codigo">
                                        <pre>
a b c d e f g h i j k l m n o p
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Así pues, la rutina de la ROM del Spectrum se encarga (tanto al grabar como al leer) de
                                codificar pulsos de diferentes duraciones para almacenar los ceros y unos de forma
                                consecutiva. Nosotros aprovecharemos (como veremos a continuación) dicha rutina para
                                cargar o salvar bloques de datos a nuestro antojo sin tener que programar esas
                                temporizaciones y lecturas/escrituras a la cinta. Para nosotros será tan sencillo como
                                cargar los valores adecuados en ciertos registros y realizar un CALL. No obstante, para
                                los más curiosos, al final de este capítulo tenéis un enlace a las rutinas de la ROM
                                adecuadamente comentadas de "The Complete Spectrum ROM Disassembly", por el Ian Logan y
                                Frank O'Hara (publicado en 1983).</p>

                            <p>El nivel más bajo al que necesitamos llegar es el siguiente:</p>

                            <ul>
                                <li>Cada bloque tiene la siguiente estructura física:<br><br></li>

                                <ul>
                                    <li>Un tono guía de 8063 (cabeceras) ó 3223 pulsos (datos) de 2168 t-stados cada
                                        uno.
                                    </li>
                                    <li>Un pulso de sincronización de 667 t-stados.</li>
                                    <li>Un segundo pulso de sincronización de 735 t-stados.</li>
                                    <li>El bloque de datos en sí mismo, bit a bit (0 = 2 pulsos de 855 t-stados, 1 = 2
                                        pulsos de 1710 t-stados).<br><br></li>
                                </ul>
                                <li>Cada bloque tiene la siguiente estructura lógica (formato de los datos DENTRO de un
                                    bloque):<br><br></li>
                                <ul>
                                    <li>Flag byte, con un valor de 0x00 para bloques de cabecera o 0xFF para bloques de
                                        datos.
                                    </li>
                                    <li>Los datos en sí mismos: 17 bytes para cabeceras, o la longitud concreta de los
                                        datos para los bloques de datos.
                                    </li>

                                    <li>Un byte de checksum, calculado de forma que haciendo un XOR de todos los bytes
                                        juntos, incluyendo el flag Byte, produzca 0x00.
                                    </li>
                                </ul>
                            </ul>

                            <p>Resumiendo:</p>

                            <ul>
                                <li>Los datos salvados en cinta constan de tono guía, seguido de un bloque de datos de
                                    19 bytes denominado cabecera, seguido de un tono guía de menor duración que el
                                    inicial (por ser de datos), seguido de los datos en sí mismos.
                                </li>
                                <li>Esa cabecera proporciona información sobre el nombre, duración y ciertos parámetros
                                    relativos a los datos en sí mismos (el segundo bloque cargado).
                                </li>
                                <li>Los datos se leen de cinta secuencialmente, del primer al último byte del bloque de
                                    datos, y almacenado cada byte desde el bit 7 al 0 secuencialmente.
                                </li>
                                <li>Los 1s y los 0s se almacenan en cinta como pulsos de duraciones concretas.</li>

                                <li>Las rutinas de la ROM nos permiten leer y escribir en cinta bloques de datos,
                                    realizando ellas la temporización adecuada para convertir nuestros "datos en
                                    memoria" en "pulsos" o viceversa sin complicación por nuestra parte.
                                </li>
                                <li>Sólo necesitaríamos escribir una rutina propia de carga (que detecte pulsos,
                                    temporice, etc) si quisiéramos programar nuestra propia carga, por ejemplo para
                                    cargar a diferente velocidad que el Spectrum (ultracargas), que cargue de
                                    dispositivos externos (puerto de joystick, algún pin concreto del bus de expansión,
                                    etc.) o para ejecutar código mientras cargamos el programa (minijuegos durante la
                                    carga, contadores de carga, etc). Para el resto de casos, bastará con usar mediante
                                    CALL las rutinas de la ROM.
                                </li>
                            </ul>

                            <p><b>Ejemplo de volcado de un SAVE</b></p>

                            <p>En la FAQ de comp.sys.sinclair y WorldOfSpectrum tenemos un ejemplo muy interesante que
                                muestra el formato lógico de los datos grabados con un SAVE en cinta. Supongamos el
                                siguiente comando BASIC:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
SAVE "ROM" CODE 0,2

</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Este comando BASIC salvaría (SAVE), un total de 2 bytes (2) de datos (CODE), empezando en
                                0 (0) a cinta. En resumen, salvaría el contenido de la dirección de memoria 0x0000 y
                                0x0001 en cinta. Esto produciría los siguientes datos en cinta:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1 ff f3 af a3
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Comencemos mostrando qué representa cada dato poco a poco:</p>

                            <table class="flags">
                                <tr>
                                    <th>Cabecera</th>
                                    <th>Bloque de datos</th>
                                </tr>
                                <tr>
                                    <td>00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1</td>
                                    <td>ff f3 af a3</td>
                                </tr>
                            </table>

                            <p>Desgranando más la información:</p>

                            <table class="flags">
                                <tr>
                                    <th>Byte Flag</th>
                                    <th>Datos cabecera</th>
                                    <th>Checksum</th>
                                    <th>Byte flag</th>
                                    <th>Datos ROM</th>
                                    <th>Checksum</th>
                                </tr>
                                <tr>
                                    <td>00</td>
                                    <td>03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80</td>
                                    <td>f1</td>
                                    <td>ff</td>
                                    <td>f3 af</td>
                                    <td>a3</td>
                                </tr>

                            </table>

                            <p> Concretamente, los datos de la cabecera (ignorando el Byte Flag y el Checksum):</p>

                            <table class="flags">
                                <tr>
                                    <th>Tipo de bloque</th>
                                    <th>Nombre de fichero</th>
                                    <th>Longitud bloque</th>
                                    <th>Parámetro 1</th>
                                    <th>Parámetro 2</th>
                                </tr>
                                <tr>
                                    <td>03</td>
                                    <td>52 4f 4d 20 20 20 20 20 20 20</td>
                                    <td>02 00</td>
                                    <td>00 00</td>
                                    <td>00 80</td>
                                </tr>

                            </table>

                            <p>Como véis el nombre "<b>ROM</b>" (52 4F 4D) se completa con espacios en blanco hasta los
                                10 caracteres. Además podemos ver la longitud del bloque que se salvó (02 bytes).</p>

                            <p>Después de estos datos tenemos el checksum (F1) y el bloque de datos en sí mismo:</p>

                            <table class="flags">
                                <tr>
                                    <th>Byte Flag</th>
                                    <th>Datos grabados</th>
                                    <th>Checksum</th>
                                </tr>
                                <tr>
                                    <td>ff</td>
                                    <td>f3 af</td>
                                    <td>a3</td>
                                </tr>

                            </table>

                            <p>En este caso el byte flag es 0xFF (bloque de tipo "datos"), al cual siguen los 2 bytes
                                tomados de la ROM y grabados a cinta (0x0000 y 0x0001) y el checksum (0xA3).</p>


                            <p><b>Rutinas de carga de la ROM</b></p>

                            <p>Ya sabemos cómo se almacenan los datos en cinta, así que nuestra próxima misión es
                                conocer cómo cargarlos o grabarlos de una manera sencilla. Para hacer esto usaremos las
                                funciones de la ROM del Spectrum para carga y grabación de datos a cinta: hablamos de 2
                                subrutinas (de LOAD y SAVE) a las que podremos llamar con unos parámetros concretos.</p>

                            <p><b>Rutina de LOAD de la ROM</b></p>

                            <p>La rutina de LOAD comienza en la dirección $0556 (0556h ó 1366d) y requiere los
                                siguientes parámetros:</p>

                            <table class="flags">
                                <tr>
                                    <th>Registro</th>
                                    <th>Valor</th>
                                </tr>
                                <tr>
                                    <td>IX</td>
                                    <td>Dirección inicio de memoria donde almacenar los datos que se van a cargar.</td>
                                </tr>
                                <tr>
                                    <td>DE</td>
                                    <td>Longitud del bloque de datos a cargar.</td>
                                </tr>
                                <tr>
                                    <td>A</td>
                                    <td>Flag Byte, normalmente 0x00 para cargar cabeceras o 0xFF (255) para cargar
                                        datos.
                                    </td>
                                </tr>

                                <tr>
                                    <td>CF (CarryFlag)</td>
                                    <td>1=LOAD, 0=VERIFY</td>
                                </tr>
                            </table>

                            <p>La rutina devuelve el CF = 0 si ocurre alguno de los siguientes errores:</p>

                            <ul>
                                <li>"R-Tape Loading Error" (bien por timeout o bien por byte de paridad incorrecto).
                                </li>
                                <li>Flag Byte incorrecto.</li>
                                <li>"D BREAK - CONT repeats" (se pulsó la tecla BREAK).</li>
                            </ul>

                            <p>Recuerda que puedes activar el CARRY FLAG con la instruccion "SCF" (Set Carry Flag) y
                                ponerlo a cero con un simple "AND A".</p>

                            <p>Veamos 2 ejemplos, el primero cargaría una pantalla gráfica sobre la videomemoria (el
                                equivalente de un LOAD "" SCREEN$) siempre y cuando la pantalla se haya grabado sin
                                cabecera:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
   SCF                ; Set Carry Flag -> CF=1 -> LOAD
   LD A, 255          ; A = 0xFF (cargar datos)
   LD IX, 16384       ; Destino del load = 16384
   LD DE, 6912        ; Tamaño a cargar = 6912
   CALL 1366          ; Llamamos a la rutina de carga
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Este segundo programa cargaría un bloque de código ejecutable en memoria, y saltaría a él
                                (un programa "cargador"):</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
   SCF               ; Set Carry Flag (LOAD)
   LD A, 255        ; A = 0xFF (cargar datos)
   LD IX, 32768      ; Destino de la carga
   LD DE, 12000      ; Nuestro "programa" ocupa 12000 bytes.
   CALL 0556        ; Recordemos que 0556h = 1366d
   JP 32768          ; Saltamos al programa código máquina cargado
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p><b>Rutina de SAVE de la ROM</b></p>


                            <p>La rutina SAVE de la ROM tiene unos parámetros muy similares a la de LOAD, y está alojada
                                en 1218d (04c2h):</p>

                            <table class="flags">
                                <tr>
                                    <th>Registro</th>
                                    <th>Valor</th>
                                </tr>
                                <tr>
                                    <td>IX</td>
                                    <td>Dirección inicio de memoria de los datos que se van a grabar.</td>
                                </tr>
                                <tr>
                                    <td>DE</td>
                                    <td>Longitud del bloque de datos a grabar (se grabarán los datos desde IX a
                                        IX+DE).
                                    </td>
                                </tr>

                                <tr>
                                    <td>A</td>
                                    <td>Flag Byte, 0x00 para grabar cabeceras o 0xFF (255) para grabar datos.</td>
                                </tr>
                                <tr>
                                    <td>CF (CarryFlag)</td>
                                    <td>0 (SAVE)</td>
                                </tr>
                            </table>

                            <p>Lo normal es que no tengamos que recurrir en prácticamente ninguna ocasión a la rutina de
                                grabación de datos, de modo que nos centraremos, mediante ejemplos, en la rutina de
                                carga.</p>


                            <p><b>Cargando o Ignorando la cabecera</b></p>

                            <p>Cuando salvamos datos desde BASIC, lo normal es que se generen 2 bloques de datos, el de
                                la cabecera, y el de los datos en sí mismos. El bloque de datos de la cabecera, cargado
                                en memoria, nos permite saber el tamaño y destino de los datos que vendrán en el
                                siguiente bloque. Es decir, cargando el primer bloque obtenemos la información necesaria
                                para cargar en IX y DE los valores adecuados para la carga del bloque de datos.</p>

                            <p>En ocasiones, podemos ignorar el bloque de cabecera totalmente, sobre todo cuando sabemos
                                qué vamos a cargar desde cinta, qué destino tiene, y qué tamaño tiene, y lo
                                especificamos directamente en nuestro programa ASM. En ese caso, podemos cargar la
                                cabecera con el CARRY FLAG a cero (verify), con lo cual la leemos pero no la almacenamos
                                en memoria, y después cargar los valores adecuados en IX, DE, A, etc, poner el CF a 1, y
                                cargar los datos que vienen tras la cabecera.</p>

                            <p>Supongamos que grabamos un bloque de datos, gráficos, una pantalla o música en cinta
                                usando SAVE, rutinas de la ROM, o desde un emulador o herramienta cruzada de PC.
                                Supongamos que sabemos el tamaño exacto en cinta de dichos datos, y no necesitamos leer
                                y analizar la cabecera para cargarlos. En tal caso, podemos ejecutar código como el
                                siguiente:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
  AND A                           ; CF = 0 (verify)
  CALL 1366                       ; Cargamos e ignoramos la cabecera

  SCF                             ; Set Carry Flag -> CF=1 -> LOAD
  LD A, 255                       ; A = 0xFF (cargar datos)
  LD IX, direccion_destino        ; Destino del load
  LD DE, tamaño_a_cargar          ; Tamaño a cargar
  CALL 1366                       ; Llamamos a la rutina de carga
</pre>
                                        </p></td>
                                </tr>

                            </table>


                            <p>Posteriormente veremos un ejemplo que ignora la cabecera al cargar una pantalla SCR
                                completa sobre la videoram.</p>

                            <p>¿Cuándo nos interesa analizar la cabecera? Principalmente cuando los datos están
                                generados desde nuestro propio programa y tienen un tamaño variable. Por ejemplo,
                                supongamos que programamos un editor de textos que da al usuario la oportunidad de
                                salvar y cargar los textos en cinta. En tal caso, necesitaremos leer la cabecera para
                                saber el tamaño del documento (bloque de datos) a cargar, ya que no lo conocemos de
                                antemano.</p>

                            <p>No obstante, en el caso de un juego, normalmente se conoce con antelación el tamaño de
                                los datos a cargar, por lo que se puede ignorar felizmente la cabecera del bloque de
                                cinta.</p>


                            <p><b>Convirtiendo datos en cinta</b></p>

                            <p>Lo primero que necesitamos saber es, ¿cómo convertimos nuestros datos (gráficos, pantalla
                                de carga, números, tablas precalculadas, sprites, música, etc) en datos cargables desde
                                las rutinas que hemos visto? Hay múltiples formas de hacerlo.</p>

                            <p>Para empezar, podemos hacerlo desde el mismo BASIC del Spectrum, usando el comando SAVE:
                                esto nos permitirá grabar datos de memoria en cinta:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
SAVE "nombre" CODE direccion_inicio, tamaño
</pre>
                                        </p></td>
                                </tr>
                            </table>


                            <p>En la mayoría de los casos, muchos de nosotros programamos hoy en sistemas PC usando
                                compiladores cruzados, ensambladores cruzados y emuladores, por lo que normalmente lo
                                que nos interesará es obtener ficheros TAP para poder concatenarlos con nuestros
                                cargadores o programas.</p>

                            <p>Supongamos que estamos programando un juego que, nada más acabar, lo primero que hace es
                                cargar desde cinta los datos del nivel actual (gráficos, mapeado, etc). Esto implica que
                                cuando programemos el juego, tendremos por un lado el código, que nos proporcionará un
                                fichero TAP (por ejemplo) listo para ejecutar. A ese fichero TAP tendremos que
                                concatenarle los datos de los diferentes niveles (o gráficos, o los datos que
                                necesitemos).</p>

                            <p>Así, nuestro "programa.asm" (código fuente) se convierte en "programa.bin" tras el
                                proceso de ensamblado, y finalmente obtenemos un "programa.tap" (o .tzx) listo para
                                cargar en un Spectrum.</p>

                            <p>Pero en dicho TAP o TZX tenemos que añadir (al final del mismo) los datos que el programa
                                espera cargar. Imaginemos que estos datos son una pantalla gráfica (.scr) de 6912 bytes.
                                Tendremos un fichero "pantalla.scr", y tenemos que introducirlo dentro de nuestro
                                fichero TAP, al final, tras el código del programa, para que cuando este sea ejecutado,
                                lo siguiente que cargue desde cinta nuestro programa sea dicha pantalla SCR.</p>

                            <p>Para ello, con el objetivo de hacerlo de una manera muy sencilla, utilizaremos ficheros
                                TAP. El formato de este tipo de ficheros es muy sencillo, simplemente contienen bloques
                                de datos precedidos por 2 bytes que indican el tamaño del bloque. Supongamos que tenemos
                                en un fichero los 2 primeros bytes de la ROM que vimos anteriormente:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>

f3 af
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Este fichero de 2 bytes de tamaño (inicio_rom.bin, por ejemplo), guardado en una cinta
                                tendría el formato que vimos anteriormente: 2 bloques (cabecera y datos).</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1

+

ff f3 af a3
</pre>
                                        </p></td>
                                </tr>

                            </table>

                            <p>Es decir, 2 bloques de cinta de 19 y 4 bytes de datos, que conforman un SAVE de nuestros
                                2 bytes. Pues un fichero TAP con estos datos sería, sencillamente, el escribir estos 2
                                bloques en un fichero anteponiendo a cada bloque el tamaño a cargar:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
13 00 00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1

+

04 00 ff f3 af a3
</pre>
                                        </p></td>
                                </tr>
                            </table>


                            <p>Es decir "13 00" (número 19 en formato WORD, indicando el tamaño del bloque que viene a
                                continuación) seguido de los 19 bytes, y "04 00" (número 4 en formato WORD) seguido de
                                los 4 bytes del bloque.</p>

                            <p>El contenido en binario de nuestro inicio_rom.tap sería, pues:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
13 00 00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1 04 00 ff f3 af a3
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Y el tamaño resultante en bytes del fichero serían 2 + 19 + 2 + 4= 27 bytes.</p>

                            <p>Gracias a este formato tan sencillo, podemos unir ficheros TAP simplemente
                                concatenándolos. De esta forma, si tenemos nuestro "programa.tap" y la "graficos.tap", y
                                queremos unirlos porque nuestro programa, al ejecutarse, carga los gráficos esperándolos
                                en cinta tras el código del mismo, bastaría con hacer:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
Linux:    cat programa.tap graficos.tap > programa_final.tap
Windows:  copy /B programa.tap graficos.tap programa_final.tap
</pre>
                                        </p></td>
                                </tr>
                            </table>


                            <p>Sabemos cómo podemos obtener nuestro programa en formato TAP: cogemos el código fuente,
                                lo compilamos, y o bien obtenemos un TAP directamente (pasmo --tapbas), o bien obtenemos
                                un BIN que convertimos con BIN2TAP. Pero ... ¿cómo convertimos nuestro "graficos.bin",
                                "pantalla_carga.bin", "musica.bin" o cualquier otro fichero de datos en crudo? No
                                podemos usar el BIN2TAP original porque éste añade un cargador BASIC al principio del
                                programa... hay múltiples soluciones, pero la más sencilla es utilizar un ensamblador
                                como <b>pasmo</b>.</p>

                            <p>Para convertir un fichero .bin en un fichero tap sin cabecera, creamos un pequeño
                                programa ASM (rom.asm) como el siguiente:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
INCBIN "rom.bin"
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>A continuación, "ensamblamos" ese programa con PASMO indicando que queremos que nos
                                genere un TAP sin cabecera BASIC:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
pasmo --tap rom.asm rom.tap
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Con esto, obtendremos un fichero "rom.tap" con el contenido de rom.bin, y sin cargador
                                BASIC, listo para utilizar.</p>

                            <p><b>Ejemplo completo</b></p>

                            <p>Finamente, para aquellos programadores que quieran ver un ejemplo de aplicación práctica
                                de la recuperación de datos desde un binario en ejecución, vamos a juntar todo lo visto
                                para realizar un programa que cargue una pantalla gráfica completa (fichero .scr) sobre
                                la videoRAM.</p>

                            <p>Los pasos a seguir para generar el ejemplo son los siguientes:</p>

                            <p>Primero, buscamos un fichero .SCR de carga (por ejemplo, la pantalla de carga de
                                cualquier juego obtenida desde WOS InfoSeek) y lo almacenamos en disco.</p>

                            <p>Segundo, mediante pasmo obtenemos un TAP con los datos del fichero SCR, sin cabecera
                                BASIC. Dicho TAP tendrá un tamaño como el siguiente:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
[sromero@compiler]$ ls -l zxcolumns.*
-rw-r--r-- 1 sromero sromero 6912 2007-10-08 13:01 zxcolumns.scr
-rw-r--r-- 1 sromero sromero 6937 2007-10-08 13:02 zxcolumns.tap
</pre>
                                        </p></td>
                                </tr>

                            </table>


                            <p>Ahora ya tenemos una pantalla SCR guardada en formato TAP (en cinta). Nótese cómo
                                podríamos cargar este TAP desde BASIC con un <em>LOAD "" CODE 16384,6912</em>, y
                                aparecería la imagen en pantalla.</p>

                            <p>Lo siguiente que necesitamos es el programa propiamente dicho, el cual hará la carga de
                                la pantalla en videomemoria:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
;----------------------------------------------------------------------
; Loadscr.asm : Demostración de las rutinas LOAD de la ROM, con
; la carga de un fichero SCR (desde cinta) en videomemoria.
;----------------------------------------------------------------------

  ORG 32000

  AND A                           ; CF = 0 (verify)
  CALL 1366                       ; Cargamos e ignoramos la cabecera

  SCF                             ; Set Carry Flag -> CF=1 -> LOAD
  LD A, 255                       ; A = 0xFF (cargar datos)
  LD IX, 16384                    ; Destino del load = 16384
  LD DE, 6912                     ; Tamaño a cargar = 6912
  CALL 1366                       ; Llamamos a la rutina de carga

  RET

END 32000
</pre>

                                        </p></td>
                                </tr>
                            </table>

                            <p>Al respecto del código fuente, como habréis notado, realizamos 2 llamadas a la rutina de
                                la ROM. La primera carga (pero no almacena en ningún sitio) el primer bloque de datos
                                existente (la cabecera de la pantalla de carga). La rutina de la ROM ignorará esta carga
                                porque el CARRY FLAG está a cero (0=VERIFY). La segunda llamada a 1366 realizará la
                                carga de los datos propiamente dichos. Al cargarlos sobre la dirección de destino 16384
                                (la dirección de la videoram), veremos cómo se van cargando sobre la pantalla
                                directamente desde la cinta.</p>

                            <p>Ensamblamos nuestro programa con "pasmo --tapbas loadscr.asm loadscr.tap" y tendremos lo
                                siguiente:</p>

                            <ul>
                                <li>Un TAP (loadscr.tap) con nuestro programa (pero que no tiene datos después de él).
                                </li>
                                <li>Un TAP (zxcolumns.tap) con los datos gráficos (en este caso, una pantalla completa
                                    de 6912 bytes).
                                </li>
                            </ul>

                            <p>Si cargamos en el Spectrum, o en un emulador, el fichero loadscr.tap, nos encontraríamos
                                con que intenta cargar los datos desde cinta, pero no hay datos almacenados tras el
                                programa. Para solucionarlo, concatenamos los 2 TAPs (con cat en Linux o copy en
                                Windows/DOS):</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
[sromero@compiler]$ cat loadscr.tap zxcolumns.tap > programa.tap
</pre>
                                        </p></td>
                                </tr>
                            </table>

                            <p>Ahora sí, cargando "programa.tap" en el emulador, cargaremos nuestro programa, el cual
                                llama a la rutina de la ROM para cargar los datos que van después del programa (la
                                pantalla de carga) en videomemoria. Si lo probáis en un emulador, recordad deshabilitar
                                las opciones de carga rápida o carga instantánea si queréis ver el efecto de la
                                carga.</p>


                            <table border="0" cellspacing="0" cellpadding="2" width="320">
                                <tr align="right">
                                    <td><img src="img/loadscreen.png" width="320" height="240"
                                             alt="Nuestro programa cargando el fichero SCR."/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Nuestro programa cargando el fichero SCR.</td>
                                </tr>
                            </table>


                            <p>Si os fijáis durante la carga, veréis como primero se carga el LOADER, luego el código
                                máquina de nuestro programa, y después la pantalla. Contando los tonos guía de carga
                                también encontraréis el lugar donde se lee, pero ignora, la cabecera (19 bytes, carga
                                muy corta) de la pantalla SCR.</p>

                            <p>Un apunte: tanto en el caso de la carga, como de la grabación de datos, recordad que las
                                rutinas de la ROM no indican al usuario que debe pulsar PLAY o REC, por lo que debemos
                                indicar al usuario cuándo debe pulsar PLAY o REC dentro de nuestros programas o juegos.
                                Incluso, cuando acabemos de cargar los datos relativos a nuestro juego, resulta
                                conveniente indicarle al usuario cuándo debe detener la cinta (especialmente en juegos
                                multicarga) e insertar los segundos de "espacio" que creamos convenientes entre
                                bloques.</p>

                            <p>Recordad que en este ejemplo hemos cargado 6912 bytes de un fichero SCR directamente
                                sobre la videoRAM, pero nada nos impide cargar ficheros de cualquier otro tamaño, con
                                cualquier otro contenido (sprites, fondos, datos, mapeados) sobre cualquier lugar de la
                                memoria (asegurándonos primero que no hay nada en el lugar destino de la carga, como
                                código, la pila, u otros datos o variables). </p>

                            <p>Así pues, de la misma forma que hemos cargado una pantalla SCR, podemos organizar los
                                gráficos y mapeados de nuestro juego en 1 "bloque de datos" por nivel, cargar los datos
                                del nivel 1 tras acabar la carga de nuestro programa, y sobreescribir estos gráficos y
                                mapeados "en memoria" con los de los diferentes niveles según vaya avanzando el jugador.
                                En otras palabras, podemos hacer un juego multicarga que nos permita tener más sprites,
                                pantallas o gráficos disponibles para cada nivel, que los que tendríamos disponibles si
                                cargamos todos los datos de todos los niveles del juego, ya que usamos toda la memoria
                                para cada nivel, en lugar de dividirla en espacio para los diferentes niveles. A cambio,
                                el usuario tendrá que cargar desde cinta las diferentes fases conforme avanza, y
                                rebobinar para cargar los datos del "Nivel 1" cuando deba empezar una nueva partida.</p>


                            <p><b>Ficheros</b></p>

                            <ul>
                                <li><a href="src/09_loadscr.asm" onclick="window.open(this.href); return false;">Ejemplo
                                    de load de SCR sobre la VRAM</a>.
                                </li>
                                <li><a href="src/09_loadscr.tap" onclick="window.open(this.href); return false;">TAP del
                                    ejemplo anterior</a>.
                                </li>
                                <li><a href="src/bin2tap.c" onclick="window.open(this.href); return false;">Conversor de
                                    datos a fichero TAP</a>.
                                </li>
                                <li><a href="src/bin2tap_nl.c" onclick="window.open(this.href); return false;">Bin2tap
                                    que no genera cargador BASIC</a>.
                                </li>

                            </ul>


                            <p><b>Enlaces</b></p>

                            <ul>
                                <li><a href="http://www.worldofspectrum.org/faq/reference/48kreference.htm"
                                       onclick="window.open(this.href); return false;">FAQ 48K de WOS</a>.
                                </li>
                                <li>
                                    <a href="http://www.worldofspectrum.org/faq/reference/48kreference.htm#TapeDataStructure"
                                       onclick="window.open(this.href); return false;">Tape Data Structure</a>.
                                </li>
                                <li><a href="http://www.worldofspectrum.org/tapsamp.html"
                                       onclick="window.open(this.href); return false;">Cintas y TAPER</a>.
                                </li>

                                <li><a href="http://www.worldofspectrum.org/ldbytes.html"
                                       onclick="window.open(this.href); return false;">Rutina de carga/grabación de la
                                    ROM, desemsamblada y comentada</a>.
                                </li>
                                <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt24.html"
                                       onclick="window.open(this.href); return false;">Manual del +3</a>.
                                </li>
                                <li><a href="http://www.z80.info/" onclick="window.open(this.href); return false;">Web
                                    del Z80</a>.
                                </li>
                                <li><a href="http://www.worldofspectrum.org/faq/reference/z80reference.htm"
                                       onclick="window.open(this.href); return false;">Z80 Reference de WOS</a>.
                                </li>
                                <li><a href="http://www.arrakis.es/~ninsesabe/pasmo/"
                                       onclick="window.open(this.href); return false;">PASMO</a>.
                                </li>

                                <li><a href="http://www.speccy.org/metalbrain/BIN2CODE.EXE"
                                       onclick="window.open(this.href); return false;">BIN2CODE (Web de Metalbrain)</a>.
                                </li>

                        </div>
                    </td>
                </tr>
                <tr>
                    <td align="right"><br><br>Santiago Romero</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td> </td>
    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarPie(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>

                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('analisis.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="la-historia-del-spectrum.html">La historia del Spectrum</option>

                                <option value="el-aventurero.html">El Aventurero</option>
                                <option value="analisis.html">Análisis</option>
                                <option value="computone.html" selected>Computone</option>
                                <option value="al-descubierto.html">Al Descubierto</option>
                                <option value="basic.html">Programación BASIC</option>
                                <option value="z88dk.html">Programación Z88DK</option>

                                <option value="ensamblador.html">Programación Ensamblador</option>
                                <option value="128k-mode.html">128K MODE</option>
                                <option value="input.html">INPUT</option>
                                <option value="tira-comica.html">Tira cómica</option>
                                <option value="opinion.html">Opinión</option>
                            </select>

                            <input type="button" onclick="RecargarCabecera('al-descubierto.html');" name="siguiente"
                                   value=">"/>
                        </td>
                        <td align="right" class="texto">
                            <a href="#arriba">Volver arriba</a>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>
                </form>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
                <tr align="center" valign="center">
                    <td>2003-2009 Magazine ZX</td>
                </tr>
            </table>
        </td>
    </tr>
</table>
</body>
</html>
