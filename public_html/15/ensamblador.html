<!doctype html>
<html lang="es">
    <head>
        <title>Magazine ZX</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

        <link rel="stylesheet" href="../css/magazine.css" type="text/css">
    </head>
    <body><!-- Google Tag Manager --> <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-W5DD5R" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-W5DD5R');</script> <!-- End Google Tag Manager -->


            <table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
                <tr>
                    <td>
<a name="arriba"></a>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
	<tr align="center" valign="center">
		<td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0" /></a></td>
	</tr>
</table>
                    </td>

                </tr>
                <tr>
                    <td>
<script language="JavaScript">
function RecargarCabecera(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">
        <tr><td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>

        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('rem.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
        <option value="index.html">Portada</option>
        <option value="editorial.html">Índice - Editorial</option>
        <option value="panorama.html">Panorama</option>
        <option value="analisis.html">Análisis</option>

        <option value="hardware.html">Hardware</option>
        <option value="rem.html">REM</option>
        <option value="ensamblador.html" selected>Programación Ensamblador</option>
    </select>
    <input type="button" onclick="return false;" name="siguiente" value=">" disabled  />
</td>
            <td align="center" class="texto">Número 15 - Marzo 2007</td>

            <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX" onClick="window.open(this.href); return false;"><img src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0" alt="ZX Certified webmaster"></a>&nbsp;<a href="http://www.speccy.org/" onClick="window.open(this.href); return false;"><img src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a></td>
        </tr>
    </form>
</table>
</a>
                    </td>
                </tr>
                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td>

<table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
    <tr>
        <td>
<div align="justify">
<p align="center"><font size="5">Lenguaje Ensamblador del Z80 (II)</font></p>
<p><strong>DESPLAZAMIENTO DE MEMORIA, MANIPULACIÓN DE BITS Y OPERACIONES LÓGICAS</strong></p>
<p>En nuestra anterior entrega comenzamos nuestra andadura en el lenguaje ensamblador del Z80 por medio de las instrucciones de carga (LD), operaciones aritméticas (ADD, ADC, SUB, SBC, INC, DEC) y de intercambio (EXX y EX). Mientras se introducían las diferentes instrucciones, os mostramos la manera de emplear los registros y cómo los resultados podían afectar a los flags del registro F, mediante las "tablas de afectación de flags".</p>
<p>Toda la teoría explicada en el anterior capítulo del curso nos permitirá avanzar ahora mucho más rápido, ya que con todos los conceptos asimilados podemos ir realizando una rápida introducción a nuevas instrucciones, bastando ahora con una simple descripción de cada una de ellas. Las tablas de afectación de flags y comentarios sobre los operandos permitidos (o prohibidos) para cada una de ellas completarán la formación necesaria.</p>
<p>Para poder continuar con éste y posteriores capítulos del curso será imprescindible haber comprendido y asimilado todos los conocimientos de las entregas anteriores, de modo que si no es así, recomendamos al lector que relea las entregas 1, 2 y 3, y que se asegure de comprender todos los conceptos explicados.</p>
<p>En esta entrega trataremos las operaciones con bits (NEG, CPL, BIT, SET y RES), las operaciones lógicas (AND, OR y XOR) y las operaciones de desplazamiento de bits (RR, RL, RLC, RRC, SLA, SRA y SRL).</p>

<p>No obstante, antes de pasar a hablar de las operaciones con bits finalizaremos con la descripción de las instrucciones de carga (en este caso las repetitivas), y veremos 4 instrucciones muy sencillas: SCF, CCF, NOP y DAA.</p>
<p><strong>INSTRUCCIONES DE DESPLAZAMIENTO DE MEMORIA</strong></p>
<p>En la entrega anterior conocimos la existencia de las instrucciones de carga (LD), que nos permitían mover valores entre registros. Lo que vamos a ver a continuación es cómo podemos copiar un byte de una posición de memoria a otra, con una sóla instrucción.</p>
<p>Las 2 instrucciones que vamos a describir: LDI y LDD, no admiten parámetros. Lo que hacen estas instrucciones es:</p>
<p>LDI (Load And Increment):</p>
<ul>
	<li>Leer el byte de la posición de memoria apuntada por el registro HL.</li>
	<li>Escribir ese byte en la posición de memoria apuntada por el registro DE.</li>

	<li>Incrementar DE en una unidad (DE=DE+1).</li>
	<li>Incrementar HL en una unidad (HL=HL+1).</li>
	<li>Decrementar BC en una unidad (BC=BC-1).</li>
</ul>
<p>LDD (Load And Decrement):</p>
<ul>
	<li>Leer el byte de la posición de memoria apuntada por el registro HL.</li>
	<li>Escribir ese byte en la posición de memoria apuntada por el registro DE.</li>

	<li>Decrementar DE en una unidad (DE=DE-1).</li>
	<li>Decrementar HL en una unidad (HL=HL-1).</li>
	<li>Decrementar BC en una unidad (BC=BC-1).</li>
</ul>
<p>En pseudocódigo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
LDI:    Copiar [HL] en [DE]
        DE=DE+1
        HL=HL+1
        BC=BC-1

LDD:    Copiar [HL] en [DE]
        DE=DE-1
        HL=HL-1
        BC=BC-1

</pre>
    </p></td></tr>
</table>
<p>Estas instrucciones lo que nos permiten es copiar datos de una zona de la memoria a otra. Por ejemplo, supongamos que queremos copiar el byte contenido en 16384 a la posición de memoria 40000:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD HL, 16384
 LD DE, 40000
 LDI
</pre>
    </p></td></tr>
</table>
 <p>Qué tiene de especial LDI con respecto a realizar la copia a mano con operaciones LD? Pues que al incrementar HL y DE, lo que hace es apuntar a los siguientes elementos en memoria (HL=16385 y DE=40001), con lo cual nos facilita la posibilidad de copiar múltiples datos (no sólo 1), con varios LDI. Lo mismo ocurre con LDD, que al decrementar DE y HL los hace apuntar a los bytes anteriores de origen y destino.</p>

 <p>Pero para facilitarnos más aún la tarea de copia (y no tener que realizar bucles manualmente), el Z80 nos proporciona las instrucciones LDIR y LDDR, que funcionan igual que LDI y LDD pero copiando tantos bytes como valga el registro BC. Es decir:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
LDIR = Repetir LDI hasta que BC valga 0
     = Repetir:
          Copiar [HL] en [DE]
          DE=DE+1
          HL=HL+1
          BC=BC-1
       Hasta que BC = 0

LDDR = Repetir LDD hasta que BC valga 0
     = Repetir:
          Copiar [HL] en [DE]
          DE=DE-1
          HL=HL-1
          BC=BC-1
       Hasta que BC = 0
</pre>
    </p></td></tr>
</table>
<p>Estas instrucciones son enormemente útiles porque nos permiten copiar bloques de datos desde una zona de la memoria a otra. Por ejemplo, podemos hacernos una copia del estado de la pantalla en una zona de memoria mediante:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
  LD HL, 16384
  LD DE, 50000
  LD BC, 6912
  LDIR
</pre>
    </p></td></tr>
</table>
<p>Con el anterior programa, copiamos los 6912 bytes que hay a partir de la dirección de memoria 16384 (la pantalla) y los copiamos a partir de la dirección 50000. De este modo, desde 50000 a 56912 tendremos una copia del estado de la pantalla (podría servir, por ejemplo, para modificar cosas en esta "pantalla virtual" y después copiarla de nuevo a la videoram, tomando HL=50000 y DE=16384).</p>
<p>Para demostrar esto, ensamblemos y ejecutemos el siguiente ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 ; Ejemplo de LDIR donde copiamos 6144 bytes de la ROM
 ; a la videomemoria. Digamos que "veremos la ROM" :)
 ORG 40000

  LD HL, 0         ; Origen: la ROM
  LD DE, 16384     ; Destino: la VideoRAM
  LD BC, 6144      ; toda la pantalla
  LDIR             ; copiar

 RET

</pre>
    </p></td></tr>
</table>

<table border="0" cellspacing="0" cellpadding="2" width="317">
	<tr align="right">
		<td><img src="img/la_rom.gif" width="317" height="238"  alt="Aspecto de la rom al copiarla a la VRAM" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Aspecto de la rom al copiarla a la VRAM</td>

	</tr>
</table>

<p>Os animo a que probéis el equivalente BASIC del ejemplo anterior y verifiquéis las diferencias de velocidad existentes:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
  5 REM Ejecutar "bas2tap -a10 copiarom.bas copiarom.tap"
 10 REM Copiamos la ROM en la VideoRAM
 20 FOR I=0 TO 6144 : POKE (16384+I), (PEEK I) : NEXT I
 30 PAUSE 0
</pre>
    </p></td></tr>
</table>
</p>Concluimos pues que en todas estas instrucciones de copia de memoria o transferencia, HL es el origen, DE el destino y BC el número de bytes a transferir. Con LDI y LDD sólo copiaremos 1 byte (independientemente del valor de BC, aunque lo decrementará), y con LDIR y LDDR copiaremos tantos bytes como valga BC, decrementando BC hasta que su valor llega a cero. Los flags quedarán afectados, especialmente con LDI y LDD para indicarnos mediante el registro P/V si BC ha llegado a cero.</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   LDI               |- - 0 * 0 -|
   LDD               |- - 0 * 0 -|
   LDDR              |- - 0 0 0 -|
   LDIR              |- - 0 0 0 -|
 </pre>
    </p></td></tr>
</table>
<p>Recordemos el significado de los símbolos de la tabla de afectación de flags (válido para todas las tablas de instrucciones que utilizaremos a lo largo del curso):</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 - = El flag NO se ve afectado por la operación.
 * = El flag se ve afectado por la operación acorde al resultado.
 0 = El flag se pone a cero.
 1 = El flag se pone a uno.
 V = El flag se comporta como un flag de Overflow acorde al resultado.
 P = El flag se comporta como un flag de Paridad acorde al resultado.
 ? = El flag toma un valor indeterminado.

</pre>
    </p></td></tr>
</table>
<p>Una duda que puede asaltarle al lector es: "si tenemos LDIR para copiar bloques, ¿para qué nos puede servir LDDR? ¿No es una instrucción redundante, que podemos no necesitar nunca gracias a LDIR? Pues como bien nos apunta Miguel (devil_net) LDDR es especialmente útil cuando hay que hacer copias de bloques de datos que se superponen.</p>
<p>Supongamos que tenemos que realizar una copia de 1000 bytes desde 25000 hasta 25100. Supongamos que preparamos el siguiente código:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD HL, 25000
 LD DE, 25100
 LD BC, 1000
 LDIR
 </pre>
    </p></td></tr>

</table>
<p>Este código no funcionará como esperamos. Ambas zonas se superponen, con lo cual si lo ejecutamos, ocurrirá lo siguiente:</p>
<ul>
	<li>El byte en [25000] se copiará a [25100].</li>
	<li>El byte en [25001] se copiará a [25101].</li>
	<li>etc...</li>
</ul>
<p>¿Qué ocurrirá cuando LDIR llegue al byte número 25100 y lo intente copiar a 25200? Sencillamente, que hemos perdido el contenido REAL del byte número 25100, porque fue machacado al principio de la ejecución del LDIR por el byte contenido en [25000]. No estamos moviendo el bloque correctamente, porque las zonas se superponen y cuando llegamos a la zona destino, estamos copiando bytes que movimos desde el origen.</p>
<p>Para ello, lo correcto sería utilizar el siguiente código:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD HL, 26000
 LD DE, 26100
 LD BC, 1000
 LDDR
</pre>
    </p></td></tr>
</table>
<p>Es decir, apuntamos HL y DE al final de los 2 bloques de copia, y copiamos los bloques desde abajo, decrementando. De este modo nunca "machacamos" una posición de memoria que vayamos a copiar posteriormente con un dato.</p>
<p>En este ejemplo:</p>
<ul>
	<li>El byte en [26000] se copia en [26100].</li>

	<li>El byte en [25999] se copia en [26099].</li>
	<li>El byte en [25998] se copia en [26098].</li>
	<li>(...)</li>
	<li>El byte en [25001] se copia en [25101].</li>
	<li>El byte en [25000] se copia en [25100].</li>
</ul>
<p>Que es, efectivamente, lo que queríamos hacer, pero sin perder datos en la copia: copiar 1000 bytes desde 25000 a 25100 (sólo que realizamos la copia de abajo a arriba).</p>

<p><strong>UN EJEMPLO DE RUTINA CON LDIR</strong></p>
<p>Vamos a ver un ejemplo de rutina en ensamblador que utiliza LDIR con un propósito concreto: vamos a cargar una pantalla de carga (por ejemplo, para nuestros juegos) de forma que no aparezca poco a poco como lo haría con LOAD "" SCREEN$, sino que aparezca de golpe.</p>
<p>Para eso lo que haremos será lo siguiente:</p>
<p>Crearemos una rutina en ensamblador que copiará 6912 bytes desde la dirección 50000 hasta la posición 16384 (la videoram). La rutina ya la hemos visto:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 ORG 40000
  LD HL, 50000     ; Origen: 50000
  LD DE, 16384     ; Destino: la VideoRAM
  LD BC, 6912      ; toda la pantalla
  LDIR             ; copiar
 RET
</pre>
    </p></td></tr>

</table>
<p>La ensamblamos con pasmo y obtenemos el siguiente código máquina:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 33, 80, 195, 017, 0, 64, 1, 0, 27, 237, 176, 201
</pre>
    </p></td></tr>
</table>
<p>Nos crearemos un cargador BASIC que realice el trabajo de pokear nuestra rutina en 40000 y cargar la pantalla en 50000:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
10 REM Ejemplo de volcado de pantalla de carga
20 CLEAR 39999
30 DATA 33, 80, 195, 017, 0, 64, 1, 0, 27, 237, 176, 201
40 FOR I=0 TO 11 : READ OPCODE : POKE 40000+I, OPCODE : NEXT I
50 LOAD "" CODE 50000, 6912
60 RANDOMIZE USR 40000
70 PAUSE 0
</pre>
    </p></td></tr>
</table>
<p>Grabamos este cargador en cinta (o tap/tzx), y a continuación, tras el cargador, grabamos una pantalla de carga.</p>
<p>Ejecutamos el programa resultante en emulador o Spectrum, y veremos cómo la carga de la pantalla no puede verse en el monitor. Cuando está termina su carga, la rutina ensamblador se ejecuta y se vuelca, de golpe, a la videoram (estad atentos a la carga, porque el volcado es muy rápido).</p>

<table border="0" cellspacing="0" cellpadding="2" width="318">
	<tr align="right">
		<td><img src="img/carga.gif" width="318" height="239"  alt="La pantalla de carga de ZXColumns, volcada a videoram" />
</td>

	</tr>
	<tr>
		<td class="piefoto" align="right">La pantalla de carga de ZXColumns, volcada a videoram</td>
	</tr>
</table>

<p><strong>ALGUNAS INSTRUCCIONES ESPECIALES</strong></p>
<p>Antes de comenzar con las instrucciones de manipulación de registros y datos a nivel de bits vamos a ver una serie de instrucciones difíciles de encuadrar en futuros apartados y que pueden sernos de utilidad en nuestros programas:</p>
<ul>
	<li><p>SCF: Set Carry Flag</p>

		<p>Esta instrucción (que no admite parámetros) pone a 1 el Carry Flag del registro F. Puede sernos útil en determinadas operaciones aritméticas.</p></li>
	<li><p>CCF: Complement Carry Flag</p>
		<p>Esta instrucción (que tampoco admite parámetros) invierte el estado del bit de Carry Flag: si está a 1 lo pone a 0, y viceversa. Puede servirnos para poner a 0 el carry flag mediante la combinación de SCF + CCF.</p></li>
	<li><p>NOP: No OPeration</p>
		<p>Esta instrucción especial del microprocesador ocupa un byte en el código (opcode 00h) y no efectúa ninguna operación ni afecta a ningún flag. Eso sí, se toma 4 t-states (t-estados, o ciclos del procesador) para ejecutarse. ¿Para qué puede servir una instrucción que no realiza ninguna acción y que requiere tiempo del procesador (aunque sea muy poco) para ejecutarse? Muy sencillo: para múltiples cosas. Por un lado, podemos utilizarla en bucles de retardos (varios NOPs ejecutados en un bucle que se repita varias veces) para poner retardos en nuestros programas o juegos. Por otro, como ocupa un byte en memoria (en el código) y no realiza ninguna operación, podemos utilizarla para rellenar zonas de nuestro código, y así alinear código posterior en una determinada dirección que nos interese.</p></li>
	<li><p>DAA: Decimal Adjust Accumulator</p>

		<p> Esta instrucción permite realizar ajustes en los resultados de operaciones con números BCD (tras operaciones aritméticas). ¿Qué son los números en formato BCD? Es una manera de representar números en los registros (o memoria) de forma que de los 8 bits de un byte se utilizan los 4 bits del 0 al 3 para representar un número del 0 al 9 (4 bits = desde 0000 hasta 1111), y los 4 bits del bit 4 al 7 para representar otro número del 0 al 9. A los 2 números BCD juntos se les llama "Byte BCD" o "números en formato BCD". Un número BCD puede estar formado por varios bytes BCD, siendo cada byte 2 cifras del mismo. Así, para representar un número de 10 cifras en BCD sólo es necesario utilizar 5 bytes. Además, podemos utilizar un byte extra que indique la posición de la "coma decimal" para así poder trabajar con números decimales en ensamblador. Si queremos realizar operaciones entre este tipo de números deberemos programarnos nosotros mismos las rutinas para realizarlas.</p></li>
</ul>
<p>A lo largo del curso no utilizaremos números en BCD y por lo tanto es muy probable que no lleguemos a utilizar DAA, pero conviene saber que el Z80 nos brinda la oportunidad de utilizar números más grandes de 16 bits, operando con números en BCD. Para realizar juegos normalmente no necesitaremos de estas instrucciones.</p>
<p>Todas estas instrucciones afectan a los flags de la siguiente manera:</p>
 <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   SCF               |- - 0 - 0 1|
   CCF               |- - ? - 0 *|
   NOP               |- - - - - -|
   DAA               |* * * P - *|
</pre>

    </p></td></tr>
</table>
<p><strong>OPERACIONES CON BITS</strong></p>
<p>El conjunto de instrucciones que vamos a ver hoy está pensado para trabajar con los bits individuales de un registro: invertir los bits de un registro, obtener el complemento a dos de un registro y poner a 0 o a 1, o comprobar, un determinado bit de un registro.</p>
<p><em>CPL Y NEG</em></p>
<p>CPL es una instrucción que se usa para obtener el inverso del registro A. No admite parámetros (el operando destino es el registro A) y cuando la ejecutamos, se invierte el estado de cada uno de los bits de A, de forma que los unos pasan a valer cero, y los ceros, uno.</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD A, %10000001
 CPL                 ; A = %01111110

</pre>
    </p></td></tr>
</table>
<p>La tabla de afectación de flags de CPL es:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   CPL               |- - 1 - 1 -|
</pre>
    </p></td></tr>
</table>
<p>Es decir, se deja a uno el flag de Resta (N) y el de HalfCarry (H). El resto de flags no se ven afectados.</p>

<p>Existe una instrucción similar a CPL, pero que además de realizar la inversión de unos y ceros suma 00000001 al resultado de la inversión del registro A. El resultado es que en A obtenemos el valor negativo del número en complemento a dos almacenado en este registro (A = -A).</p>
<p>Por ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD A, 1     ; A = +1
 NEG         ; A = -1 = %11111111
</pre>
    </p></td></tr>
</table>
<p>La tabla de afectación de flags de NEG es:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr><td><p class="codigo">
<pre>
                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   NEG               |* * * V 1 *|
</pre>
    </p></td></tr>
</table>
<p><em>SET, RES Y BIT</em></p>
<p>Las siguientes instrucciones que vamos a ver nos permitirán el manejo de cualquiera de los bits de un registro o posición de memoria: activar un bit (ponerlo a uno), desactivar un bit (ponerlo a cero), o comprobar su valor (averiguar si es cero o uno) afectando a los flags.</p>
<p>Comencemos con "SET". Esta instrucción activa (pone a valor 1) uno de los bits de un registro o dirección de memoria. El formato de la instrucción es:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
 SET bit, DESTINO
</pre>
    </p></td></tr>
</table>
<p>donde Bit es un número entre 0 (el bit menos significativo o bit 0) y 7 (el de más valor o más significativo), y destino puede ser cualquier registro de 8 bits (A, B, C, D, E, H y L), una dirección de memoria apuntada por HL (es decir, el destino puede ser [HL]), o una dirección de memoria indexada por [IX+N] o [IY+N]. Con esto, las siguientes instrucciones serían válidas:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 SET 5, A         ; Activar el bit 5 del registro A
 SET 0, H         ; Activar el bit 0 del registro H
 SET 7, [HL]      ; Activar el bit 7 del dato contenido en
                  ; la dirección de memoria apuntada por HL
 SET 1, [IX+10]   ; Activar el bit 1 del dato en [IX+10]
</pre>
    </p></td></tr>

</table>
<p>La instrucción contraria a SET es RES (de reset), que pone a cero uno de los bits del destino especificado. Su formato es igual que el de SET, como podemos ver en los siguientes ejemplos:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 RES bit, DESTINO

 RES 0, H         ; Desactivar el bit 0 del registro H
 RES 7, [HL]      ; Desactivar el bit 7 del dato contenido en
                  ; la dirección de memoria apuntada por HL
 RES 1, [IX-5]    ; Desactivar el bit 0 del dato en [IX-5]
</pre>
    </p></td></tr>
</table>
<p>SET y RES no afectan a los flags, como podemos ver en su tabla de afectación de indicadores:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
  SET b, s          |- - - - - -|
  RES b, s          |- - - - - -|
</pre>
    </p></td></tr>
</table>
<p>La última instrucción de manipulación de bits individuales que veremos en este apartado es BIT. Esta instrucción modifica el flag de cero (Z) y deja su valor en 0 ó 1 dependiendo del valor del bit que estamos probando. Si estamos probando, por ejemplo, el bit 5 del registro A, ocurrirá lo siguiente:</p>
<ul>
	<li>Si el bit 5 del registro A es cero: el Flag Z se pone a 1.</li>
	<li>Si el bit 5 del registro A es uno: el flag Z se pone a 0.</li>
</ul>

<p>En otras palabras, Z toma la inversa del valor del Bit que comprobamos: esto es así porque Z no es una COPIA del bit que estamos testeando, sino el resultado de evaluar si dicho bit es cero o no, y una evaluación así pone a uno el flag Z sólo cuando lo que se evalúa es cero.</p>
<p>Su formato es:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 BIT bit, DESTINO
</pre>
    </p></td></tr>
</table>
<p>El destino puede ser el mismo que en SET y RES: un registro, posición de memoria apuntado por HL o posición de memoria apuntada por un registro índice más un desplazamiento.</p>
<p>Por ejemplo:</p>

<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD A, 8       ; A = %00001000
 BIT 7, A      ; El flag Z vale 1
               ; porque el bit 7 es 0
 BIT 3, A      ; El flag Z vale 0
               ; porque el bit 3 no es 0
               ; (es 1).
</pre>
    </p></td></tr>
</table>
<p>El lector se preguntará ... ¿cuál es la utilidad de BIT? Bien, el hecho de que BIT modifique el Zero Flag de acuerdo al bit que queremos comprobar nos permitirá utilizar instrucciones condicionales para realizar muchas tareas. Por ejemplo, podemos comprobar el bit 0 de un registro (algo que nos permitiría saber si es par o impar) y en caso de que se active el flag de Zero (Si z=1, el bit 0 vale 0, luego es par), realizar un salto a una determinada línea de programa.</p>
<p>Por ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>

 BIT 0, A      ; Que valor tiene el bit 0?
               ; Ahora Z = bit 0 de A.
 JP Z es_par   ; Saltar si esta Z activado
               ; (si Z=1 -&gt; salta a es_par)
               ; ya que si Z=1, es porque e
</pre>
    </p></td></tr>
</table>
<p>Esta instrucción es, como veremos en muchas ocasiones, muy útil, y como ya hemos dicho sí que altera el registro F:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
  BIT b, s          |? * 1 ? 0 -|

</pre>
    </p></td></tr>
</table>
<p><em>ROTACION DE BITS</em></p>
<p>El siguiente set de instrucciones que veremos nos permitirá ROTAR (ROTATE) los bits de un dato de 8 bits (por ejemplo, almacenado en un registro o en memoria) hacia la izquierda o hacia la derecha.</p>
<p>Para realizar esta tarea tenemos disponibles 2 instrucciones básicas: RLC y RRC. La primera de ellas, RLC, rota el registro o dato en un bit a la izquierda (RLC = Rotate Left Circular), y la segunda lo hace a la derecha.</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Bit      7 6 5 4 3 2 1 0                 7 6 5 4 3 2 1 0
         ----------------- -&gt; RLC -&gt;     -----------------
 Valor    a b c d e f g h                 b c d e f g h a


 Bit      7 6 5 4 3 2 1 0                 7 6 5 4 3 2 1 0
         ----------------- -&gt; RRC -&gt;     -----------------
 Valor    a b c d e f g h                 h a b c d e f g

</pre>
    </p></td></tr>
</table>
<p>Así, RLC de 00000001 daría como resultado 00000010. Como la rotación es circular, todos los bits se mueven una posición a la izquierda y el bit 7 se copia en el bit 0. Asímismo, RRC de 00000001 daría como resultado 10000000, ya que el bit 0 al rotarse a la derecha (como todos los demás bits) se copia donde estaba el bit 7. Cabe destacar que el Carry Flag se vé afectado, ya que el bit 7 en RLC y el 0 en RRC también se copiará allí.</p>

<table border="0" cellspacing="0" cellpadding="2" width="500">
	<tr align="right">
		<td><img src="img/rlc_rrc.gif" width="500" height="400"  alt="RLC y RRC" />
</td>
	</tr>
	<tr>

		<td class="piefoto" align="right">RLC y RRC</td>
	</tr>
</table>

<p>Por ejemplo, supongamos el valor 10000001 almacenado en el registro B:</p>
<p>El resultado las 2 operaciones descritas sería:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD B, %10000001   ; B = 10000001
 RLC B             ; B = 00000011

 LD B, %10000001   ; B = 10000001
 RRC B             ; B = 00000011

</pre>
    </p></td></tr>
</table>
<p>No sólo podemos rotar registros: en general el destino de la rotación podrá ser un registro, el contenido de la dirección de memoria apuntada por [HL], o bien el contenido de la memoria apuntada por un registro índice más desplazamiento ([IX+N] o [IY+N]). Más adelante veremos la tabla de afectación de flags de esta y otras instrucciones que veremos a continuación.</p>
<p>Además de RLC y RRC (rotación circular), tenemos disponibles 2 instrucciones más que nos permiten apoyarnos en el Carry Flag del registro F como si fuera un bit más de nuestro registro, comportándose como el noveno bit (de más valor) del registro: hablamos de las instrucciones RL y RC:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Bit     C   7 6 5 4 3 2 1 0               C   7 6 5 4 3 2 1 0
        ---------------------- -&gt;  RL  -&gt;  ---------------------
 Valor   X   a b c d e f g h               a   b c d e f g h X


 Bit     C   7 6 5 4 3 2 1 0               C   7 6 5 4 3 2 1 0
        ---------------------- -&gt;  RR  -&gt;  ---------------------
 Valor   X   a b c d e f g h               h   X a b c d e f g

</pre>
    </p></td></tr>
</table>
<p>El CarryFlag hace de bit extra: por un lado se copia al Bit 0 o al Bit 7 según estemos rotando a izquierda o a derecha, y por otra parte recibe el valor del bit 7 del bit 0 (respectivamente para RL y RR).</p>

<table border="0" cellspacing="0" cellpadding="2" width="500">
	<tr align="right">
		<td><img src="img/rl_rr.gif" width="500" height="400"  alt="RL y RR" />
</td>
	</tr>
	<tr>

		<td class="piefoto" align="right">RL y RR</td>
	</tr>
</table>

<p>Por ejemplo, supongamos el valor 10000001 almacenado en el registro B y que el carry flag estuviera a uno:</p>
<p>El resultado las 2 operaciones descritas sería:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 SCF              ; Set Carry Flag (hace C=1)
 LD B, %00000010  ; B = 00000010
 RL B             ; B = 00000101 y C=0 (del bit 7)

 SCF              ; Set Carry Flag (hace C=1)
 LD B, %01000001  ; B = 01000000
 RR B             ; B = 10100000 y C=1 (del bit 0)

</pre>
    </p></td></tr>
</table>
<p>Así pues, RLC y RRC son circulares y no utilizan el Carry Flag, mientras que RR y RL sí que lo utilizan, como un bit extra. Utilizando RR/RL 9 veces o bien RLC/RRC 8 veces sobre un mismo registro obtenemos el valor original antes de comenzar a rotar.</p>
<p>Veamos la tabla de afectación de flags de estas nuevas instrucciones:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                        Flags
  Instrucción       |S Z H P N C|         Significado
 -----------------------------------------------------------------
  RLC s             |* * 0 P 0 *|         Rotate Left Circular
  RRC s             |* * 0 P 0 *|         Rotate Right Circular
  RL s              |* * 0 P 0 *|         Rotate Left (con Carry)
  RR s              |* * 0 P 0 *|         Rotate Right (con Carry)
</pre>
    </p></td></tr>

</table>
<p>El destino "s" puede ser cualquier registro de 8 bits, memoria apuntada por HL o registros índice con desplazamiento. Como veis hay muchos flags afectados, y en esta ocasión el flag P/V ya no nos sirve para indicar desbordamientos sino que su estado nos da la PARIDAD del resultado de la operación de rotación. Con el flag P a uno, tenemos paridad par (even), es decir, el número de bits a uno en el resultado es par. Si está a cero significa que el número de bits a uno en el resultado es impar.</p>
<p>Aunque pueda parecer sorprendente (ya que podemos utilizar las 4 operaciones anteriores con el registro A como operando), existen 4 instrucciones más dedicadas exclusivamente a trabajar con "A": hablamos de RLA, RRA, RLCA y RRCA. La diferencia entre estas 4 instrucciones y su versión con un espacio en medio (RL A, RR A, RLC A y RRC A) radica simplemente en que las nuevas 4 instrucciones (sin espacio) alteran los flags de una forma diferente:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                        Flags
  Instrucción       |S Z H P N C|       Significado
 -----------------------------------------------------------------
  RLA               |- - 0 - 0 *|       Rotate Left Accumulator
  RRA               |- - 0 - 0 *|       Rotate Right Accumulator
  RLCA              |- - 0 - 0 *|       Rotate Left Circular Acc.
  RRCA              |- - 0 - 0 *|       Rotate Right Circular Acc.
</pre>
    </p></td></tr>
</table>
<p>Como veis, están pensadas para alterar MENOS flags que sus homónimas de propósito general (algo que nos puede interesar en alguna ocasión).</p>

<p>Y para acabar con las instrucciones de rotación, tenemos RLD y RRD, que realiza una rotación entre A y el contenido de la memoria apuntada por HL.</p>
<p>Concretamente, RRD lo que hace es:</p>
<ul>
	<li>Leer el dato contenido en la dirección de memoria apuntada por HL.</li>
	<li>Coger los 4 bits más significativos (bit 4-7) de ese valor.</li>
	<li>Rotar A hacia la izquierda 4 veces (copiando los bits 0-3 en las posiciones 4-7).</li>
	<li>Copiar los 4 bits extraídos de la memoria en los 4 bits menos significativos de A.</li>

</ul>
<p>Resumiendo, supongamos los siguientes valores de A y [HL]:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Registro A:   Bit 7 6 5 4 3 2 1 0
               --------------------
                   a b c d e f g h

 [HL]:         Bit 7 6 5 4 3 2 1 0
               --------------------
                   s t u v w x y z
</pre>
    </p></td></tr>
</table>
<p>Resultado de RRD:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
 Registro A:   Bit 7 6 5 4 3 2 1 0
               --------------------
                   e f g h s t u v
</pre>
    </p></td></tr>
</table>
<p>Resultado de RLD:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>

 Registro A:   Bit 7 6 5 4 3 2 1 0
               --------------------
                   s t u v e f g h
</pre>

    </p></td></tr>
</table>
<p>En pseudocódigo C:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>

 RRD:  A = ( A&lt;&lt;4 )    | ([HL]&gt;&gt;4)
 RLD:  A = ( [HL]&lt;&lt;4 ) | (A & 0x0F)
</pre>

    </p></td></tr>
</table>
<p>La afectación de flags sería:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                        Flags
  Instrucción       |S Z H P N C|         Significado
 -----------------------------------------------------------------
  RLD               |* * 0 P 0 -|         Rotate Left 4 bits
  RRD               |* * 0 P 0 -|         Rotate Right 4 bits
</pre>
    </p></td></tr>
</table>
<p>Aunque ahora todo este conjunto de instrucciones pueda parecernos carente de utilidad, lo que hace el microprocesador Z80 es proveernos de toda una serie de pequeñas herramientas (como estas de manipulación, chequeo y rotación de bits) para que con ellas podamos resolver cualquier problema, mediante la combinación de las mismas. Os aseguramos que en más de una rutina tendréis que usar instrucciones de rotación o desplazamiento.</p>

<p><strong>DESPLAZAMIENTO DE BITS</strong></p>
<p>El siguiente set de instrucciones que veremos nos permitirá DESPLAZAR (SHIFT) los bits de un dato de 8 bits (por ejemplo, almacenado en un registro o en memoria) hacia la izquierda o hacia la derecha. Desplazar es parecido a rotar, sólo que el desplazamiento no es circular; es decir, los bits que salen por un lado no entran por otro, sino que entran ceros:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 00010001 ROTADO A LA IZQUIERDA es 00100010
 (movemos todos los bits hacia la izquierda y el bit 0 entra como 0. El bit 7 se copia al Carry)

 10000001 ROTADO A LA DERECHA es 01000000
 (el 0 del bit 7 del resultado entra nuevo, el 1 del bit 0 origen se pierde)
</pre>
    </p></td></tr>
</table>
<p>Las instrucciones de desplazamiento a izquierda y derecha en Z80 se llaman SLA (Shift Left Arithmetic) y SRA (Shift Right Arithmetic), y su formato es:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr><td><p class="codigo">
<pre>
 SRA operando
 SLA operando
</pre>
    </p></td></tr>
</table>
<p>Donde operando puede ser el mismo tipo de operando que en las instrucciones de rotación: un registro de 8 bits, [HL] o [IX/IY+N]. Lo que realizan estas operaciones sobre el dato operando es:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Bit 7 6 5 4 3 2 1 0                C    7 6 5 4 3 2 1 0
    ----------------- -&gt; SLA -&gt;  ------------------------
     a b c d e f g h                a    b c d e f g h 0

</pre>
    </p></td></tr>
</table>
 <p>Literalmente:</p>
 <ul>
 	<li>Rotar los bits a la izquierda (&lt;&lt;).</li>
 	<li>El bit "a" (bit 7) se copia al Carry Flag.</li>
 	<li>Por la derecha entra un cero.</li>

 </ul>
 <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Bit 7 6 5 4 3 2 1 0                C    7 6 5 4 3 2 1 0
    ----------------- -&gt; SRA -&gt;  ------------------------
     a b c d e f g h                h    a a b c d e f g
</pre>
    </p></td></tr>
</table>

<p>Literalmente:</p>
<ul>
	<li>Rotar los bits a la derecha (&gt;&gt;).</li>
	<li>El bit "h" (bit 0) se copia al Carry Flag.</li>
	<li>En la izquierda (bit 7) se mantiene su valor anterior.</li>
</ul>
<p>Nótese pues que SLA y SRA nos permiten trabajar también con números negativos. En el caso de SLA se utiliza el carry flag para almacenar el estado del bit 7 tras la rotación (con lo cual podemos conservar el signo si sabemos dónde buscarlo). En el caso de SRA, porque el bit 7 además de desplazarse hacia la derecha se mantiene en su posición (manteniendo el signo).</p>
<p>El hecho de desplazar un número binario una posición a izquierda o derecha tiene una curiosa propiedad: el número resultante se multiplica o divide por 2.</p>

<p>Pensemos un poco en nuestro sistema decimal: si tenemos un determinado número y desplazamos todos los dígitos una posición a la izquierda y añadimos un cero, lo que está sucediendo es que multiplicamos el valor del número por la base:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 1 5  -> Desplazar y cero  ->  1 5 0
 (equivale a multiplicar por la base, es decir, por 10)
</pre>
    </p></td></tr>
</table>
<p>Si desplazamos el número a la derecha, por contra, estamos dividiendo por la base:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
 1 5 2 -> Desplazar y cero -> 0 1 5
 (equivale a dividir por la base, es decir, por 10).
</pre>
    </p></td></tr>
</table>
<p>En binario ocurre lo mismo: al desplazar un byte a la izquierda estamos multiplicando por 2, y al hacerlo a la derecha estamos dividiendo por 2 (siempre divisiones enteras). Veamos unos ejemplos:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 33 = 00100001
          << 1   (<< significa desplazamiento de bits a izquierda)
    ------------
      01000010 = 66 (33*2)


 14 = 00001110
          >> 1   (>> significa desplazamiento de bits a derecha)
    ------------
      00000111 = 7 (14/2)

</pre>
    </p></td></tr>
</table>
<p>Cada vez que realizamos un desplazamiento estamos multiplicando el resultado por dos, de forma que:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Dirección        Núm. desplazamientos   Operación
-----------------------------------------------------------------
 SLA:
 Izquierda (<<)         1                 N = N*2
 Izquierda (<<)         2                 N = (N*2)*2 = N*4
 Izquierda (<<)         3                 N = ((N*2)*2)*2 = N*8
 Izquierda (<<)         4                 N = (...) N*16
 Izquierda (<<)         5                 N = (...) N*32
 Izquierda (<<)         6                 N = (...) N*64
 Izquierda (<<)         7                 N = (...) N*128
 SRA:
 Derecha   (>>)         1                 N = N/2
 Derecha   (>>)         2                 N = (N/2)/2 = N/4
 Derecha   (>>)         3                 N = ((N/2)/2)/2 = N/8
 Derecha   (>>)         4                 N = (...) N/16
 Derecha   (>>)         5                 N = (...) N/32
 Derecha   (>>)         6                 N = (...) N/64
 Derecha   (>>)         7                 N = (...) N/128

</pre>
    </p></td></tr>
</table>
<p>Así, desplazar una vez a la izquierda equivale a multiplicar por 2, 2 veces, por 4, 3 veces, por 8, etc. En resumen, desplazar un registro N veces a la izquierda equivale a multiplicarlo por 2 elevado a N. Lo mismo ocurre con la multiplicación.</p>
<p>De este modo, acabamos de descubrir una manera muy sencilla y efectiva (y rápida, muy rápida para el microprocesador) de efectuar multiplicaciones y divisiones por 2, 4, 8, 16, 32, 64 y 128.</p>
<p>Existe una pequeña variante de SRA llamada SRL que realiza la misma acción que SRA pero que, a diferencia de esta, lo que hace es introducir un cero a la izquierda (en lugar de copiar el bit de signo). La diferencia es que SRA es un desplazamiento aritmético (tiene en cuenta el signo) y SRL es un desplazamiento lógico (simplemente desplaza los bits):</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Bit 7 6 5 4 3 2 1 0                C    7 6 5 4 3 2 1 0
    ----------------- -> SRL ->  ------------------------
     a b c d e f g h                h    0 a b c d e f g
</pre>

    </p></td></tr>
</table>
<p>Literalmente:</p>
<ul>
	<li>Rotar los bits a la derecha (&gt;&gt;).</li>
	<li>El bit "h" (bit 0) se copia al Carry Flag.</li>
	<li>Por la izquierda entra un cero.</li>
</ul>


<table border="0" cellspacing="0" cellpadding="2" width="500">
	<tr align="right">
		<td><img src="img/sla_sra_srl.gif" width="500" height="400"  alt="SLA, SRA y SLR" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">SLA, SRA y SLR</td>
	</tr>
</table>


<p>Nuestra ya conocida tabla:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                        Flags
  Instrucción       |S Z H P N C|        Significado
 -----------------------------------------------------------------
  SLA s             |* * 0 P 0 *|        Shift Left Arithmetic (s=s*2)
  SRA s             |* * 0 P 0 *|        Shift Right Arithmetic (s=s/2)
  SRL s             |* * 0 P 0 *|        Shift Right Logical (s=s&gt;&gt;1)
</pre>
    </p></td></tr>
</table>
<p>Cabe destacar que gracias al Carry flag podremos realizar operaciones que desborden los 8 bits de que dispone un registro. Por ejemplo, supongamos que queremos realizar una multiplicación por 152 por 2. El resultado del desplazamiento sería:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr><td><p class="codigo">
<pre>
 152 = 10011000
           << 1 (*2)
     ------------
       00110000 = 48
</pre>
    </p></td></tr>
</table>
<p>¿Por qué nuestro registro acaba con un valor 48? Porque el resultado es mayor que 255, el valor máximo que podemos representar con 8 bits. Para representar el resultado (304), necesitaríamos un bit extra (9 bits) que nos daría acceso a representar números en el rango de 0 a 511. Ese bit extra es el carry flag, ya que en realidad:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>

 152 =     10011000
               << 1 (*2)
     ---------------------
      1    00110000 = 304
     (C)
</pre>
    </p></td></tr>
</table>
<p>Además, gracias a la combinación de instrucciones de rotación y desplazamiento podemos realizar operaciones con registros de 16 bits. Por ejemplo, supongamos que queremos multiplicar por 2 el valor positivo que tenemos en el registro DE:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
  SLA E
  RL  D
</pre>

    </p></td></tr>
</table>
<p>Lo que hacemos con "SLA E" es desplazar el byte más bajo del registros 16 bits DE hacia la izquierda, dejando el bit 7 de "E" en el Carry Flag, y después realizar una rotación de "D" hacia la izquierda introduciendo el carry flag de la operación anterior en el bit 0 de "D".</p>
<p>Registro DE original:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
               D                       E
 DE:   ---------------------   ---------------------
 Bit  15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00      Carry
     -------------------------------------------------     -----
       a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p        ?
</pre>
    </p></td></tr>
</table>

<p>Primero con SLA E rotamos la parte baja, metiendo el bit "i" en el Carry Flag:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 SLA E:
               D                       E
 DE:   ---------------------   ---------------------
 Bit  15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00      Carry
     -------------------------------------------------     -----
       a  b  c  d  e  f  g  h  j  k  l  m  n  o  p  0        i
</pre>
    </p></td></tr>
</table>
<p>Ahora con RL D rotamos D introduciendo el bit "i" en su bit 0:</p>
<p>RL D:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr><td><p class="codigo">
<pre>
               D                       E
 DE:   ---------------------   ---------------------
 Bit  15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00      Carry
     -------------------------------------------------     -----
       b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  0           a
</pre>
    </p></td></tr>
</table>
<p>Podemos repetir la operación para multiplicar por 4, 8, 16, etc. dicho par de registros.</p>
<p>De igual forma, podemos realizar rotaciones de 16 bits a la derecha, haciendo el proceso inverso y comenzando primero con el byte alto:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>

 SRA D
 RR E
</pre>
    </p></td></tr>
</table>
<p>Las operaciones de este tipo sobre registros de 16 bits son muy importantes para realizar otro tipo de operaciones de más amplitud como multiplicaciones y divisiones.</p>
<p>Y, para finalizar, veamos cómo el operando destino de 16 bits puede ser un par de bytes de memoria, como en el siguiente código de ejemplo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 LD IX, 16384
 SLA (IX)
 RL (IX+01H)
</pre>

    </p></td></tr>
</table>
<p>Recordad para este ejemplo que en memoria se almacena primero el byte menos significativo de la palabra de 16 bits, y en la siguiente posición de memoria el más significativo.</p>
<p><em>OPERACIONES LOGICAS: AND, OR Y XOR</em></p>
<p>Para acabar con el artículo de hoy vamos a ver 3 operaciones a nivel de bits: AND, OR y XOR. Estas 3 operaciones lógicas se realizan entre 2 bits, dando un tercer bit como resultado:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
  Bit  Bit   Resultado
   1    2       AND
----------------------
   1    1        1
   1    0        0
   0    1        0
   0    0        0


  Bit  Bit   Resultado
   1    2       OR
----------------------
   1    1        1
   1    0        1
   0    1        1
   0    0        0


  Bit  Bit   Resultado
   1    2       XOR
----------------------
   1    1        0
   1    0        1
   0    1        1
   0    0        0
</pre>
    </p></td></tr>

</table>
<p>Podría decirse que:</p>
<ul>
	<li>AND es la multiplicación lógica: si cualquiera de los 2 bits es cero, el resultado es cero (0*0=0, 0*1=0, 1*0=0); dicho resultado sólo será uno cuando ambos bits sean 1 (1*1=1).</li>
	<li>OR es la suma lógica: si alguno de los bits es uno, el resultado es uno (1+1=1, 0+1=1, 1+0=1). Sólo obtendremos un 0 al hacer un OR entre 2 bits cuando ambos son cero.</li>
	<li>XOR es una operación de "O EXCLUSIVO" (exclusive OR) donde el resultado es cero cuando los 2 bits operandos son iguales, y uno cuando los 2 bits operandos son diferentes.</li>
</ul>
<p>Ejemplos:<p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr><td><p class="codigo">
<pre>
 10010101 AND 0000111  = 00000101

 00000101 OR  1100000  = 11000101

 11000011 XOR 10011001 = 01011010
</pre>
    </p></td></tr>
</table>
<p>A la hora de realizar estas operaciones lógicas en nuestro Z80 disponemos de 3 instrucciones cuyos nombres son, como podéis imaginar, AND, OR y XOR. Las tres tienen el mismo formato:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 AND ORIGEN
 OR  ORIGEN
 XOR ORIGEN

</pre>
    </p></td></tr>
</table>
<p>Donde ORIGEN puede ser cualquier registro de 8 bits, valor inmediato de 8 bits, contenido de la memoria apuntada por [HL], o contenido de la memoria apuntada por un registro índice más un desplazamiento. El formato de la instrucción no requiere 2 operandos, ya que el registro destino sólo puede ser A.</p>
<p>La operación CPL, que vimos al principio de esta entrega, también se considera una operación lógica, equivalente a NOT (0->1 y 1->0).</p>
<p>Pero continuemos con AND, OR y XOR. Veamos algunos ejemplos de instrucciones válidas:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 AND B
 OR C
 OR [HL]
 XOR [IX+10]
 AND 45
</pre>

    </p></td></tr>
</table>
<p>La operación realizada por estas instrucciones sería:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 AND ORIGEN -> A = A & ORIGEN
 OR  ORIGEN -> A = A | ORIGEN
 XOR ORIGEN -> A = A ^ ORIGEN

 ( Donde & = AND, | = OR y ^ = XOR )
</pre>
    </p></td></tr>
</table>

<p>Recordemos que AND, OR y XOR son operaciones de un sólo bit, de modo que al trabajar con registros (o memoria, o valores inmediatos), en realidad estamos realizando 8 operaciones AND, OR o XOR. Por ejemplo, al hacer un AND entre los registros A y B con "AND B" (A=A&B), realizamos las siguientes operaciones:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Registro A:   Bit  7  6  5  4  3  2  1  0
               ----------------------------
                   A7 A6 A5 A4 A3 A2 A1 A0

 Registro B:   Bit  7  6  5  4  3  2  1  0
               ----------------------------
                   B7 B6 B5 B4 B3 B2 B1 B0
</pre>
    </p></td></tr>
</table>
<p>Resultado:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
 A7 = A7 AND B7
 A6 = A6 AND B6
 A5 = A5 AND B5
 A4 = A4 AND B4
 A3 = A3 AND B3
 A2 = A2 AND B2
 A1 = A1 AND B1
 A0 = A0 AND B0
</pre>
    </p></td></tr>
</table>
<p>Es decir, se hace una operación AND entre el bit 7 de A y el bit 7 de B, y se almacena el resultado en el bit 7 de A, y lo mismo para los bits restantes.</p>
<p>¿Para qué pueden servirnos estas 3 operaciones lógicas? Os aseguro que a lo largo de vuestros programas tendréis que usarlas, y mucho, porque son operaciones muy importantes a la hora de manipular registros. Por ejemplo, supongamos que queremos eliminar los 4 bits más altos de un registro, dejándolos a cero, y dejar sin alterar el estado de los 4 bits menos significativos.</p>
<p>Podríamos hacer:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>

 RES 7, A
 RES 6, A
 RES 5, A
 RES 4, A
</pre>
    </p></td></tr>
</table>
<p>Pero sería mucho más sencillo:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 AND %00001111
</pre>
    </p></td></tr>

</table>
<p>O sea, realizar la operación:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 A = A AND 00001111b
</pre>
    </p></td></tr>
</table>
<p>Veamos un ejemplo del porqué:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
 Sea A = 10101011
 valor = 00001111
       ------------ <-- Operación AND
         00001011
</pre>
    </p></td></tr>
</table>
<p>Como AND es la operación lógica de la multiplicación, al hacer un AND de A con 00001111, todos aquellos bits que son cero en 00001111 quedarán a cero en el resultado, y todos aquellos bits que son uno en 00001111 no modificarán el estado de los bits de A.</p>
<p>De la misma forma, por ejemplo, OR nos permite fusionar 2 cuartetos de bits:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 Sea A = 10100000
 Sea B = 00001111
       ------------ &lt;-- Operación OR
         10101111

</pre>
    </p></td></tr>
</table>
<p>La afectación de flags de las 3 instrucciones es idéntica:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
  AND s             |* * * P 0 0|
  OR s              |* * * P 0 0|
  XOR s             |* * * P 0 0|
</pre>
    </p></td></tr>
</table>
<p>Una curiosidad: XOR A es equivalente a "LD A, 0". Dejamos como ejercicio al lector comprobar por qué mediante algún ejemplo práctico.</p>

<p><strong>EN LA PROXIMA ENTREGA</strong></p>
<p>Veremos conceptos e instrucciones muy importantes en cualquier programa en ensamblador: qué es y cómo se usa la PILA (stack) del Spectrum, y cómo realizar cambios en el flujo del programa con sentencias condicionales equivalentes al IF/THEN/ELSE.</p>
<p><strong>FICHEROS</strong></p>
<ul>
    <li><a href="src/sumaresta.txt" onClick="window.open(this.href); return false;">Ejemplos de suma y resta en BCD</a></li>
    <li><a href="src/copiarom.bas" onClick="window.open(this.href); return false;">Ejemplo de programa en BASIC que copia la ROM en la VRAM</a></li>
    <li><a href="src/compiarom.tap" onClick="window.open(this.href); return false;">Fichero tap del ejemplo copiarom.bas</a></li>
    <li><a href="src/carga.asm" onClick="window.open(this.href); return false;">Rutina de volcado de pantalla en ASM</a></li>

    <li><a href="src/carga.bin" onClick="window.open(this.href); return false;">Rutina de volcado de pantalla en ASM (binario)</a></li>
    <li><a href="src/carga.bas" onClick="window.open(this.href); return false;">Cargador BASIC de la rutina anterior</a></li>
    <li><a href="src/ejemplo.asm" onClick="window.open(this.href); return false;">Ejemplo ejecutable de carga de pantalla con volcado</a></li>
    <li><a href="src/ejemplo.asm" onClick="window.open(this.href); return false;">Ejemplo de programa en ASM</a></li>
    <li><a href="src/ejemplo.tap" onClick="window.open(this.href); return false;">Fichero tap del ejemplo anterior</a></li>
</ul>
<p><strong>LINKS</strong></p>

<ul>
    <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt28.html" onClick="window.open(this.href); return false;">Juego de caracteres</a></li>
    <li><a href="http://www.z80.info/" onClick="window.open(this.href); return false;">Web del Z80</a></li>
    <li><a href="http://www.worldofspectrum.org/faq/reference/z80reference.htm" onClick="window.open(this.href); return false;">Z80 Reference de WOS</a></li>
    <li><a href="http://ti86.acz.org/z80_ref.htm" onClick="window.open(this.href); return false;">Z80 Reference de TI86</a></li>
    <li><a href="http://icarus.ticalc.org/articles/z80_faq.html" onClick="window.open(this.href); return false;">FAQ de Icarus Productions</a></li>
    <li><a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" onClick="window.open(this.href); return false;">Microfichas de CM de MicroHobby</a></li>

    <li><a href="http://www.ticalc.org/pub/text/z80/" onClick="window.open(this.href); return false;">Tablas de ensamblado y t-estados (pulsar en z80.txt, z80_reference.txt, z80time.txt)</a></li>
    <li><a href="http://www.worldofspectrum.org/faq/reference/Z80reference.htm" onClick="window.open(this.href); return false;">Z80 Reference de WOS</a></li>
    <li><a href="http://www.z80.info/lesson1.htm" onClick="window.open(this.href); return false;">Curso de ensamblador de z80.info</a></li>
    <li><a href="http://www.arrakis.es/~ninsesabe/pasmo/" onClick="window.open(this.href); return false;">Pasmo</li>
</ul>
</div>
        </td>
    </tr>

    <tr>
        <td align="right"><br><br>SROMERO</td>
    </tr>
</table>
                    </td>
                </tr>
                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td>

<script language="JavaScript">
function RecargarPie(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">
        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('rem.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
        <option value="index.html">Portada</option>
        <option value="editorial.html">Índice - Editorial</option>

        <option value="panorama.html">Panorama</option>
        <option value="analisis.html">Análisis</option>
        <option value="hardware.html">Hardware</option>
        <option value="rem.html">REM</option>
        <option value="ensamblador.html" selected>Programación Ensamblador</option>
    </select>

    <input type="button" onclick="return false;" name="siguiente" value=">" disabled  />
</td>
            <td align="right" class="texto">
                <a href="#arriba">Volver arriba</a>
            </td>
        </tr>
        <tr><td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>

    </form>
</table>
                    </td>
                </tr>
                <tr>
                    <td>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
	<tr align="center" valign="center">
		<td>2003-2009 Magazine ZX</td>

	</tr>
</table>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-8018503-4");
pageTracker._trackPageview();
} catch(err) {}</script>
                    </td>
                </tr>
            </table>

    </body>

</html>
