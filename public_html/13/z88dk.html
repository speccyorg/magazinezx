<!doctype html>
<html lang="es">
<head>
    <title>Programación Z88DK - Magazine ZX número 13 - Enero 2006</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/magazine.css" type="text/css">
</head>
<body>
<table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
    <tr>
        <td>
            <a name="arriba"></a>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
                <tr align="center" valign="center">
                    <td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0"/></a></td>
                </tr>
            </table>
        </td>

    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarCabecera(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>

                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('el-aventurero.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>

                                <option value="al-descubierto.html">Al Descubierto</option>
                                <option value="el-aventurero.html">El Aventurero</option>
                                <option value="z88dk.html" selected>Programación Z88DK</option>
                                <option value="input.html">INPUT</option>
                                <option value="ensamblador.html">Programación Ensamblador</option>
                                <option value="rem.html">REM</option>

                                <option value="opinion.html">Opinión</option>
                            </select>
                            <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                        </td>
                        <td align="center" class="texto">Número 13 - Enero 2006</td>
                        <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX"
                                             onClick="window.open(this.href); return false;"><img
                                src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0"
                                alt="ZX Certified webmaster"></a>&nbsp;<a href="http://www.speccy.org/"
                                                                          onClick="window.open(this.href); return false;"><img
                                src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a>
                        </td>
                    </tr>
                </form>

            </table>
            </a>
        </td>
    </tr>
    <tr>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
                <tr>
                    <td>

                        <div align="justify">
                            <p align="center"><font size="5">LA LIBRERIA SPRITE PACK</font></p>
                            <p><b>INTRODUCCIÓN</b></p>
                            <p><i>En artículos anteriores de la revista hemos visto como utilizar las funciones
                                proporcionadas de base con la librería z88dk para la creación de sprites, aplicándolas
                                para crear la semilla de lo que podría ser nuestro propio juego de coches. Sin embargo,
                                nos encontrábamos con un par de contratiempos que, aunque no se indicaron de forma
                                explícita, los podríamos descubrir a la hora de crear nuestras propias aplicaciones. Por
                                una parte, la complejidad del diseño de los propios sprites; de hecho, nos teníamos que
                                basar en una aplicación (sólo para Linux) para la creación de los mismos. Por otra
                                parte, cambiar los atributos de color y fondo de los sprites, así como transparencias,
                                es un tema no especialmente sencillo que ni siquiera se trató.</i></p>
                            <p>Para hacernos la vida más fácil a la hora de programar usando sprites disponemos de la
                                librería <b>Sprite Pack</b>; la página principal del proyecto es <a
                                        href="http://www.geocities.com/aralbrec/"
                                        onclick="window.open(this.href); return false;">http://www.geocities.com/aralbrec/</a>.
                                Se trata de piezas de código escritas en ensamblador, con una interfaz que puede ser
                                usada desde C para su compilación con las herramientas de z88dk. Esto en cristiano
                                quiere decir que podremos llamar a las funciones de la librería Sprite Pack desde
                                nuestros programas z88dk de forma totalmente transparente, pero teniendo la seguridad de
                                que el código será lo más eficiente posible.</p>
                            <p>Sprite Pack es una librería multipropósito, no centrada únicamente en la creación de
                                sprites. Se compone de varios módulos distintos: creación de sprites, rutinas de
                                entrada, intersecciones de rectángulos, tipos abstractos de datos, compresión de datos,
                                API de interrupciones, etc. No solo podemos utilizarla con el Spectrum, sino que en
                                teoría podríamos emplear todo este código en cualquier plataforma Z80, aunque existen
                                dos módulos demasiado específicos que solo dispondremos para <i>Spectrum y Timex</i>, el
                                de creación de sprites y el de lectura de dispositivos de entrada.</p>

                            <p>Durante los siguientes artículos nos centraremos especialmente en el módulo de sprites,
                                con la idea de ser utilizado en el seno de nuestras aplicaciones z88dk para Spectrum,
                                aunque durante el desarrollo de nuestros ejemplos tendremos que ir usando también
                                algunas pequeñas partes del resto de los módulos. Vamos a dar un pequeño paso atrás con
                                respecto a entregas anteriores, pues vamos a aprender de nuevo a dibujar sprites desde
                                el principio, aunque utilizando Sprite Pack en esta ocasión. Podría parecer que esto es
                                un poco inútil, pero ya veremos más adelante que las ventajas de utilizar esta capa por
                                encima de z88dk no tardarán en llegar.</p>
                            <p><b>INSTALACIÓN</b></p>
                            <p>Lo primero que debemos hacer es descargar la librería de su página (en el momento de
                                escribir este artículo, la última versión era la 2.2):</p>
                            <p><a href="http://www.geocities.com/aralbrec/"
                                  onclick="window.open(this.href); return false;">http://www.geocities.com/aralbrec/</a>
                            </p>
                            <p>Tras obtener el fichero comprimido, lo descomprimimos en cualquier directorio de trabajo.
                                El resultado será la carpeta z88dk, en cuyo interior encontraremos a su vez otro
                                directorio llamado work, en el que en último lugar descubriremos un nuevo directorio
                                llamado splib2, en el que nos deberemos situar para realizar la compilación.</p>
                            <p>Al tratarse de una librería para el manejo, entre otras cosas, de sprites de la pantalla,
                                debemos comprobar que el código de la librería se va a compilar para las características
                                peculiares del Spectrum antes de continuar. Lo único que tendremos que hacer será editar
                                el fichero <i>SPconfig.def</i>, que es el fichero de configuración de la compilación, y
                                asegurarnos de que el valor de <b>DISP_SPECTRUM</b> es 1 y el valor del resto de
                                variables DISP_ (<b>DISP_HICOLOUR</b>, <b>DISP_HIRES</b> y <b>DISP_TMXDUAL</b>) es 0.
                            </p>

                            <p>Sprite Pack incluye un fichero <i>Makefile.bat</i> que creará la librería en una máquina
                                Windows. Solamente sería necesario en este tipo de entorno que se abriera una ventana de
                                MS-DOS, se acudiera al directorio donde está el código fuente, y tras inicializar las
                                variables de entorno que permiten compilar con z88dk, teclear Makefile. En Linux es un
                                poco más complicado, y deberemos modificar ese archivo para que funcione. Para ahorrar
                                trabajo al lector, se incluye un fichero <i>Makefile.sh</i>, equivalente al Makefile.bat
                                para Windows, que puede ser usado en Linux junto a este artículo. No se debe olvidar el
                                proporcionar permiso de ejecución a dicho fichero para que lo podamos utilizar. El
                                fichero <i>sp.lst</i>, que se encuentra en el directorio raíz del código fuente de la
                                librería (junto a makefile.bat) tambien debe ser modificado para Linux; junto a este
                                artículo se adjunta igualmente este archivo para poder ser utilizado en este sistema.
                            </p>
                            <p>Sea cual sea el sistema operativo que utilicemos, como resultado obtendremos un nuevo
                                fichero <b>splib2.lib</b>, que deberemos copiar al interior del directorio
                                <i>lib\clibs</i> dentro de nuestro directorio de instalación de z88dk. A su vez,
                                deberemos copiar el fichero <b>spritepack.h</b> en el directorio <i>include</i>, también
                                dentro del directorio de isntalación de z88dk. ¡Ya tenemos la librería lista para ser
                                usada!. Solo será necesario añadir la línea <font color="green">#include
                                    "spritepack.h"</font> en cada uno de los archivos .c en los que queramos hacer uso
                                de las funcionalidades de la libreria, y compilarlos añadiendo -lsplib2 como uno de los
                                parámetros de zcc.</p>

                            <p><b>NUESTRO PRIMER EJEMPLO</b></p>
                            <p>Sprite Pack tiene una forma particular de actualizar la pantalla. Realizar una
                                actualización completa y simultánea de toda ella simultáneamente haría necesario el uso
                                de rutinas en ensamblador demasiado específicas, lo cual chocaría con el objetivo real
                                de la librería, que se pretende que sea multiplataforma. Es por ello que lo que
                                realmente se hace es actualizar únicamente las porciones de la pantalla donde se ha
                                producido algún cambio. Se dirá que aquellas partes de la pantalla que queramos
                                redibujar deberán ser invalidadas. Aquellas partes que no queramos redibujar serán
                                regiones validadas. Luego lo veremos con un ejemplo y lo entenderemos mejor, pero de
                                momento nos debemos hacer a la idea de que nunca podremos hacer juegos con scroll total,
                                ya sea horizontal o vertical, con esta librería. Deberemos centrarnos en juegos de
                                plataformas o juegos limitados donde toda la acción se desarrolla sin scroll.</p>
                            <p>Otros conceptos que deberemos tener claros son el de <b>backtile</b> y <b>sprite</b>.
                                Comprender la diferencia entre ambos es necesario para desarrollar nuestras
                                aplicaciones. La pantalla está dividida en un array de tamaño 32x24 de celdas de
                                caracteres (a su vez de tamaño 8x8). Cada una de estas celdas podrá contener sólo un
                                backtile y uno o más sprites. Los backtiles se pueden entender como el "fondo", y en
                                realidad se trata de UDGs coloreados de tamaño 8x8, que son escritos en la pantalla de
                                la misma forma en la que lo son los UDGs en BASIC. Por otra parte, los sprites podrán
                                ocupar cualquier posición de la pantalla, en incrementos de un pixel, y su tamaño podrá
                                ser mayor que 8x8, aunque no tendremos tanta libertad como con z88dk y únicamente podrán
                                tener tamaños múltiplos, tanto en número de filas como de columnas, de 8.</p>
                            <p>De momento nos centraremos en los backtiles. La función básica para dibujarlos es <font
                                    color="green">sp_PrintAtInv</font>, que además de dibujar el carácter con el color
                                de tinta y papel que deseemos, invalidadá la celda donde haya sido dibujado para que se
                                redibuje al actualizar la pantalla. Existe otra función, <font
                                        color="green">sp_PrintAt</font>, que hace exactamente lo mismo, pero sin
                                invalidar la celda donde el backtile es dibujado. Todos los cambios en la pantalla se
                                realizarán de forma simultánea al llamar a la función <font
                                        color="green">sp_updateNow</font>.</p>

                            <p>Veamos un ejemplo. El siguiente código se encarga de dibujar letras 'x' en posiciones al
                                azar de la pantalla, cambiando el color de la tinta y el papel, también al azar.</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
#include &lt;stdlib.h&gt;
#include &lt;spritepack.h&gt;

#pragma output STACKPTR=61440

main()
{
   #asm
   di
   #endasm
   sp_InitIM2(0xf1f1);
   sp_CreateGenericISR(0xf1f1);
   #asm
   ei
   #endasm


   sp_Initialize(INK_BLACK | PAPER_WHITE, ' ');
   while(1) {
           sp_UpdateNow();
           if (rand()%10 &gt; 5)
                   sp_PrintAtInv(rand()%24, rand()%32, INK_RED | PAPER_CYAN, 'x');
           else
                   sp_PrintAtInv(rand()%24, rand()%32, INK_CYAN | PAPER_RED, 'x');
           sp_Pause(20);
   }
}

</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Veamos línea por línea de qué va todo esto. Las dos primeras se corresponden con las
                                sentencias #include necesarias; en este caso la librería estándar y el archivo de
                                cabecera de la librería Sprite Pack.</p>
                            <p>La sentencia <font color="green">#pragma</font> deberemos incluirla siempre al principio
                                de nuestros programas escritos para la librería Sprite Pack, antes del método main. Lo
                                que se dice con ella es que se desea comenzar la ejecución del programa con el puntero
                                de la pila del Z80 apuntando a la dirección 61440. Al hacerlo de esta forma, evitaremos
                                que la función <i>sp_initialize</i> destruya cierta información de la memoria.</p>
                            <p>Las primeras líneas de código en el interior de main(), entre el primer <font
                                    color="green">#asm</font> y el último <font color="green">#endasm</font> tendremos
                                que ponerlas también siempre en nuestros programas que usen Sprite Pack. No es necesario
                                entrar en detalle, pero diremos que este código tiene algo que ver con deshabilitar
                                interrupciones para que ciertas funciones como sp_Invalidate funcionen.</p>

                            <p>Y por fin comienzan las líneas interesantes. La función sp_Initialize es necesaria para
                                que el módulo de sprites de la librería comience a funcionar. En este caso, los
                                parámetros hacen que la pantalla se inicialice escribiendo espacios en blanco, con color
                                de fondo (paper) blanco y tinta negra (ink).</p>
                            <p>A continuación nos introducimos en el bucle principal, que se va a ejecutar de forma
                                ininterrumpida por toda la eternidad (a menos que detengamos la ejecución del programa).
                                La estructura es muy sencilla. Primero se llama a <font
                                        color="green">sp_UpdateNow</font> para que se redibujen las celdas de la
                                pantalla donde hubo algún cambio. A continuación se obiene un número al azar entre 1 y
                                10 (mediante la función <font color="green">rand()</font>), y en función de su valor
                                llamaremos a <font color="green">sp_PrintAtInv</font> con unos parámetros u otros.</p>
                            <p>El método <font color="green">sp_PrintAtInv</font> dibuja un backtile en la pantalla e
                                invalida la posición donde dicho backtile ha sido colocado, para que la celda
                                correspondiente sea redibujada tras llamar a <i>sp_UpdateNow</i>. Los dos primeros
                                parámetros indican la posición del backtile (que también los obtenemos al azar), a
                                continuación el color de papel y de tinta (con la misma sintaxis que en el caso de la
                                función <i>sp_Initialize</i>) y por último indicamos el carácter a escribir. Este
                                carácter se corresponde con un UDG, como en BASIC. De momento no hemos asociado ningún
                                UDG a la letra x, por lo que se mostrará en pantalla será la letra x apareciendo en
                                posiciones al azar, teniendo o bien color de tinta rojo y papel cyan o al revés.</p>

                            <p>La última línea del bucle, <font color="green">sp_Pause</font>, introduce un pequeño
                                retardo. Actúa exactamente igual que el comando PAUSE de BASIC.</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="640">
                                <tr align="right">
                                    <td><img src="img/z88dk8_1.png" width="640" height="504"
                                             alt="Espectaculares efectos gráficos conseguidos con la librería Sprite Pack"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Espectaculares efectos gráficos conseguidos con la
                                        librería Sprite Pack
                                    </td>

                                </tr>
                            </table>

                            <p><b>NUESTRO PRIMER EJEMPLO CON UN SPRITE</b></p>
                            <p>En esta sección vamos a dibujar un sprite simple sobre un fondo un poco más complejo.
                                Para comprender cómo podemos crear un fondo más complejo, hemos de recordar que los
                                backtiles pueden entenderse como si fueran UDGs de BASIC; sin embargo, hasta ahora solo
                                hemos utilizado caracteres alfanuméricos. ¿De qué forma definimos gráficos para estos
                                backtiles?</p>
                            <p>Mediante la función <font color="green">sp_TileArray</font> asociamos un determinado UDG
                                8x8 a un carácter, de tal forma que al escribir dicho carácter como backtile en la
                                pantalla, aparecerá su UDG correspondiente. Esta función recibe como parámetro el
                                carácter al que queremos asociar el UDG y un array de tipo uchar con la definición del
                                UDG. Ese array contendrá un valor hexadecimal por cada fila del UDG, utilizando la misma
                                notación que vimos en capítulos anteriores para la creación de sprites de tamaño 8x8 con
                                z88dk. Por ejemplo, observemos el siguiente código:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>

<font color="green">
uchar fondo[] = {0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa};

sp_TileArray(' ', fondo);
sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Con la primera línea creamos un array llamado fondo que contendrá la definición de un UDG
                                de tipo "tablero de ajedrez" (un pixel negro, un pixel blanco, un pixel negro, un pixel
                                blanco, y así sucesivamente). Con la instrucción sp_TileArray asociamos este UDG al
                                carácter de espacio en blanco, de tal forma que cuando en la línea siguiente llamamos a
                                sp_Initialize, el fondo se llenará de copias del UDG asociado a dicho carácter. De esta
                                forma tan sencilla podremos tener fondos más detallados.</p>
                            <p>¿Y cómo definimos un sprite? De forma mucho más fácil a la vista en artículos anteriores,
                                en los que se usaba z88dk sin ningún añadido. Nada más simple que una notación como la
                                siguiente:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
#asm

._sprite1
defb @00111100, @11000011
defb @01000010, @10000001
defb @10000001, @00000000
defb @10100101, @00000000
defb @10000001, @00000000
defb @10011001, @00000000
defb @01011010, @10000001
defb @00111100, @11011011

#endasm

</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Como se puede observar, volvemos a hacer uso de código ensamblador empotrado en el
                                interior de nuestro código C, entre las directivas <i>#asm</i> y <i>#endasm</i>. En este
                                caso concreto estamos definiendo un único sprite 8x8, para el cual necesitaremos dos
                                bloques de bits de ese tamaño. El de la izquierda es el dibujo en sí mismo del sprite,
                                que en nuestro caso en una pequeña carita con la boca abierta. El bloque de la derecha
                                indica las transparencias; en aquellas posiciones donde el valor sea 1, el sprite será
                                transparente y se verá lo que haya en el fondo. Evidentemente, es necesario que dichas
                                posiciones tengan un valor 0 en el bloque de la izquierda.</p>
                            <p>A este bloque de datos que marcan un sprite de 8x8 le hemos llamado sprite1. Este nombre
                                nos servirá para referenciar este código ensamblador desde el código C. Para ver cómo
                                dibujar el sprite en la pantalla, nada mejor que un pequeño ejemplo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
<font color="green">
#include &lt;spritepack.h&gt;
#pragma output STACKPTR=61440

extern struct sp_Rect *sp_ClipStruct;
#asm
LIB SPCClipStruct
._sp_ClipStruct         defw SPCClipStruct
#endasm


extern uchar sprite1[];
uchar fondo[] = {0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa};



void *my_malloc(uint bytes)
{
           return sp_BlockAlloc(0);
}


void *u_malloc = my_malloc;
void *u_free = sp_FreeBlock;



main()
{
           struct sp_SS *bicho;


           #asm
           di
           #endasm
           sp_InitIM2(0xf1f1);
           sp_CreateGenericISR(0xf1f1);
           #asm
           ei
           #endasm

           sp_TileArray(' ', fondo);
           sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');
           sp_Border(BLACK);
           sp_AddMemory(0, 255, 14, 0xb000);

           bicho = sp_CreateSpr(sp_MASK_SPRITE, 1, sprite1, 1, TRANSPARENT);
           sp_MoveSprAbs(bicho, sp_ClipStruct, 0, 10, 15, 0, 0);

           sp_UpdateNow();

           while(1);
}

#asm

._sprite1
defb @00111100, @11000011
defb @01000010, @10000001
defb @10000001, @00000000
defb @10100101, @00000000
defb @10000001, @00000000
defb @10011001, @00000000
defb @01011010, @10000001
defb @00111100, @11011011

#endasm
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Comentemos línea por línea el programa. La sentencia <font color="green">#pragma</font>
                                ya la conocemos del ejemplo anterior, así que no hace falta que nos detengamos en ella.
                                A continuación se define una estructura de la forma siguiente:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
extern struct sp_Rect *sp_ClipStruct;
#asm
LIB SPCClipStruct
._sp_ClipStruct         defw SPCClipStruct
#endasm
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Esta estructura tan confusa está sacada de <i>spritepack.h</i> y define un rectángulo que
                                cubre toda la superficie de la pantalla. Existen muchas definiciones como ésta dentro de
                                dicho fichero de cabecera. Para qué sirven lo veremos mucho más adelante, cuando
                                tratemos el tema de las colisiones. De momento deberemos saber que lo necesitamos para
                                poder dibujar el sprite en la pantalla.</p>
                            <p>La línea <font color="green">extern uchar sprite1[];</font> crea el array que contendrá
                                la información del sprite. Este array se llena con los datos definidos entre las
                                cláusulas <i>#asm</i> y <i>#endasm</i> al final del programa, después de la etiqueta <i>._sprite1</i>,
                                y contendrá la definición del sprite, de la misma forma en la que en la línea siguiente
                                se crea un array de tipo uchar llamado fondo con la definición de un UDG para asociarlo
                                al backtile de fondo.</p>

                            <p>El siguiente código:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
void *my_malloc(uint bytes)
{
           return sp_BlockAlloc(0);
}


void *u_malloc = my_malloc;
void *u_free = sp_FreeBlock;
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>entra dentro de lo que estaremos obligados a insertar en nuestro programa cada vez que
                                queramos añadirle sprites, aunque no entendamos muy bien de qué se trata. Se obtiene a
                                partir del módulo de manejo de memoria de Sprite Pack y sirve para que el programa pueda
                                obtener memoria bajo demanda. Esto es necesario debido a la forma en que la pantalla es
                                actualizada al usar esta librería. Además de las estructuras creadas por el programador,
                                la librería creará otras propias durante la ejecución y la memoria para dichas
                                estructuras se obtendrá por medio de esta función.</p>
                            <p>Y por fin comienza el método <b>main</b>. En primer lugar definimos la variable que va a
                                contener el sprite que vamos a mostrar por pantalla. Esta variable es de tipo <b>struct
                                    sp_SS</b>, una estructura que contiene diversa infomación sobre un sprite, como su
                                localización y su tamaño. A continuación, entre las directivas #asm y #endasm, el código
                                ensamblador necesario en cada uno de nuestros programas Sprite Pack del que hablamos en
                                la sección anterior.</p>

                            <p>Y continuamos con las dos líneas siguientes, cuyo funcionamiento ha sido explicado
                                anteriormente:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
p_TileArray(' ', fondo);
sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>La línea posterior es nueva, y permite definir el color del borde de la pantalla (como la
                                instrucción BORDER de BASIC). A continuación otra línea un tanto complicada,
                                correspondiente a la llamada a la función <font color="green">sp_AddMemory</font>, con
                                la que se reserva memoria para los sprites. En concreto estamos reservando 255 bloques
                                de 14 bytes a partir de la dirección 0xb000 que se sabe que está libre. Para cada sprite
                                deberíamos reservar un par de bloques de 14 bytes, por lo que 255 es algo
                                desproporcionado para nustro ejemplo. Si nos vemos apurados de memoria podemos reservar
                                menos en este paso.</p>

                            <p>Las líneas que más nos interesan de este ejemplo son las siguientes:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
bicho = sp_CreateSpr(sp_MASK_SPRITE, 1, sprite1, 1, TRANSPARENT);
sp_MoveSprAbs(bicho, sp_ClipStruct, 0, 10, 15, 0, 0);
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Con la primera de ellas creamos el sprite en si mismo. El resultado de la llamada se
                                almacenará en la variable de tipo <i>struct sp_SS bicho</i> declarada anteriormente, que
                                usaremos en el resto de métodos con los que queramos manipular dicho sprite. El primer
                                parámetro (para el que nosotros hemos usado MASK, pero que podría ser XOR, OR o LOAD)
                                indica la forma en la que el sprite se dibuja en la pantalla. El tipo <b>MASK</b> es el
                                más lento de dibujar, y utiliza una máscara para determinar que porciones del sprite
                                serán transparentes (tal como se ha visto anteriormente). Los tipos OR y XOR se
                                corresponderían con los ya vistos en artículos anteriores. El siguiente parámetro indica
                                el número de rejillas 8x8 que forman el sprite (se hablará de esto más adelante). A
                                continuación, el nombre del array de tipo uchar que contiene la definición del sprite.
                                En tercer lugar, el plano que ocupará el sprite en pantalla. El valor de este parámetro
                                podrá valer entre 0 y 63. Cuanto mas bajo sea este valor más cerca del usuario se
                                encontrará el sprite, de tal forma que sprites con valores bajos del tercer parámetro
                                serán situados "encima" de sprites con valores altos, tapándolos. El cuarto parámetro
                                tiene que ver con el color, y lo veremos también más adelante. Hemos usado el valor
                                TRANSPARENT para que no influya en el color del fondo.</p>

                            <p>Situaremos el sprite creado sobre la pantalla mediante el uso de la función <font
                                    color="green">sp_MoveSprAbs</font>, que desplaza nuestro personaje a una posición
                                absoluta de la pantalla. Podríamos utilizar <font color="green">sp_MoveSprRel</font>,
                                que acepta el mismo número de parámetros, con la diferencia de mover el sprite a una
                                posición relativa a la actual. Por lo tanto, siempre usaremos sp_MoveSprAbs para colocar
                                al sprite en su posición inicial.</p>
                            <p>Como primer parámetro, el sprite a mover. Como segundo parámetro, el rectángulo que hace
                                referencia a toda la pantalla definido anteriormente. El tercer parámetro hace
                                referencia a la animación, y tampoco hablaremos de él en esta ocasión. El cuarto y el
                                quinto, al bloque de la pantalla donde situaremos el sprite. Decíamos anteriormente que
                                la pantalla estaba dividida en bloques de 8x8; pues bien, con estos dos parámetros
                                indicamos la celda donde colocaremos nuestro sprite. Para conseguir una colocación más
                                exacta, podemos usar los dos últimos parámetros, correspondientes al offset. Indican
                                cuantos píxeles mover hacia la derecha y hacia abajo, respectivamente, a partir de la
                                celda cuya posición es la indicada por los dos parámetros anteriores.</p>
                            <p>Por último, con <font color="green">sp_UpdateNow()</font> redibujamos las porciones de la
                                pantalla que lo necesiten, y con while(1) dejamos nuestro programa en constante
                                ejecución, hasta el resto de los días, o hasta que lo detengamos. El resultado se puede
                                observar en la siguiente captura de pantalla.</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="640">
                                <tr align="right">

                                    <td><img src="img/z88dk8_2.png" width="640" height="504"
                                             alt="Un terrible ser intergaláctico espera ansioso la orden de atacar"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Un terrible ser intergaláctico espera ansioso la
                                        orden de atacar
                                    </td>
                                </tr>
                            </table>

                            <p><b>UN SPRITE GRANDE Y NERVIOSO</b></p>
                            <p>En este apartado veremos un pequeño ejemplo que introduce algunos conceptos interesantes,
                                como la creación de sprites de un tamaño superior a 8x8 y el uso del movimiento
                                relativo. Vamos a hacer aparecer una criatura en nuestra pantalla que se mueva de forma
                                nerviosa y aleatoria.</p>

                            <p>Pero comencemos por el principio. ¿Cómo definimos sprites que contengan más de un bloque
                                8x8? Con Sprite Pack, los sprites grandes se definen por columnas. Podemos definir una
                                columna de un sprite grande, compuesta por uno o más bloques de 8x8, bajo una misma
                                etiqueta de código ensamblador. Un sprite de más de una columna se formará a partir de
                                varias de estas definiciones en ensamblador.</p>
                            <p>Por ejemplo, mostramos como quedaría un sprite con un tamaño de dos bloques de alto por
                                dos bloques de ancho listo para ser usado con Sprite Pack:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
#asm

._bicho1
defb @00000011, @11111100
defb @00000100, @11111000
defb @00001000, @11110000
defb @00001011, @11110000
defb @00001011, @11110000
defb @00001000, @11110000
defb @00001000, @11110000
defb @00000100, @11111000

defb @00000011, @11111100
defb @00001100, @11110011
defb @00001100, @11110011
defb @00011000, @11100111
defb @00011000, @11100111
defb @01111100, @10000011
defb @01111100, @10000011
defb @00000000, @11111111

._bicho2
defb @11100000, @00011111
defb @00010000, @00001111
defb @00001000, @00000111
defb @01101000, @00000111
defb @01101000, @00000111
defb @00001000, @00000111
defb @10001000, @00000111
defb @10010000, @00001111

defb @11100000, @00011111
defb @00011000, @11100111
defb @00011000, @11100111
defb @00001100, @11110011
defb @00001100, @11110011
defb @00111110, @11000001
defb @00111110, @11000001
defb @00000000, @11111111

#endasm
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Como se puede observar, definimos dos columnas para el sprite, cada una de ellas formada
                                a su vez por dos sprites de tamaño 8x8, incluyendo su máscara de transparencias. Para
                                utilizar el sprite en el código deberíamos hacer algo similar a esto:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
extern uchar bicho1[];
extern uchar bicho2[];

main()
{
	struct sp_SS *spriteBicho;

         spriteBicho = sp_CreateSpr(sp_MASK_SPRITE, 2, bicho1, 1, TRANSPARENT);
         sp_AddColSpr(spriteBicho, bicho2, TRANSPARENT);
         sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);
}
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Se debe hacer uso, en primer lugar, de <font color="green">sp_CreateSpr</font> para
                                asignar la primera columna del sprite a la variable de tipo <b>struct sp_SS</b>, y en
                                segundo lugar, de <font color="green">sp_AddColSpr</font>, tantas veces como columnas
                                adicionales debamos añadir. En este caso, se ha usado un valor de 2 para el segundo
                                parámetro de <i>sp_CreateSpr</i>, indicando que cada columna del sprite tendrá un tamaño
                                de dos bloques de 8x8. Efectivamente, este segundo parámetro indica el número de bloques
                                que tendrá cada columna de nuestro sprite; por eso en nuestro primer ejemplo le dimos
                                valor 1. Una vez se ha creado el sprite con <i>sp_CreateSpr</i> y se han añadido las
                                columnas correspondientes con <i>sp_AddColSpr</i>, se podrá tratar la estructura sp_SS
                                resultante como un todo, tal como se demuestra en la llamada a <i>sp_MoveSprAbs</i> que
                                sigue a las dos líneas anteriores.</p>

                            <p>Es importante destacar que todas las columnas de un mismo sprite deben de ser definidas
                                de forma contigua en la memoria. Esto se traduce en que tenemos que definirlas de forma
                                contigua también en nuestro código.</p>
                            <p>Sin embargo, hay algo que hasta ahora no hemos tenido en cuenta, y es debido a que no
                                hemos movido nuestros sprites por la pantalla. Cuando trasladamos sprites usando el
                                pixel y no el bloque como unidad de medida (los dos últimos parámetros de sp_MoveSprAbs
                                y sp_MoveSprRel servían para esto) veremos como los sprites no son correctamente
                                dibujados; solo se redibuja la parte del sprite más a la izquierda que cabe dentro de
                                una misma celdilla de la pantalla. Un truco para evitar esto es crear sprites un poco
                                más anchos y más altos de lo que realmente necesitamos. Para ello, añadimos una nueva
                                columna en blanco, y en cada columna, un nuevo bloque en blanco al final. En el caso
                                concreto de nuestro sprite 2x2 anterior, deberíamos definirlo de esta forma:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
#asm

._bicho1
defb @00000011, @11111100
defb @00000100, @11111000
defb @00001000, @11110000
defb @00001011, @11110000
defb @00001011, @11110000
defb @00001000, @11110000
defb @00001000, @11110000
defb @00000100, @11111000

defb @00000011, @11111100
defb @00001100, @11110011
defb @00001100, @11110011
defb @00011000, @11100111
defb @00011000, @11100111
defb @01111100, @10000011
defb @01111100, @10000011
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho2
defb @11100000, @00011111
defb @00010000, @00001111
defb @00001000, @00000111
defb @01101000, @00000111
defb @01101000, @00000111
defb @00001000, @00000111
defb @10001000, @00000111
defb @10010000, @00001111

defb @11100000, @00011111
defb @00011000, @11100111
defb @00011000, @11100111
defb @00001100, @11110011
defb @00001100, @11110011
defb @00111110, @11000001
defb @00111110, @11000001
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho3
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

#endasm
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Por lo tanto, nuestro sprite 2x2 se convierte en un sprite 3x3 al añadir una nueva
                                columna a la derecha y un nuevo bloque en la parte inferior de cada columna. Nuestro
                                código a la hora de usar el sprite debería ser en este caso algo más parecido a
                                esto:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
extern uchar bicho1[];
extern uchar bicho2[];
extern uchar bicho3[];

main()
{
         struct sp_SS *spriteBicho;

         spriteBicho = sp_CreateSpr(sp_MASK_SPRITE, 3, bicho1, 1, TRANSPARENT);
         sp_AddColSpr(spriteBicho, bicho2, TRANSPARENT);
         sp_AddColSpr(SpriteBicho, bicho3, TRANSPARENT);
         sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);
}
</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Como queda patente, indicamos que el tamaño en bloques de cada columna es 3 al llamar a
                                la función <i>sp_CreateSPr</i>, y además se llama dos veces a <i>sp_AddColSpr</i> para
                                añadir la segunda y la tercera columna a nuestro bicho.</p>

                            <p>A continuación se muestra un ejemplo completo, con nuestro sprite moviéndose al azar por
                                la pantalla, por medio de la función <i>sp_MoveSprRel</i>:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
<font color="green">
#include &lt;spritepack.h&gt;
#include &lt;stdlib.h&gt;
#pragma output STACKPTR=61440

extern struct sp_Rect *sp_ClipStruct;
#asm
LIB SPCClipStruct
._sp_ClipStruct         defw SPCClipStruct
#endasm

extern uchar bicho1[];
extern uchar bicho2[];
extern uchar bicho3[];
uchar hash[] = {0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa};

void *my_malloc(uint bytes)
{
           return sp_BlockAlloc(0);
}

void *u_malloc = my_malloc;
void *u_free = sp_FreeBlock;


main()
{
           char dx, dy, i;
           struct sp_SS *spriteBicho;

            #asm
            di
            #endasm
            sp_InitIM2(0xf1f1);
            sp_CreateGenericISR(0xf1f1);
            #asm
            ei
            #endasm

           sp_TileArray(' ', hash);
           sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');
           sp_Border(CYAN);
           sp_AddMemory(0, 255, 14, 0xb000);


           spriteBicho = sp_CreateSpr(sp_MASK_SPRITE, 3, bicho1, 1, TRANSPARENT);
           sp_AddColSpr(spriteBicho, bicho2, TRANSPARENT);
           sp_AddColSpr(spriteBicho, bicho3, TRANSPARENT);
           sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);

           while(1) {
                 sp_UpdateNow();

                 dx = dy = 1;

                if (rand()%2 == 0) // izquierda
                        dx = -dx;
                else if (rand()%2 == 0) // derecha
                        dx = 0;
                if (rand()%2 == 0) // arriba
                        dy = -dy;
                else if (rand()%2 == 0) // abajo
                        dy = 0;

                sp_MoveSprRel(spriteBicho, sp_ClipStruct, 0, 0, 0, dx, dy);
           }
}

#asm

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho1
defb @00000011, @11111100
defb @00000100, @11111000
defb @00001000, @11110000
defb @00001011, @11110000
defb @00001011, @11110000
defb @00001000, @11110000
defb @00001000, @11110000
defb @00000100, @11111000

defb @00000011, @11111100
defb @00001100, @11110011
defb @00001100, @11110011
defb @00011000, @11100111
defb @00011000, @11100111
defb @01111100, @10000011
defb @01111100, @10000011
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho2
defb @11100000, @00011111
defb @00010000, @00001111
defb @00001000, @00000111
defb @01101000, @00000111
defb @01101000, @00000111
defb @00001000, @00000111
defb @10001000, @00000111
defb @10010000, @00001111

defb @11100000, @00011111
defb @00011000, @11100111
defb @00011000, @11100111
defb @00001100, @11110011
defb @00001100, @11110011
defb @00111110, @11000001
defb @00111110, @11000001
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho3
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

#endasm

</font>
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Ya deberíamos entender la práctica totalidad de este código, que mueve un sprite al azar
                                por la pantalla, por lo que tan solo haremos dos apuntes:</p>
                            <ul>
                                <li>Los movimientos indicados con <i>sp_MoveSprRel</i> son movimientos relativos, por lo
                                    que si queremos desplazarnos tan solo un pixel, ya sea a la izquierda o a la
                                    derecha, ya sea arriba o abajo (penúltimo y último parámetros respectivamente)
                                    usaremos valores +1 y -1.
                                </li>
                                <li>Se ha añadido un bloque vacío antes de definir nuestro sprite, al final del código
                                    anterior; esto es así porque debemos asegurarnos de que haya un bloque en blanco
                                    encima de cada columna (manías del ensamblador generado por Sprite Pack).
                                </li>

                            </ul>

                            <table border="0" cellspacing="0" cellpadding="2" width="640">
                                <tr align="right">
                                    <td><img src="img/z88dk8_3.png" width="640" height="504"
                                             alt="El terrible ser intergaláctico se ha hecho mayor y es más nervioso que antes..."/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">El terrible ser intergaláctico se ha hecho mayor y
                                        es más nervioso que antes...
                                    </td>
                                </tr>

                            </table>

                            <p><b>¿Y AHORA QUÉ?</b></p>
                            <p>Hemos aprendido las más básicas funcionalidades de Sprite Pack para la creación de
                                sprites. Ya somos capaces de crear nuestros propios sprites (de forma más sencilla a la
                                que se ha realizado en artículos anteriores) y de moverlos, aunque sea de manera
                                aleatoria, por la pantalla (sin necesidad de hacer llamadas de ensamblador para el
                                manejo de interrupciones, como en el ejemplo de los coches visto en el número anterior
                                de MagazineZX). Por lo tanto, ganamos en facilidad de uso.</p>
                            <p>Vemos que no es necesario borrar un sprite usando la máscara XOR antes de volver a
                                dibujarlo para simular movimiento, tal como hacíamos con z88dk sin Sprite Pack, y
                                también observamos como somos capaces de añadir transparencias en los sprites de forma
                                muy simple. Volvemos a ganar en facilidad de uso.</p>
                            <p>En el siguiente artículo añadiremos colores a nuestros sprites y aprenderemos a moverlos
                                con el teclado. También veremos como borrar de forma efectiva un sprite. Si el espacio
                                lo permite (y si no es así, que no cunda el pánico, pues se verá en números posteriores
                                de la revista) codificaremos un simple juego funcional con todo lo aprendido.</p>
                            <b>LINKS</b>
                            </p>
                            <ul>
                                <li><a href="src/z88dk8_codigo.tar.gz" onClick="window.open(this.href); return false;">Código
                                    fuente</a></li>

                            </ul>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td align="right"><br><br>SIEW</td>
                </tr>
            </table>
        </td>
    </tr>

    <tr>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarPie(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('el-aventurero.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">

                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>
                                <option value="al-descubierto.html">Al Descubierto</option>
                                <option value="el-aventurero.html">El Aventurero</option>

                                <option value="z88dk.html" selected>Programación Z88DK</option>
                                <option value="input.html">INPUT</option>
                                <option value="ensamblador.html">Programación Ensamblador</option>
                                <option value="rem.html">REM</option>
                                <option value="opinion.html">Opinión</option>
                            </select>

                            <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                        </td>
                        <td align="right" class="texto">
                            <a href="#arriba">Volver arriba</a>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>

                </form>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
                <tr align="center" valign="center">
                    <td>2003-2009 Magazine ZX</td>

                </tr>
            </table>
            <script type="text/javascript">
              var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
              document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
            </script>
            <script type="text/javascript">
              try {
                var pageTracker = _gat._getTracker("UA-8018503-4");
                pageTracker._trackPageview();
              } catch (err) {
              }</script>
        </td>
    </tr>
</table>

</body>

</html>
