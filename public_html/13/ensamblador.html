<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
    <head>
        <title>Magazine ZX</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
        <link rel="shortcut icon" href="favicon.ico">
        <link rel="stylesheet" href="../css/magazine.css" type="text/css">
    </head>
    <body bgcolor="#CFCFCF">

        <center>
            <table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
                <tr>
                    <td>
<a name="arriba"></a>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
	<tr align="center" valign="center">
		<td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0" /></a></td>
	</tr>
</table>
                    </td>

                </tr>
                <tr>
                    <td>
<script language="JavaScript">
function RecargarCabecera(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">
        <tr><td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>

        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('input.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
        <option value="index.html">Portada</option>
        <option value="editorial.html">Índice - Editorial</option>
        <option value="panorama.html">Panorama</option>
        <option value="analisis.html">Análisis</option>

        <option value="al-descubierto.html">Al Descubierto</option>
        <option value="el-aventurero.html">El Aventurero</option>
        <option value="z88dk.html">Programación Z88DK</option>
        <option value="input.html">INPUT</option>
        <option value="ensamblador.html" selected>Programación Ensamblador</option>
        <option value="rem.html">REM</option>

        <option value="opinion.html">Opinión</option>
    </select>
    <input type="button" onclick="RecargarCabecera('rem.html');" name="siguiente" value=">" />
</td>
            <td align="center" class="texto">Número 13 - Enero 2006</td>
            <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX" onClick="window.open(this.href); return false;"><img src="http://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0" alt="ZX Certified webmaster"></a>&nbsp;<a href="http://www.speccy.org/" onClick="window.open(this.href); return false;"><img src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a></td>
        </tr>
    </form>

</table>
</a>
                    </td>
                </tr>
                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td>
<table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
    <tr>
        <td>

<div align="justify">
<p align="center"><font size="5">Arquitectura y funcionamiento del Spectrum</font></p>
<p><strong>LA ARQUITECTURA DEL SPECTRUM</strong></p>
<p>Antes de comenzar a programar el Spectrum necesitamos conocer su arquitectura: ¿qué hay dentro de nuestro pequeño ordenador y cómo funciona? En BASIC muchas veces podemos olvidarnos de los detalles a nivel de hardware (para eso es un lenguaje de Alto Nivel), pero en ensamblador no: al hablar directamente un lenguaje que se traduce a código máquina, necesitamos conocer exactamente cómo funciona internamente.</p>
<p>Aquí veremos una visión simplificada de la arquitectura hardware del Spectrum pero que en el fondo es todo lo que necesitaremos para la mayoría de programas. Para empezar veremos un esquema de cómo es internamente nuestro Spectrum a nivel de hardware, y después comentaremos uno a uno los elementos que lo componen:</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="500">
	<tr align="right">
		<td><img src="img/esquema_zx.gif" width="500" height="400"  alt="Esquema del hardware de un ZX Spectrum" />
</td>
	</tr>

	<tr>
		<td class="piefoto" align="right">Esquema del hardware de un ZX Spectrum</td>
	</tr>
</table>
</center>
<p>En un vistazo general, podemos ver que el microprocesador Z80 se conecta mediante los puertos de entrada/salida de la CPU a los periféricos externos (teclado, cassette y altavoz de audio), pudiendo leer el estado de los mismos (leer del teclado, leer del cassette) y escribir en ellos (escribir en el altavoz para reproducir sonido, escribir en el cassette) por medio de estas conexiones conocidas como "I/O Ports".</p>
<p>Al mismo tiempo, los Buses de Datos y de Direcciones conectan al microprocesador con la memoria. Esta conexión es la que permite que el Z80 pueda leer y escribir en cualquier posición de la memoria. Cuando encendemos el Spectrum, lo que éste lee de la memoria son instrucciones. Empezando por la posición 0000 (0 Kb), el Spectrum comienza a leer instrucciones y a ejecutarlas, una a una. En la primera parte de la memoria tenemos la ROM del Spectrum, que contiene instrucciones de programa preprogramadas y que no podemos modificar: es el menú del Spectrum y el intérprete de BASIC.</p>
<p>Por otro lado, nuestro microprocesador tiene una serie de registros internos con los que trabaja y que son los que manipula y utiliza para ejecutar las instrucciones almacenadas en la memoria.</p>
<p>Algo muy importante sobre la memoria es que hay una zona de ella que se conoce como videomemoria. Es memoria RAM normal y corriente, sólo que los datos que contiene son leídos por un chip llamado ULA muchas veces por segundo, y conforman la imagen que vemos en el televisor de nuestro Spectrum. Escribiendo un valor en una de estas direcciones de memoria (poniendo a 1 uno de sus bits), veremos aparecer en el televisor un punto. La ULA es, pues, el chip encargado de representar en el televisor el contenido de la videomemoria y nosotros, cuando queramos escribir o dibujar algo en pantalla, ya no utilizaremos funciones como PLOT o DRAW, sino que escribiremos directamente valores en esta zona de memoria.</p>

<p>Por último, el puerto de expansión del Spectrum permite conectar nuevos periféricos (como el adaptador de Joystick Kempston o el Interface 1 ó 2) directamente a las patillas de la CPU, ampliando las funcionalidades del ordenador.</p>
<p>Veamos más detalladamente los diferentes componentes de la arquitectura del Spectrum, y cómo funcionan.</p>
<p><strong>EL MICROPROCESADOR Z80</strong></p>
<p>Como podemos distinguir en el esquema, el cerebro de nuestro Spectrum es un microprocesador Zilog Z80 a 3,54Mhz. Un microprocesador es un circuito integrado que consta (principalmente) de registros, microcódigo, puertos de entrada/salida, un bus de datos y uno de direcciones.</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="400">
	<tr align="right">
		<td><img src="img/Z80.jpg" width="400" height="227"  alt="Imagen de un C.I. Z80 de Zilog" />
</td>
	</tr>

	<tr>
		<td class="piefoto" align="right">Imagen de un C.I. Z80 de Zilog</td>
	</tr>
</table>
</center>
<p>Los registros son variables (igual que cualquier variable de BASIC) que residen dentro de la misma CPU. En el caso del Z80, tiene 2 juegos de registros con unos nombres concretos: entre otros, lo forman registros de un byte como A, F, B, C, D, E, H, L, I y R, y los registros de dos bytes IX, IY, SP y PC. Veremos los registros en detalle en su momento (así como el segundo juego de registros disponible), pero podemos hacernos a la idea de que los registros son simples variables de 8 ó 16 bits que utilizaremos en nuestros programas en ensamblador. Así, podremos cargar un valor en un registro (LD A, 25), sumar un registro con otro (ADD A, B), activar o desactivar determinados bits de un registro (SET 7,A), etc.</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="510">
	<tr align="right">
		<td><img src="img/debugger1.gif" width="510" height="458"  alt="Parte del debugger de FUSE mostrando los registros de la CPU" />

</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Parte del debugger de FUSE mostrando los registros de la CPU</td>
	</tr>
</table>
</center>
<p>El juego de registros es todo lo que tenemos (aparte de la memoria) para realizar operaciones en nuestro programa: siempre que estemos operando con datos o utilizando variables, tendrá que ser por fuerza un registro, o una posición de memoria que usemos como variable. Por ejemplo, podemos escribir el siguiente programa en ensamblador, que sumaría dos números:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">

<pre>
  LD A, 10
  LD B, 20
  ADD A, B
</pre>
    </p></td></tr>
</table>
<p>El anterior programa, una vez ensamblado y ejecutado en un Z80, vendría a decir:</p>
<ul>
	<li>Carga en el registro A el valor "10".</li>
	<li>Carga en el registro B el valor "20".</li>
	<li>Suma el valor del registro A con el del registro B y deja el resultado en el registro A (A=A+B).</li>

</ul>
<p>Tras ejecutar el anterior programa en un Z80, el contenido del registro A sería 30 (10+20). Cuando comencemos a explicar las diferentes instrucciones del Z80 veremos en más detalle los registros, su tamaño, cómo se agrupan, y de qué forma podemos usarlos para operar entre ellos y realizar nuestras rutinas o programas.</p>
<p>Existe un registro especial llamado PC (Program Counter, o Contador de Programa). Este registro de 16 bits puede contener un valor entre 0 y 65535, y su utilidad es la de apuntar a la dirección de memoria de la siguiente instrucción a ejecutar. Así, cuando arrancamos nuestro Spectrum, el registro PC vale 0000h, con lo que lo primero que se ejecuta en el Spectrum es el código que hay en 0000. Una vez leído y ejecutado ese primer código de instrucción, se incrementa PC para apuntar al siguiente, y así continuadamente. Los programas se ejecutan linealmente mediante (como veremos) un ciclo basado en: Leer instrucción en la dirección de memoria apuntada por PC, incrementar registro PC, ejecutar instrucción. Posteriormente veremos más acerca de PC.</p>
<p>Ya hemos visto lo que son los registros del microprocesador. Ahora bien, en el ejemplo anterior, ¿cómo sabe el microprocesador qué tiene que hacer cuando se encuentra un comando "LD" o "ADD"? Esto es tarea del microcódigo. El microcódigo del microprocesador es una definición de qué tiene que hacer el microprocesador ante cada una de las posibles órdenes que nosotros le demos.</p>
<p>Por ejemplo, cuando el microprocesador está ejecutando nuestro anterior programa y lee "LD A, 10" (en realidad, lee de la memoria los opcodes 62 y 10), el Z80 utiliza el microcódigo encargado de mover el valor 10 al registro A. Este microcódigo no es más que una secuencia de señales hardware y cambios de estados electrónicos cuyo resultado será, exactamente, activar y desactivar BITs en el registro A (que no es más que una serie de 8 biestables electrónicos que pueden estar a 0 voltios o a 5 voltios cada uno de ellos, representando el estado de los 8 bits del registro A). Lo mismo ocurrirá cuando se lea la instrucción "LD B, 20", sólo que se ejecutará otra porción de microcódigo que lo que hará será modificar el registro B.</p>
<p>Este microcódigo está dentro del microprocesador porque sus diseñadores implementaron todas y cada una de las operaciones que puede hacer el Z80. Cuando pedimos meter un valor en un registro, leer el valor de un registro, sumar un registro con otro, escribir el valor de un registro en una dirección de memoria, saltar a otra parte del programa, etc, para cada una de esas situaciones, hay un microcódigo (implementado mediante hardware) que realiza esa tarea. Nosotros no tendremos que preocuparnos pues de cómo hace el Z80 las cosas internamente a nivel de microcódigo, aunque es bueno que conozcáis cómo llega el Spectrum a ejecutar nuestros comandos: gracias al microcódigo.</p>
<p><strong>PUERTOS DE ENTRADA/SALIDA</strong></p>
<p>Si cogemos un microprocesador Z80, podremos distinguir muchas patillas de conexión. Además de las patillas que se utilizan para alimentar el Z80 desde la fuente de alimentación, existen otra serie de patillas para "Puertos de Entrada/Salida" y "Bus de datos y de direcciones". Esas patillas son la conexión del microprocesador con el resto de elementos del ordenador.</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="325">

	<tr align="right">
		<td><img src="img/pinout.gif" width="325" height="453"  alt="Las 40 patillas del microprocesador Z80. donde vemos el bus de direcciones (A0 a A15) y el bus de datos (D0 a D7), que se conectan a los puertos de entrada/salida y a la memoria" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Las 40 patillas del microprocesador Z80. donde vemos el bus de direcciones (A0 a A15) y el bus de datos (D0 a D7), que se conectan a los puertos de entrada/salida y a la memoria</td>
	</tr>
</table>
</center>
<p>Los registros del microprocesador y el microcódigo son internos al procesador, y ninguna de las patillas que podemos ver en la imagen anterior nos comunica con ellos. Es el procesador (internamente) quien lee/modifica los registros o quien ejecuta microcódigo cuando nosotros se lo decimos con las instrucciones de nuestro programa.</p>

<p>Pero nuestro procesador, como hemos dicho, necesita conectarse con elementos del exterior, entre ellos (y casi exclusivamente en el caso del Spectrum) tenemos la memoria, el teclado, el altavoz y la unidad de cinta.</p>
<p>Visto de un modo muy simple, el Z80 puede acceder a través de una serie de patillas hasta a 65536 elementos externos. Esos elementos se conectan a la CPU Z80 a través de las patillas de "Buses de datos y direcciones" (que podemos leer en los puertos de Entrada/Salida). Una vez conectados (la conexión se realiza físicamente a nivel de hardware, con pistas en la placa base), el microprocesador Z80 puede leer los valores que el dispositivo pone en esas pistas, o puede escribir valores en esas pistas para que el dispositivo los utilice.</p>
<p>Supongamos el ejemplo del teclado: un teclado es (a un nivel muy simple) una matriz de pulsadores. Al final de toda esa matriz de pulsadores, lo que acabamos teniendo es un número de 8 bits (0-255) cuyos bits nos dicen la teclas pulsadas. Pues bien, ese número de 8 bits es lo que el mismo teclado pone en los "cables" que lo unen con el Z80. El teclado se conecta a la CPU mediante una conexión a uno de los puertos (una serie de patillas de datos y direcciones) del microprocesador y gracias a esto el microprocesador (y nuestro programa) puede leer en todo momento el estado del teclado (y saber qué teclas están pulsadas y cuales no) leyendo del puerto correspondiente.</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="567">
	<tr align="right">
		<td><img src="img/teclado.jpg" width="567" height="349"  alt="Matriz de teclado del Spectrum y conexiones al Z80" />
</td>
	</tr>
	<tr>

		<td class="piefoto" align="right">Matriz de teclado del Spectrum y conexiones al Z80</td>
	</tr>
</table>
</center>
<p>Así, en nuestros programas podemos leer el estado del teclado mediante (por ejemplo):</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
5  REM Mostrando el estado de la fila 1-5 del teclado
10 LET puerto=63486
20 LET V=IN puerto: PRINT AT 20,0; V ; "  " : GO TO 20
</pre>
    </p></td></tr>

</table>
<p>Este ejemplo lee (en un bucle infinito) una de las diferentes filas del teclado, mediante la lectura del puerto 63486 (F7FEh) con la instrucción de lectura de puertos de BASIC "IN". El estado de las 5 teclas desde el 1 hasta el 5 del teclado del Spectrum está conectado a 5 "hilos" de los 8 que llegan al puerto 63486 del micro Z80. Cuando se pulsa una tecla, el teclado pone a 0 (a 0 voltios) el "hilo" correspondiente de esos 8, y nosotros podemos conocer el estado de la tecla leyendo dicho puerto y mirando el bit en cuestión. Al ejecutar el ejemplo anterior, veremos que la pulsación de la tecla "1" cambiará el valor que aparece en pantalla. Si pasamos los diferentes valores que aparecen a binario y nos fijamos en el estado de los 5 últimos bits, nos daremos cuenta como al pulsar y soltar las diferentes teclas del 1 al 5 estaremos variando esos bits entre 0 (al pulsarlas) y 1 (al liberarlas). Los 3 bits más altos del byte debemos ignorarlos, ya que no tienen relación con el teclado.</p>
<p>Si no hay ninguna tecla pulsada, los 5 bits más bajos del byte que hay en el puerto estarán todos a 1, mientras que si se pulsa alguna de las teclas del 1 al 5, el bit correspondiente a dicha tecla pasará a estado 0. Nosotros podemos leer el estado del puerto y saber, mirando los unos y los ceros, si las teclas están pulsadas o no.</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="320">
	<tr align="right">
		<td><img src="img/leer_teclado.gif" width="320" height="240"  alt="Pulsando "1", ponemos a 0 el bit 0, pasando de 191 a 190" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Pulsando "1", ponemos a 0 el bit 0, pasando de 191 a 190</td>

	</tr>
</table>
</center>
<p>Así, leyendo del puerto 63486 obtenemos un byte cuyos 8 bits tienen como significado el estado de cada una de las teclas de la semifila del "1" al "5".</p>
<table>
	<tr>
		<th style="border-bottom: 1px solid #000;">Bits</th><td style="border-bottom: 1px solid #000;">D7</td><td style="border-bottom: 1px solid #000;">D6</td><td style="border-bottom: 1px solid #000;">D5</td><td style="border-bottom: 1px solid #000;">D4</td><td style="border-bottom: 1px solid #000;">D3</td><td style="border-bottom: 1px solid #000;">D2</td><td style="border-bottom: 1px solid #000;">D1</td><td style="border-bottom: 1px solid #000;">D0</td>

	</tr>
	<tr>
		<th>Teclas</th><td>XX</td><td>XX</td><td>XX</td><td>"5"</td><td>"4"</td><td>"3"</td><td>"2"</td><td>"1"</td>
	</tr>

</table>
<p>Los bits D7 a D5 no nos interesan en el caso del teclado (por ejemplo, D6 tiene relación con la unidad de cinta), mientras que los bits de D5 a D0 son bits de teclas (0=pulsada, 1=no pulsada). Tenemos pues el teclado dividido en filas de teclas y disponemos de una serie de puertos para leer el estado de todas ellas:</p>
<table>
	<tr><th style="border-bottom: 1px solid #000;">Puerto</th><th style="border-bottom: 1px solid #000;">Teclas</th></tr>
	<tr><td>65278d (FEFEh)</td><td>de CAPS SHIFT a V</tr>
	<tr><td>65022d (FDFEh)</td><td>de A a G</tr>
	<tr><td>64510d (FBFEh)</td><td>de Q a T</tr>

	<tr><td>63486d (F7FEh)</td><td>de 1 a 5 (and JOYSTICK 1)</tr>
	<tr><td>61438d (EFFEh)</td><td>de 6 a 0 (and JOYSTICK 2)</tr>
	<tr><td>57342d (DFFEh)</td><td>de P a Y</tr>
	<tr><td>49150d (BFFEh)</td><td>de ENTER a H</tr>
	<tr><td>32766d (7FFEh)</td><td>de (space) a B</tr>

</table>
<p>A la hora de leer estos puertos, el bit menos significativo (D0) siempre hace referencia a la tecla más alejada del centro del teclado ("1" en nuestro ejemplo), mientras que el más significativo de los 5 (D5) lo hace a la tecla más cercana al centro del teclado.</p>
<p>En ensamblador también hay disponibles 2 instrucciones para leer el contenido de un puerto de Entrada/Salida y para escribir un valor en un puerto determinado, las instrucciones se llaman igual que en BASIC: IN y OUT:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 ; Cargamos en BC el valor del puerto a leer
 LD BC, F7FEh

 ; Leemos en el registro A el valor del puerto
 IN A, (C)
</pre>
    </p></td></tr>
</table>
<p>Queríamos mostraros el ejemplo del teclado, aunque estamos todavía empezando y puede haber sido algo complicado de entender, por diferentes motivos:</p>

<ul>
	<li>El primero, explicar qué son los puertos de E/S y cómo están conectados a nivel de hardware con el microprocesador. Como habéis visto, del teclado salen una serie de "hilos" o pistas de circuito impreso que van directamente al Z80, a través de sus diferentes buses y puertos.</li>
	<li>Nosotros podemos, en cualquier momento, leer y escribir en los puertos de E/S. Con esto conseguimos comunicarnos con los periféricos externos. En este caso, podemos leer del teclado (o escribir o leer del cassette, o en el altavoz) con simples operaciones de lectura y escritura.</li>
</ul>
<p>El lector debería extraer una conclusión extra del ejemplo del teclado: la gran diferencia de proceso que hay entre programar en ensamblador y programar en BASIC. Supongamos que nos interesa leer el estado del teclado para saber si unas determinadas teclas están pulsadas o no. Para esto, en ensamblador (aunque esto también podemos hacerlo en BASIC) leemos directamente el estado del teclado con un par de simples instrucciones (LD + IN). En BASIC, por contra al leer de un INKEY$ estamos esperando la ejecución de un código que, además de leer TODAS las filas del teclado (no sólo aquellas de las teclas que nos interesen), realiza una conversión de todos los bits pulsados o no pulsados mediante una tabla ASCII para al final proporcionarnos el código ASCII de la tecla pulsada. Lo que son varias simples instrucciones IN en ASM, en BASIC se realiza mediante cientos de instrucciones en ensamblador que nos acaban dando la última tecla pulsada. Es por eso que el intérprete BASIC es tan lento: cada operación BASIC son decenas, cientos o miles de instrucciones en ensamblador que nosotros ni vemos ni controlamos. Programando directamente en ASM, el microprocesador hara EXCLUSIVAMENTE lo que nosotros le digamos que haga. He aquí la "mágica" diferencia de velocidad entre ambos lenguajes.</p>
<p>Podéis encontrar más información sobre los puertos de Entrada y Salida en el capítulo 8 sección 32 del manual del +2A y +3, que tenéis disponible online en World Of Spectrum.</p>
<p><strong>MEMORIA</strong></p>
<p>Al igual que en el caso de los puertos de entrada/salida, nuestro microprocesador está también conectado a los diferentes chips de memoria (hay más de uno). La conexión se realiza siguiendo unas normas definidas por los ingenieros de Sinclair, de tal forma que la memoria se mapea linealmente. ¿Qué quiere decir esto? Que aunque tengamos varios chips de memoria, vemos la memoria como una gran y única memoria de 64KB.</p>
<p>El Spectrum básico (48KB de RAM y 16KB de ROM) tiene disponibles 64KB de memoria, es decir, 65536 bytes a los cuales podemos acceder. Podemos pensar en esta memoria como un gran baúl con 65536 cajones, uno encima de otro. El primer cajón es el cajón 0 (posición de memoria 0), el segundo el cajón 1 (posición de memoria 1), y así hasta el cajón 65535 (posición de memoria 65535).</p>

<p>Nuestro Spectrum no puede tener más de 65536 cajones porque el "bus de direcciones" del microprocesador Z80 es de 16 bits, es decir, las líneas que conectan al microprocesador con la memoria sólo permiten 16 "conexiones"; lo que nos da la posibilidad de acceder a 2 elevado a 16 bytes de memoria, exactamente 65536 bytes.</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="400">
	<tr align="right">
		<td><img src="img/memoria.gif" width="400" height="300"  alt="Aspecto de nuestras 65536 celdillas de memoria" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">Aspecto de nuestras 65536 celdillas de memoria</td>
	</tr>

</table>
</center>
<p>Cada uno de estos cajones (más técnicamente, "celdillas de memoria" o "posiciones de memoria") puede contener un número de 8 bits, con un valor, por tanto, entre 0 y 255. Esto es así porque el "bus de datos" del microprocesador Z80 es de 8 bits, lo que implica que "sólo hay 8 conexiones" entre la salida de datos de la memoria y nuestro procesador.</p>
<p>El microprocesador Z80 puede acceder a cualquier posición de memoria tanto para leer como para escribir. Internamente, cuando le pedimos al microprocesador que meta en el registro A el contenido de la celdilla de memoria 1234h, mediante una instrucción de ensamblador "LD A, (1234h)" (nota, el operador () en ensamblador significa acceso a memoria, y equivaldría en este caso a un "LET A=PEEK 4660" en BASIC) lo que hace el microprocesador internamente es:</p>
<p><em>Ejecución de LD A, (1234h):</em></p>
<ul>
	<li>1234h en binario es 00010010 00110100, de modo que el Z80 coge las 16 líneas que conectan al microprocesador con la memoria y las pone a esos estados (0 = 0 voltios, 1 = 5 voltios).</li>
	<li>A continuación, el microprocesador utiliza una conexión especial que le conecta con la memoria donde le indica qué operación quiere realizar. Poniendo al valor apropiado la línea de control que le comunica con la memoria, el Z80 informa al chip de memoria de que quiere realizar una operación de lectura.</li>
	<li>La memoria recibe la señal de "quiero leer un dato" por esta señal de control, y mira el bus de direcciones que le conecta con el Spectrum. Mirando el estado de las 16 líneas encuentra el "00010010 00110100" (1234h). Con eso, la memoria sabe a qué "casilla" o "cajón" quiere acceder el microprocesador.</li>

	<li>La memoria lee el valor de la celdilla de memoria 1234h (por ejemplo 0Fh, que es 00001111 en binario) y cambia las 8 conexiones del Bus de Datos para que contengan 00001111 (4 "líneas" las pone a 0 voltios, y las otras 4 a 5 voltios).</li>
	<li>El Z80 consulta el bus de datos y ve el estado de las líneas, con lo que lee el "00001111" o 0Fh.</li>
	<li>El Z80 coloca en el registro A el valor 0Fh.</li>
</ul>
<p>El procedimiento para escribir es similar, salvo que la línea de control entre el Z80 y la memoria en lugar de indicar "lectura" indica "escritura", y que es el Z80 quien pone en el bus de datos el valor que quiere escribir en la celdilla indicada en el bus de direcciones:</p>
<p><em>Ejecución de LD (1234h), A</em></p>
<ul>
	<li>Supongamos que A contiene el valor 15 (0Fh): el Z80 coloca las líneas del bus de datos a los valores 00001111.</li>

	<li>El Z80 coloca las líneas del bus de direcciones a 00010010 00110100 (1234h).</li>
	<li>A continuación, el microprocesador pone la línea de control READ/WRITE a tal valor que la memoria sabe que el micro le pide una operación de escritura.</li>
	<li>La memoria recibe la señal de "quiero escribir un dato", y mira el bus de direcciones que le conecta con el Spectrum. Mirando el estado de las 16 líneas encuentra el "00010010 00110100" (1234h). Con eso, la memoria sabe a qué "casilla" o "cajón" quiere acceder el microprocesador para escribir.</li>
	<li>La memoria lee el valor del bus de datos para saber qué dato tiene que escribir.</li>
	<li>La memoria escribe en su cajón número 1234h el valor 0Fh.</li>
</ul>
<p>Estas son las 2 operaciones básicas que el Z80 puede realizar con la memoria: leer una posición de memoria y escribir en una posición de memoria. Nosotros no tenemos que preocuparnos de ninguna de las señales necesarias para realizar lecturas y escrituras, de eso se encarga el microprocesador. Para nosotros, a nivel de ensamblador, nos bastará con ejecutar "LD A, (1234h)" o "LD (1234h), A", por ejemplo.</p>

<p>Las celdillas desde la nº 0 a la 16383 están ocupadas por un chip que es la ROM del Spectrum. Este chip es de sólo lectura (ROM = Read Only Memory), lo cual quiere decir que si intentamos escribir en las celdillas desde la 0 a la 16383 no conseguiremos cambiar el valor almacenado en ellas. ¿Por qué no se puede escribir aquí? Porque es la ROM del Spectrum, es un chip que contiene el sistema operativo del Spectrum, su intérprete BASIC, como veremos posteriormente.</p>
<center>
<table border="0" cellspacing="0" cellpadding="2" width="200">
	<tr align="right">
		<td><img src="img/romram.gif" width="200" height="300"  alt="ROM y RAM" />
</td>
	</tr>
	<tr>
		<td class="piefoto" align="right">ROM y RAM</td>
	</tr>

</table>
</center>
<p>Para trabajar (ejecutar programas, realizar operaciones y tareas) podemos utilizar el resto de la memoria. Desde el cajón o celdilla número 16384 hasta el 65535 podremos escribir y leer.</p>
<p>La memoria RAM (celdillas 16384 a 65536) es muy importante para el Spectrum. Para empezar, en ella es donde se almacenan los datos y donde se cargan los programas, y de ella es de donde lee el microprocesador estos programas (como veremos posteriormente) para ejecutarlos instrucción a instrucción. Cuando en nuestra anterior entrega del curso pokeamos la rutina en código máquina en la dirección 40000, estabamos escribiendo un programa en memoria para después ejecutarlo.</p>
<p>Hay una parte de la memoria RAM que es especial. El trozo de 6912 bytes que va desde la dirección 16384 hasta la 23296 es conocida como VideoRAM. Esta porción de la memoria no se utiliza para almacenar programas ni datos, sino que es una representación numérica de los gráficos que aparecen en nuestro televisor. La ULA (un chip que hay dentro de nuestro Spectrum) lee continuamente esta zona de memoria y transforma los unos y ceros que en ella encuentra en puntos y colores en el televisor.</p>
<p>Visto de una manera simple (pero real): al escribir un valor numérico (por ejemplo un 1) en alguna dirección de esta parte de la RAM, de forma inmediata aparece un punto en nuestro televisor, ya que la ULA está continuamente "escaneando" la videoram (de forma independiente del Z80) para reflejar en el televisor todos los valores numéricos que introduzcamos en ella.</p>
<p>Por ejemplo, el siguiente programa pinta 2 píxeles en el centro de la pantalla escribiendo en la videomemoria:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
10 REM Pintando 2 pixeles en pantalla mediante POKE
20 LET DIRECCION= 16384 + 2000
25 REM 129 = 10000001
30 POKE DIRECCION, 129
40 PAUSE 0

</pre>
    </p></td></tr>
</table>
<p>Si ejecutamos el programa, veremos 2 puntos en el centro de la pantalla. Estos 2 puntos aparecen al escribir el byte de valor 129 en la dirección 18384. El número 129, en binario, es 10000001. Esos 2 unos son los que se convierten en 2 puntos cuando la ULA lee la videomemoria y transforma los unos en colores de tinta y los ceros en papel.</p>
<p>Lo que nos tiene que quedar claro al respecto de la memoria es lo siguiente:</p>
<ul>
	<li>El microprocesador puede acceder a la memoria tanto para leer como para escribir, y lo hará cuando nosotros se lo pidamos (para leer o escribir datos en memoria). También lo hará para leer las instrucciones a ejecutar, como veremos posteriormente.</li>
	<li>La memoria está formada por la ROM, la VideoRAM y la RAM.</li>
 	<li>En la ROM no podemos escribir (pero sí leer). Almacena el "código" de arranque del Spectrum, así como el intérprete de BASIC. En ella existen rutinas que usa BASIC que podremos aprovechar en nuestros programas en ensamblador.</li>

 	<li>En la videoRAM sólo leeremos y escribiremos cuando queramos dibujar cosas en pantalla (puntos y colores).</li>
 	<li>En el resto de la RAM (a partir de la dirección 23296) es donde realizaremos todo el trabajo: allí situaremos nuestros programas, nuestras variables, datos, gráficos que después copiaremos a la videoRAM, etc.</li>
</ul>
<p><strong>EL PUERTO DE EXPANSIÓN</strong></p>
<p>El puerto de expansión del Spectrum no será importante en nuestro curso, ya que no lo utilizaremos para nada. Para vuestra información, basta con conocer que los diferentes pines del puerto de expansión de nuestro ZX están conectados directamente a diferentes patillas del microprocesador. Es decir, cada una de las líneas que podemos ver físicamente en el puerto de expansión es una pista de circuito (como si fuera un cable) que va directamente a alguna de las patillas del Z80.</p>
<p>Es por eso que mediante el puerto de expansión se puede implementar casi cualquier cosa hardware en el Spectrum sin tener que abrirlo: estamos conectando cosas directamente al micro y tras hacerlo, podemos realizar programas que accedan a esos elementos recién conectados: podemos leer los joysticks (porque los estamos conectando a puertos de Entrada/Salida mediante los buses de datos y direcciones), podemos leer cartuchos (porque "ocultamos" la memoria del Spectrum y la reemplazamos con otra memoria que contiene el juego ya cargado en ella, poniéndo esta memoria en el Bus de datos y Direcciones), etc.</p>
<p><strong>CÓMO FUNCIONA EL SPECTRUM</strong></p>
<p>Una vez hemos visto todas las partes funcionales, veamos cómo funciona el Spectrum a nivel de ciclo de instrucción.</p>

<p>Para empezar, los diferentes dispositivos externos (teclado, altavoz, cassette, elementos conectados al puerto de expansión, joysticks) se comunican con la CPU por medio de puertos de Entrada/Salida (Puertos E/S o I/O Ports). Para acceder a ellos simplemente leemos o escribimos en el puerto correspondiente mediante las instrucciones IN y OUT del Z80.</p>
<p>Por otra parte, nuestro Z80 puede leer y escribir de la memoria mediante instrucciones LD ("LD valor, (direccion)" y "LD (direccion), valor"), pudiendo utilizar también otro tipo de instrucciones para hacerlo (que veremos en su momento).</p>
<p>En realidad el Z80, visto de una forma simplificada, sólo puede hacer 3 cosas: leer/escribir en la memoria, leer/escribir en los dispositivos de Entrada/Salida y decodificar/ejecutar instrucciones. La parte de lectura/decodificación/ejecución es el funcionamiento principal del microprocesador, y es lo que trataremos a continuación.</p>
<p><strong>CICLO DE EJECUCIÓN DE UN SPECTRUM</strong></p>
<p>Como ya hemos visto, la parte central del Spectrum es un microprocesador Z80 el cual ve la ROM y la RAM de forma continuada como la totalidad de su memoria. Es decir, ve 64KB de memoria de los cuales los primeros 16K son el contenido de chip de ROM, y los siguientes 48K los del chip de RAM. Recordemos que el Spectrum puede leer el contenido de cualquiera de estas 65536 celdillas (así como escribir en ellas, pero sólo a partir de la 16384, ya que los primeros 16KB son de ROM).</p>
<p>Al encender el Spectrum éste se inicializa y muestra el BASIC en pantalla. ¿Por qué ocurre esto? Esto ocurre porque el microprocesador Z80 comienza a ejecutar instrucciones desde la dirección de memoria 0, donde está el principio de la ROM de 16K, es decir, el intérprete BASIC.</p>
<p>Al alimentar con corriente eléctrica el ordenador se ejecuta la ROM: al encender un Spectrum (que perdió en su apagado toda alimentación eléctrica) todos los registros del microprocesador Z80 valen 0 (sin alimentación eléctrica, todos los bits de la CPU están a 0 Voltios, es decir, a 0 lógico), incluído el registro PC (Program Counter o Contador de Programa), que es el que apunta a la siguiente instrucción que el Z80 debe leer y ejecutar. Un microprocesador funciona a grandes rasgos de la siguiente forma:</p>
<ul>
	<li>Leer instrucción apuntada por el registro PC.</li>

	<li>Incrementar PC para apuntar a la siguiente instrucción.</li>
	<li>Ejecutar la instrucción recién leída.</li>
	<li>Repetir continuadamente los 3 pasos anteriores.</li>
</ul>
<p>Visto en pseudocódigo, como si fuera un programa (de hecho, es el pseudocódigo de cualquier emulador de Spectrum), un Z80 actúa así:</p>
<ul>
	<li>
		Encendido de ordenador:
		<ul>

			<li>Todos los registros (A, B, C, ..., SP, PC) valen 0.</li>
		</ul>
	</li>
	<li>
 		Mientras No Se Apague el Ordenador:<br />
 		Leer de la memoria la siguiente instrucción, mediante (contenido de la dirección apuntada por PC):
 		<ul>
 			<li>Instruccion = [PC] (Instrucción es un opcode, un número que indica la operación a realizar. Podría ser de más de un byte.)</li>

 			<li>PC = PC + 1</li>
 			<li>Si la instrucción necesita algún operando, leerlo:
	 			<ul>
	 				<li>Operando1 = [PC]</li>
	 				<li>PC = PC + 1</li>
	 				<li>Operando2 = [PC]      (Opcional)</li>
	 				<li>PC = PC + 1           (Opcional)</li>

	 			</ul>
 			</li>
 			<li>Decodificar la instrucción (mirar en una tabla interna y ver qué microcódigo hay que ejecutar para la instrucción leída).</li>
 			<li>Ejecutar la instrucción</li>
 		</ul>
 		Fin Mientras
 	</li>
</ul>
<p>Así pues, al encender el ordenador, PC vale 0. Al estar la ROM mapeada en la posición de memoria 0 (mediante cableado hardware de los chips de memoria en la placa del Spectrum), lo que pasa al encender el ordenador es que ese contador de programa (PC) está apuntando al principio de la ROM, y es por eso que se ejecuta la ROM paso a paso, instrucción a instrucción, cada vez que lo encendemos. No hay misterio: para el Spectrum todos los chips de memoria de su interior (porque hay varios chips, no sólo 2) son como si fuera un gran baúl de 64KB continuados, algo que se consigue mediante cableado de los diferentes chips a las patillas correctas del microprocesador (como hemos visto en el apartado dedicado a la Memoria). A grandes rasgos, las patillas de datos y de direcciones del microprocesador están conectadas a los diferentes chips de memoria de forma que cuando el micro lee datos de la memoria, lo ve todo como si fuera un sólo chip de memoria de 64KB. Esto se consigue con un sencillo proceso de diseño (al hacer el esquema del ordenador antes de fabricarlo) conocido como "mapeado de memoria".</p>

<p>En el mapa de memoria del Spectrum, los primeros 16KB son la ROM (que está en un chip aparte, pero que como acabamos de ver es algo que el Spectrum no distingue, ya que la visualiza como una sección de memoria continua desde la posición 0 hasta la 16383 de su "baúl total" de 64KB) y luego viene la RAM, a partir de la posición 16384. Ahí es donde se almacenan los programas, los gráficos de la pantalla (en un trozo determinado de esa memoria), etc. En esta RAM es donde el intérprete de BASIC introduce los programas para su ejecución.</p>
<p>Estos programas pueden entrar desde los diferentes dispositivos de entrada/salida (gestionados por el Z80) como el teclado, la cinta o disco, etc.</p>
<p>Cabe hacer una mención especial (como ya hemos visto) a que una parte de la memoria RAM (desde el byte 16384 hasta el 23296) está conectada con la ULA, el chip "gráfico" del Spectrum, y encargado de convertir el contenido de esta "videoram" o VRAM a señales de vídeo para la televisión. Cuando los juegos dibujan gráficos, sprites o cualquier otra cosa en pantalla, en realidad están escribiendo bytes en estas posiciones de memoria, que la ULA muestra en la TV en el siguiente refresco de la pantalla.</p>
<p>Así pues, nuestro Z80 en el momento del arranque lo que hace es comenzar a ejecutar uno a uno los opcodes que hay a partir de la dirección 0000h de la memoria, que se corresponde con la ROM. ¿Y qué es la ROM? No es más que un programa realizado por la gente que creó el Spectrum. Ese programa es, entre otras cosas, el intérprete BASIC. Los señores de Sinclair programaron un intérprete BASIC en lenguaje ensamblador de Z80, lo ensamblaron con un ensamblador de Z80 y grabaron el código binario resultante ensamblado en un CHIP ROM de 16KB. Por eso al encender nuestro Spectrum aparece el intérprete de BASIC; el Sistema Operativo de nuestro ZX. Nada nos impediría realizar nuestro propio "sistema operativo" para Spectrum creando una ROM nueva (mirando siempre la compatibilidad con la ROM vieja, de forma que contenga las mismas rutinas de ROM y variables en memoria que utilizan muchos programas) y reemplazando el chip ROM del Spectrum por nuestro propio chip de ROM.</p>
<p><strong>OPCODES Y CÓDIGO MÁQUINA</strong></p>
<p>Nuestro microprocesador Z80 no entiende los comandos en ensamblador que hemos estado viendo en estos 2 primeros capítulos del curso de código máquina; el Z80 sólo entiende números binarios, números de 8 bits de 0 a 255 (o de 00h a FFh en hexadecimal).</p>
<p>De entre los registros del microprocesador hay uno llamado PC (Program Counter o Contador de Programa), que es el "puntero" que apunta a la instrucción actual que se está ejecutando. Cuando ejecutamos un programa, lo que hacemos es meterlo en memoria (por ejemplo, como cuando en la primera entrega del curso POKEábamos nuestra rutina a partir de la dirección 40.000) y después saltar al inicio del mismo.</p>
<p>Supongamos por ejemplo que pokeamos el siguiente programa en la dirección 40000:</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr><td><p class="codigo">
<pre>
 LD A, 0
 INC A
 LD B, $FFh
 INC B
 LD DE, $AABB
 RET
</pre>
    </p></td></tr>
</table>
<p>Si ensamblamos este programa obtendremos los siguientes números (técnicamente llamados "código máquina"):</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr><td><p class="codigo">
<pre>
 3e 00 3c 06 ff 04 11 bb aa c9
</pre>

    </p></td></tr>
</table>
<p>Al pokear en memoria estos valores, dejaremos la memoria así:</p>
<table>
	<tr><th style="border-bottom: 1px solid #000;">Dirección</th><th style="border-bottom: 1px solid #000;">Valor</th></tr>
	<tr><td>40000</td><td>3e</td></tr>
   	<tr><td>40001</td><td>00</td></tr>

   	<tr><td>40002</td><td>3c</td></tr>
   	<tr><td>40003</td><td>06</td></tr>
   	<tr><td>40004</td><td>ff</td></tr>
   	<tr><td>40005</td><td>04</td></tr>
   	<tr><td>40006</td><td>11</td></tr>

   	<tr><td>40007</td><td>bb</td></tr>
   	<tr><td>40008</td><td>aa</td></tr>
   	<tr><td>40009</td><td>c9</td></tr>
</table>
<p>Para nosotros estos números no quieren decir nada, pero para el Spectrum tienen un total significado. Concretamente:</p>
<table>
	<tr><th style="border-bottom: 1px solid #000;">Dirección</th><th style="border-bottom: 1px solid #000;">Valor</th><th style="border-bottom: 1px solid #000;">Significado</th></tr>

	<tr><td>40000</td><td>3e</td><td>LD A,</td></tr>
   	<tr><td>40001</td><td>00</td><td>00h</td></tr>
   	<tr><td>40002</td><td>3c</td><td>INC A</td></tr>
   	<tr><td>40003</td><td>06</td><td>LD B,</td></tr>

   	<tr><td>40004</td><td>ff</td><td>FFh</td></tr>
   	<tr><td>40005</td><td>04</td><td>INC B</td></tr>
   	<tr><td>40006</td><td>11</td><td>LD DE,</td></tr>
   	<tr><td>40007</td><td>bb</td><td>BBh</td></tr>

   	<tr><td>40008</td><td>aa</td><td>AAh</td></tr>
   	<tr><td>40009</td><td>c9</td><td>RET</td></tr>
</table>
<p>A la hora de ejecutar el programa, nuestro RANDOMIZE USR 40000 lo que hace en realidad es cambiar el valor del registro "PC" del microprocesador. Hace PC igual a 40000. Así, el "bucle" del programa que hemos visto arriba en pseudocódigo lo que hace es:</p>
<ul>
	<li>Leer el byte contenido en la dirección de memoria "PC" (40000).</li>

	<li>Incrementar PC (PC=PC+1).</li>
	<li>El byte es "3eh", con lo cual el Spectrum sabe que tiene que meter en A un valor numérico.</li>
	<li>El valor extra para "LD A," está a continuación en memoria, así que se lee la memoria de nuevo:
	<ul>
		<li>operando = [PC] = 00h</li>
		<li>Incrementar PC (PC=PC+1)</l>
	</ul>

	</li>
	<li>Ya se tiene el "código de instrucción completo", así que se ejecuta: "LD A, 00". (se ejecuta el microcódigo correspondiente dentro de la CPU).</li>
</ul>
<p>Esto que hemos visto es el proceso de "Lectura de Instrucción (fetch)", "decodificación (decode)", y "ejecución (execute)". Pero recordemos que este proceso se ejecuta una y otra vez, sin parar, de modo que el procesador sigue con la siguiente instrucción (INC A):</p>
<ul>
	<li>Leer el byte contenido en la dirección de memoria "PC" (40002).</li>
	<li>Incrementar PC (PC=PC+1).</li>
	<li>El byte es "3ch", con lo cual el Spectrum sabe que tiene que incrementar A.</li>

	<li>No hacen falta operandos extra, INC A no requiere nada más.</li>
	<li>Ya se tiene el "código de instrucción completo", así que se ejecuta: "INC A".</li>
</ul>
<p>Y este ciclo se vuelve a repetir, una y otra vez, hasta que llegamos al RET:</p>
<ul>
	<li>Leer el byte contenido en la dirección de memoria "PC" (40009).</li>
	<li>Incrementar PC (PC=PC+1).</li>
	<li>El byte es "c9h", con lo cual el Spectrum sabe que tiene que hacer un RET.</li>

	<li>No hacen falta operandos extra, RET no requiere nada más.</li>
	<li>Ya se tiene el "código de instrucción completo", así que se ejecuta: "RET".</li>
</ul>
<p>Un par de detalles a tener en cuenta:</p>
<ul>
	<li>Como véis, el microprocesador no entiende el lenguaje ensamblador, sólo la traducción de este a Lenguaje Máquina (los números u opcodes que estamos viendo).</li>
	<li>La primera parte leída de la instrucción es el OPCODE (código de operación), y es lo que permite al Spectrum, mediante una "tabla interna", saber qué tarea exacta tiene que realizar. Si la instrucción necesita datos extra para leer de memoria, se almacenan tras el opcode, y se conocen como "operandos". Así, "LD A, 00" se corresponde con la instrucción "3E 00", donde "3E" es el código de operación (opcode) y "00" es el operando.</li>
	<li>Cuando un operando es de 16 bits (2 bytes), primero encontramos el byte bajo y luego el byte alto. Así, nuestro "LD DE, $AABB" no se codifica como "11 AA BB" sino como "11 BB AA". El opcode para "LD DE" es "11", y "BB AA" los operandos (en este caso, un valor numérico directo). Esta forma de almacenamiento se denomina técnicamente "little endian".</li>

	<li>Para el Spectrum, no hay diferencia entre instrucciones y datos. Un "3Ch" puede ser un "INC A" o un valor númerico "3Ch". ¿Cómo distingue el Spectrum uno de otro? Sencillo: todo depende de si se encuentra al principio de un ciclo de decodificación o no. Es decir, si cuando vamos a empezar a leer una instrucción leemos un "3Ch", es un INC A. Pero si lo leemos en el proceso de lectura de un operando, su significado cambia. Pensad en por ejemplo en "LD A, 3Ch", que se codificaría como "3E 3C", pero no ejecutaría un INC A porque la lectura del "3Ch" se realiza como operando para el "LD A,".</li>
	<li>Al no existir diferencia entre instrucciones y datos, si cambiamos PC de forma que apunte a una zona de la memoria donde hay datos y no código, el Z80 no se enterará de ello y tratará de ejecutar los números que va leyendo como si fuera código (con resultados imprecedibles, seguramente con el cuelgue del Spectrum o un reset).</li>
	<li>Por último, existen una serie de opcodes compuestos (dejando de lado los operandos) que ocupan más de 1 byte. Esos opcodes suelen comenzar por CB, ED o FD, de forma que, por ejemplo el opcode "CB 04" se corresponde con la operación "RLC L". Si sólo pudieramos utilizar un byte para representar el opcode, sólo tendríamos disponibles 256 posibles instrucciones en el procesador. Para poder disponer de más instrucciones se utilizan códigos de instrucción de más de un byte. Así, cuando nuestro procesador encuentra un CB, ED o FD sabe que el próximo código que lea después tendrá un significado diferente al que tendría sin el CB, ED o FD delante. Es por eso que "04h" significa "INC B", y "CBh O4h" significa "RLC L" (otra instrucción diferente).</li>
</ul>
<p><strong>ENSAMBLADO MANUAL</strong></p>
<p>Al igual que el Spectrum consulta una tabla interna para saber a qué instrucción corresponde cada número (cada opcode) nosotros podemos consultar una tabla para ensamblar manualmente nuestros programas en ensamblador y obtener los valores de código máquina. Si no tenemos a mano un programa ensamblador que lo haga por nosotros (que, al fin y al cabo, no es más que un traductor con una tabla similar), podemos utilizar tablas para traducir el programa manualmente. Cabe decir que es una labor repetitiva y larga, y se recomienda encarecidamente la utilización de un programa ensamblador para ello.</p>
<p>Cuando lleguemos a la parte de definición del lenguaje veremos que ensamblando manualmente resulta bastante costoso calcular las direcciones de los saltos relativos y absolutos, cosa que el programa ensamblador hace con bastante facilidad.</p>
<p>Aún así, quien quiera intentar ensamblar manualmente podrá hacerlo incluso con la tabla de "Juego de caracteres" que tiene disponible en el manual del +2A/+3, capítulo 8, sección 28 (además de no ser la única tabla de ensamblado manual que existe, ya que hay varias disponibles en Internet).</p>

<p><a href="src/opcodes.txt" onclick="window.open(this.href); return false">Tabla de opcodes</a></p>
<p><strong>TIEMPOS DE EJECUCIÓN</strong></p>
<p>Cada instrucción necesita un tiempo diferente para ejecutarse. No es lo mismo un simple "INC A", que requiere leer un único byte como opcode, no requiere parámetros, y sólo realiza un incremento en un registro, que un complejo "LD A, (1234h)", que requiere leer el opcode, a continuación leer 2 bytes para el operando "1234h", después acceder a la memoria y extraer el dato contenido en (1234h) para, finalmente, depositarlo en A.</p>
<p>Los tiempos de ejecución de cada instrucción son, pues, diferentes, y para conocerlos tendremos que consultar cualquier tabla de tiempos (t-states o t-estados). Podéis acceder a alguna de estas tablas en los enlaces que veréis al final de este artículo.</p>
<p><strong>EL SOFTWARE DE SPECTRUM</strong></p>
<p>A estas alturas ya debemos tener claro cómo funciona el Spectrum, con su microprocesador Z80 continuamente ejecutando el código apuntado por "PC", incrementando este y de nuevo repitiendo el ciclo.</p>
<p>Cuando encendemos nuestro Spectrum, PC vale 0000h y se ejecuta la ROM que, como ya hemos comentado, no es más que un programa hecho por los ingenieros que desarrollaron el Spectrum. Dicho programa está disponible en formato código fuente para consultas ya que usuarios de Spectrum realizaron un desensamblado (a partir de los opcodes, obtener el código fuente original) y comentaron todas las rutinas, variables del sistema y procedimientos que se ejecutan en nuestro Spectrum nada más arrancarlo. El libro "The Complete Spectrum ROM Disassembly" (El desensamblado Completo de la ROM del Spectrum) contiene este desensamblado, y podemos obtenerlo en Internet, por si tenemos curiosidad en conocer las interioridades de la ROM del Spectrum y cómo está programado el intérprete BASIC y las diferentes funciones de la ROM del mismo (con el objetivo de poder "usarlas" en nuestros programas en ensamblador).</p>
<p>Pero aparte de la ROM del Spectrum, ¿cómo llega a la memoria de nuestro ordenador (o emulador) los programas que ejecutamos?. Veamos las diferentes maneras:</p>
<ol style="list-style-type: lower-alpha">

	<li>Desde cinta: Nuestro LOAD "" provoca en BASIC la llamada a una rutina de la ROM que carga desde cinta el código y los datos de los programas. Lo único que se hace es leer de la cinta los opcodes y sus operandos, así como cualquier otro dato (gráficos, sonidos) del programa, e introducirlos en memoria en una zona a la que luego saltaremos (cambiaremos PC a ella). Cuando grabamos a cinta, lo que hacemos es leer el contenido de un trozo de memoria y escribirlo en cinta (escribir los valores numéricos de los opcodes, operandos y datos).</li>
	<li>Desde disco: exactamente igual que en el caso de la cinta, pero el medio de almacenamiento es un disco de 3" o de 3.5".</li>
	<li>Ficheros TAP y TZX: son ficheros de ordenador que almacenan los datos exactamente igual que si fuera una cinta real: almacenan opcodes, datos y operandos, que luego serán cargados en memoria.</li>
	<li>Ficheros .SP, .SNA y .Z80 (en general, cualquier fichero de snapshot). No son más que volcados de la memoria. Por ejemplo, un fichero .SP o .SNA contiene el contenido de las 49152 celdillas de memoria desde 16384 hasta 65536. Para cargar ese .SNA en un emulador, lo que realiza el emulador es un simple "POKEado" del contenido del fichero en las celdillas de memoria. Así, un fichero snapshot no es más que una "copia" de la memoria (de su contenido) que volcamos a fichero.</li>
</ol>
<p><strong>EN RESUMEN</strong></p>
<p>Hemos visto cómo funciona internamente nuestro ordenador Spectrum y el microprocesador Z80. A partir de la próxima entrega comenzaremos ya con la sintaxis del lenguaje ensamblador y una descripción de las diferentes instrucciones disponibles. No obstante, creemos que los conceptos introducidos ya en estas 2 primeras entregas del curso deben de haber llevado ya al lector a un punto en el cual podrá realizar sus primeras pruebas en ensamblador mediante la documentación a la cual nos referimos en los enlaces. Basta con consultar el juego de instrucciones del Spectrum en la página oficial del Z80 o de Zilog para poder realizar ya nuestros primeros programas en ensamblador para nuestro querido Sinclair ZX Spectrum.</p>

<p><strong>FICHEROS</strong></p>
<ul>
    <li><a href="src/teclado.bas" onClick="window.open(this.href); return false;">Programa en BASIC que lee el teclado mediante acceso a puertos</a></li>
    <li><a href="tap/teclado.tap" onClick="window.open(this.href); return false;">Fichero tap del ejemplo teclado.bas</a></li>
    <li><a href="src/pantalla.bas" onClick="window.open(this.href); return false;">Programa en BASIC que dibuja en pantalla mediante POKE</a></li>
    <li><a href="tap/pantalla.tap" onClick="window.open(this.href); return false;">Fichero tap del ejemplo pantalla.bas</a></li>
    <li><a href="src/opcodes.txt" onClick="window.open(this.href); return false;">Listado de opcodes para ensamblado manual</a></li>

</ul>
<p><strong>LINKS</strong></p>
<ul>
    <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt32.html" onClick="window.open(this.href); return false;">Puertos E/S</a></li>
    <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt26.html" onClick="window.open(this.href); return false;">Usando CM</a></li>
    <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt24.html" onClick="window.open(this.href); return false;">La Memoria</a></li>
    <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt25.html" onClick="window.open(this.href); return false;">Variables del sistema</a></li>
    <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt28.html" onClick="window.open(this.href); return false;">Set de caracteres</a></li>

    <li><a href="http://www.Z80.info" onClick="window.open(this.href); return false;">Web del Z80</a></li>
    <li><a href="http://www.worldofspectrum.org/faq/reference/Z80reference.htm" onClick="window.open(this.href); return false;">Z80 Reference de WOS</a></li>
    <li><a href="http://ti86.acz.org/Z80_ref.htm" onClick="window.open(this.href); return false;">Z80 Reference de TI86</a></li>
    <li><a href="http://www.ticalc.org/pub/text/Z80/" onClick="window.open(this.href); return false;">Tablas de ensamblado y t-estados</a> (pulsar en Z80.txt, Z80_reference.txt, Z80time.txt)</li>
    <li><a href="http://freestuff.grok.co.uk/rom-dis/" onClick="window.open(this.href); return false;">Complete Spectrum ROM disassembly project</a></li>

</ul>
</div>
        </td>
    </tr>
    <tr>
        <td align="right"><br><br>SROMERO</td>
    </tr>
</table>
                    </td>
                </tr>

                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td>
<script language="JavaScript">
function RecargarPie(url)
{
    document.location=url;
}
</script>
<table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
    <form name="selector_secciones">
        <tr>
<td align="left">
    <input type="button" onclick="RecargarCabecera('input.html');" name="anterior" value="<" />
    <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">

        <option value="index.html">Portada</option>
        <option value="editorial.html">Índice - Editorial</option>
        <option value="panorama.html">Panorama</option>
        <option value="analisis.html">Análisis</option>
        <option value="al-descubierto.html">Al Descubierto</option>
        <option value="el-aventurero.html">El Aventurero</option>

        <option value="z88dk.html">Programación Z88DK</option>
        <option value="input.html">INPUT</option>
        <option value="ensamblador.html" selected>Programación Ensamblador</option>
        <option value="rem.html">REM</option>
        <option value="opinion.html">Opinión</option>
    </select>

    <input type="button" onclick="RecargarCabecera('rem.html');" name="siguiente" value=">" />
</td>
            <td align="right" class="texto">
                <a href="#arriba">Volver arriba</a>
            </td>
        </tr>
        <tr><td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE DE REVISTAS</b></a> <</td></tr>

    </form>
</table>
                    </td>
                </tr>
                <tr>
                    <td>
<table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
	<tr align="center" valign="center">
		<td>2003-2009 Magazine ZX</td>

	</tr>
</table>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-8018503-4");
pageTracker._trackPageview();
} catch(err) {}</script>
                    </td>
                </tr>
            </table>
        </center>
    </body>

</html>
