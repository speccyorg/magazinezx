<!doctype html>
<html lang="es">
<head>
    <title>Programación Ensamblador - Magazine ZX número 4 - Noviembre 2003</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/magazine.css" type="text/css">
</head>
<body>
<table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
    <tr>
        <td>
            <a name="arriba"></a>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
                <tr align="center" valign="center">
                    <td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0"/></a></td>
                </tr>
            </table>
        </td>

    </tr>
    <tr>
        <td>
            <script language="JavaScript">
              function RecargarCabecera(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>

                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('zona-www.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>

                                <option value="al-descubierto.html">Al Descubierto</option>
                                <option value="hardware.html">Hardware</option>
                                <option value="emulacion.html">Emulación</option>
                                <option value="zona-www.html">Zona WWW</option>
                                <option value="ensamblador.html" selected>Programación Ensamblador</option>
                                <option value="input.html">INPUT</option>

                            </select>
                            <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                        </td>
                        <td align="center" class="texto">Número 4 - Noviembre 2003</td>
                        <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX"
                                             onClick="window.open(this.href); return false;"><img
                                src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0"
                                alt="ZX Certified webmaster"></a> <a href="http://www.speccy.org/"
                                                                     onClick="window.open(this.href); return false;"><img
                                src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a>
                        </td>
                    </tr>
                </form>
            </table>
            </a>
        </td>

    </tr>
    <tr>
        <td> </td>
    </tr>
    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
                <tr>
                    <td>
                        <div align="justify">
                            <p>
                                <i>Comienza en este número un nueva sección, dedicada a la programación en
                                    ensamblador. Esta sección está pensada para que la gente que esté siguiendo el
                                    curso de MH (ya sea en su versión HTML o escaneada) pueda ver ejemplos prácticos del
                                    uso de este lenguaje. La temática de cada número podrá o no estar basada en otros
                                    artículos de la revista, y el nivel también puede variar de un artículo a
                                    otro (de hecho, esta semana comenzamos con un nivel bastante fuerte, porque la
                                    rutina que comentamos tiene muchas optimizaciones). Espero sinceramente que os
                                    agrade la sección, así que sin más preámbulos, vamos al lío.</i>

                            </p>
                            <p>
                                El mes pasado Antonio Villena nos ofreció su primera versión del programa
                                compresor de ejecutables TAPC. En este artículo nos habla sobre la técnica
                                de compresión que ha utilizado.
                            </p>
                            <table bgcolor="#EBEBFF" class="texto">
                                <tr>
                                    <td>
                                        <p align="center"><font size="4">COMPRESOR DE EJECUTABLES TAPC</font></p>
                                        <p>
                                            La compresión es una técnica que basa su éxito en eliminar la redundancia de
                                            los
                                            datos. Por tanto, la existencia de redundancia es una condición necesaria
                                            para que
                                            se pueda aplicar la técnica. En la práctica eso no supone ningún impedimento
                                            ya
                                            que la redundancia abunda en todo tipo de datos y de forma natural. En un
                                            texto las
                                            palabras se suelen repetir, en una melodía se repiten los patrones
                                            sonoros, en un gráfico dos líneas contiguas son muy similares si las
                                            comparamos.
                                        </p>
                                        <p>
                                            En este caso el objetivo es comprimir un juego de Spectrum, entre cuyos
                                            datos se
                                            encuentran instrucciones código máquina del Z80. Pues bien, incluso este
                                            tipo de
                                            datos también posee una redundancia que es posible eliminar. El estilo de
                                            programar,
                                            la abusiva utilización de instrucciones útiles frente al escaso empleo de
                                            otras más rebuscadas, incluso la mera lógica de poner un salto condicional
                                            después de una comparación, etc... dotan de la suficiente redundancia a un
                                            fragmento de
                                            código máquina Z80.
                                        </p>
                                        <p>
                                            Afortunadamente un juego de Spectrum contiene muchos más tipos de datos:
                                            sprites,
                                            melodías, tablas, niveles... que son más redundantes que los anteriores, por
                                            tanto
                                            en general se pueden comprimir mejor.
                                        </p>
                                        <p>

                                            Ahora llega la hora de comprimir; hay bastantes algoritmos de compresión
                                            así que tendremos que elegir uno. Aunque el cerco se estrecha si nos
                                            limitamos a
                                            la escasa potencia computacional de una CPU tipo CISC de 3.5MHz. Y lo peor
                                            de todo
                                            es que no disponemos de RAM extra; los juegos normalmente ocupan toda la RAM
                                            disponible, por lo que no tendremos espacio para meter tablas ni datos
                                            intermedios.
                                            Así que el único candidato que queda es una variante de Lempel-Ziv.
                                        </p>
                                        <p>
                                            Los algoritmos de Lempel-Ziv buscan la redundancia mirando hacia atrás sobre
                                            el propio fichero que se está comprimiendo, para ver si hay un patrón que se
                                            encuentre
                                            repetido y, en lugar de codificar ese patrón, codificar su posición y su
                                            longitud.
                                            Si intentamos comprimir esta frase "hola, esto mola", cuando el algoritmo
                                            esté comprimiendo
                                            y vaya por la letra "m", se dará cuenta que el siguiente patrón "ola" ocupa
                                            tres bytes; sin embargo si somos capaces de codificar en menos de tres
                                            bytes, que existe una cadena de longitud 3, en una posición de 11 letras
                                            hacia
                                            atrás, el decodificador tendrá los suficientes datos como para reconstruir
                                            el mensaje inicial y se habrá eliminado la redundancia que existía.
                                        </p>
                                        <p>
                                            La cuestión está en el "cómo" se codifican estos datos a nivel bit; es obvio
                                            que
                                            habrá que hacerlo de forma que se utilicen los menos bits posibles, e
                                            incluso se pueden
                                            usar ciertas ideas y trucos siempre y cuando se demuestre su efectividad.
                                        </p>
                                        <p>
                                            Lo primero es diferenciar entre los "bytes" que no se pueden comprimir por
                                            no haber encontrado una cadena lo suficientemente larga. Para ello se
                                            empezará leyendo
                                            un bit: si este bit es cero significa que lo que viene después es un byte en
                                            bruto,
                                            que no ha podido comprimirse. Esta es la parte mala, hemos codificado con 9
                                            bits
                                            un dato de 8, así que si todos los datos fueran así lo que hemos hecho es
                                            expandir con
                                            un factor de 9/8. Gracias a Dios esto sólo ocurre en archivos de naturaleza
                                            aleatoria, o datos ya comprimidos, circunstancias que en ningún caso se
                                            darán en un
                                            juego de Spectrum.
                                        </p>
                                        <p>
                                            Para codificar otra cosa que no sean datos en bruto hay que tener en cuenta
                                            que para
                                            ganar en rendimiento es necesario codificar los acontecimientos más
                                            frecuentes con
                                            menos bits, y viceversa. Más o menos la idea es la misma que el algoritmo de
                                            Huffman, algoritmo que hemos descartado por emplear tablas que necesitan
                                            de memoria adicional. Pues bien, como el patrón que más se repite es el
                                            "byte bruto" que ya hemos visto antes, a este le damos la mínima longitud, o
                                            sea
                                            1 bit, y le asignamos el bit 0. Para el resto habrá que ingeniárselas
                                            buscando un
                                            árbol que sea fácil de implementar en código y se ajuste a las frecuencias
                                            de aparición.
                                        </p>
                                        <p>
                                            Los otros patrones son "10", "110", "1110", "11110", y "11111". El secreto
                                            de su
                                            sencillez es que solo hay que contar el número de unos hasta ver un cero,
                                            o si contamos 5 parar. Esta feliz idea me ha permitido realizar un
                                            descompresor de
                                            122 bytes.
                                        </p>

                                        <p>
                                            Empezamos por el primer patrón "10". Se trata de una ocurrencia genérica,
                                            puede tener
                                            cualquier longitud (con un límite de 256) y la posición hacia atrás máxima
                                            es
                                            de 65536 bytes. Se supone que es el segundo patrón más frecuente y es la
                                            idea original de
                                            algoritmo Lempel-Ziv puro. Lo siguiente que viene es la longitud, pero
                                            tampoco ésta
                                            tiene un tamaño fijo, sino variable. Lo que hacemos es leer los bits de dos
                                            en
                                            dos, siendo el primero el bit de información y el segundo sólo nos indica si
                                            debemos
                                            seguir leyendo o parar. Esta es la técnica conocida como "codificación
                                            gamma".
                                            Lo más óptimo para esto es partir de un registro iniciado a 1, e ir metiendo
                                            los bits
                                            que vayamos leyendo por la derecha, desplazando el resto hacia la izquierda.
                                            Un ejemplo
                                            sencillo, "01110110". Empezamos con el registro iniciado a "00000001",
                                            leemos de la
                                            fuente "01", o sea metemos un 0 y seguimos "00000010". Ahora leemos "11",
                                            metemos
                                            un 1 y continuamos "00000101". Luego "01" dejará el registro en el
                                            valor "00001010" y proseguiremos hasta el último "10", haciendo un último
                                            desplazamiento "00010101" y el cero nos indica que ya hemos acabado. En
                                            decimal el
                                            valor leído es de 21.
                                        </p>
                                        <p>
                                            Este subalgoritmo es importante, tiene la característica de codificar
                                            números
                                            bajos con muchos menos bits que números más altos. Su uso lo justifica el
                                            hecho de que
                                            las ocurrencias más cortas son las más frecuentes. Es raro encontrar una
                                            cadena repetida
                                            de longitud 256, sin embargo las de longitud 2 son muy abundantes. Otra cosa
                                            útil de
                                            esta función es que el mínimo valor que se obtiene es 2, que coincide con la
                                            longitud mínima de una ocurrencia de este estilo.
                                        </p>
                                        <p>
                                            Después de la longitud se debe decodificar la posición. En este caso el
                                            esquema es
                                            una muestra entre longitud fija y longitud variable. También se basa en un
                                            principio
                                            teórico que dice más o menos que los datos redundantes suelen estar
                                            localizados en
                                            zonas próximas entre sí. O sea que valores más bajos "de posiciones hacia
                                            atrás" serán
                                            más frecuentes y dignos de ser codificados en menos bits. Pero en este caso
                                            los
                                            márgenes que manejamos son mayores y si no queremos perjudicar en exceso a
                                            ocurrencias lejanas necesitamos combinarlo con una parte fija de 8 bits. La
                                            posición será
                                            un registro de 16 bits, cuyos 8 bits de mayor peso se obtendrán con la misma
                                            función
                                            de antes (pero restándole 2), y los ocho de menor peso tendrán una longitud
                                            fija de 8
                                            bits.
                                        </p>
                                        <p>
                                            En realidad a efectos prácticos la mitad superior de la longitud viene antes
                                            que la
                                            posición, porque resultaba conveniente para optimizar aún más la rutina
                                            descompresora.
                                        </p>
                                        <p>
                                            Para acabar con el patrón "10" pongo el siguiente ejemplo:
                                            "1011100111111000011000", primero delimitamos campos: "10", "1110",
                                            "01111110",
                                            "00011000". El primero delimita el patrón, que es del tipo que acabo de
                                            explicar;
                                            ahora viene la parte alta de la posición "1110" que se traduce en "1 11", o
                                            sea siete
                                            pero que al restarle 2 se me queda en 5. El tercero es la longitud, que en
                                            este
                                            caso es de "1 0111" es decir empiezo con uno y leo los bits impares. Se
                                            corresponde
                                            con una longitud de 23. Acabando con la parte baja de la posición tendremos
                                            un 18h (la
                                            h por lo de hexadecimal), teniendo en total un registro de posición de 0518h
                                            ó 1304. O
                                            sea que el decodificador debe poner a continuación la misma cadena que se
                                            escribió 1304 bytes
                                            hacia atrás con una longitud de 23 bytes.
                                        </p>
                                        <p>
                                            El siguiente patrón es el "110". La funcionalidad se escapa un poco al
                                            algoritmo
                                            Lempel-Ziv aunque permite introducir bytes en bruto utilizando 7 bits en
                                            lugar de los
                                            nueve del patrón "0". Después de este patrón leemos una longitud fija de 4
                                            bits; en
                                            total hemos leído 7 bits "100XXXX". Estos cuatro bits forman un valor desde
                                            0 hasta 15.
                                            En caso de ser 0, nos indican que debemos escribir el byte más frecuente que
                                            existe,
                                            o sea el propio 0. Las zonas vacías de memoria tienen este valor, al iniciar
                                            registros, etc... El usar 7 bits para codificar un cero y 9 bits para los
                                            255 símbolos restantes repercute positivamente en cuanto a compresión. Si no
                                            me
                                            creéis coged cualquier editor hexadecimal y abrid cualquier archivo, contáis
                                            el numero de ceros y lo dividís entre la longitud del archivo. Si este valor
                                            excede
                                            con creces al valor 1/256 me daréis la razón. Prosiguiendo, en caso de no
                                            ser cero, tendremos un valor de 1 a 15 que nos indicará cuantas posiciones
                                            debemos
                                            retroceder hasta encontrar el byte que buscamos. Como ejemplo tenemos la
                                            siguiente
                                            cadena: "tenemos la siguiente caden", en este caso codificamos con un 4, ya
                                            que
                                            4 posiciones hacia atrás hay una "a" y será más corto hacer esto que usando
                                            el patrón
                                            "0" y luego 8 bits. Con esto ahorramos 2 bits.

                                        </p>
                                        <p>
                                            Los dos siguientes patrones son "1110" y "11110" que voy a explicar a la vez
                                            porque su funcionalidad es muy parecida. Se trata de ocurrencias de longitud
                                            2 y
                                            3 respectivamente (2 para "1110" y 3 para "11110") pero cuya posición no
                                            excede
                                            los 128 bytes hacia atrás. Así se podrá codificar con un número fijo
                                            de bits, en particular 7. Sumando tenemos una longitud total de 11 para el
                                            patrón
                                            "1110" y de 12 para el patrón "11110". Por poner un ejemplo aunque seguro
                                            que no hace
                                            falta si leemos "111101010101", lo separamos en "11110","1010101" que
                                            quiere decir "una cadena de longitud 3 con posición 85".
                                        </p>
                                        <p>
                                            El último patrón que queda por explicar es el "11111". Se trata de una
                                            ocurrencia en
                                            la que sólo codificamos la longitud, ya que la posición es la misma que la
                                            que tuvo
                                            la inmediatamente anterior. La longitud, que es lo único que viene después,
                                            mantiene
                                            idéntico formato a la del tipo "10". El porqué esto funciona es fácil de
                                            comprender
                                            con un ejemplo. Imagínad un gráfico en el cual dos líneas consecutivas solo
                                            difieran en
                                            un byte. Entonces la primera línea se codificará usando muchos patrones tipo
                                            "0",
                                            hasta empezar con la línea siguiente. Aquí encontraremos una ocurrencia de
                                            longitud X
                                            y posición 256 (el ancho de la línea), después codificaremos con tipo "0" ó
                                            "110" el
                                            byte que difiera, y por último encontraremos otra cadena de longitud 255-X y
                                            posición
                                            256. Como ves el hecho de encontrar dos ocurrencias consecutivas con la
                                            misma posición
                                            es más normal de lo que cabría pensar, y justifica la implementación de este
                                            patrón.
                                        </p>
                                        <p>
                                            Por último, y también es importante, tiene que haber una forma de parar el
                                            descompresor para ejecutar el código. Esto se podría hacer comparando cada
                                            vez que
                                            leemos si hemos superado una determinada posición, pero también podemos usar
                                            otro
                                            patrón, el "000000000" para indicar el EOF (End of File). Claro que si
                                            empiezo leyendo
                                            un "0", ¿no lo confundiré con un patrón del tipo "0"? (byte en bruto). Pues
                                            no,
                                            porque como recordaréis el byte 0 es tan frecuente que se codifica con 7
                                            bits
                                            en lugar de nueve, exactamente con la cadena "1100000", así que no habrá
                                            confusiones.
                                        </p>
                                        <p>
                                            Ya adquirida toda la base teórica estamos listos, suponiendo unos mínimos
                                            conocimientos de ensamblador Z80, para entender el código del descompresor.
                                        </p>
                                    </td>
                                <tr>
                                <tr>
                                    <td align="right"><br><br>ANTONIO VILLENA</td>

                                </tr>
                            </table>
                            <p><b>INTRODUCCIÓN</b></p>
                            <p>
                                La rutina que vamos a ver en este número se encuentra
                                <a href="http://www.speccy.org/bacteria/tapc_source.zip"
                                   onClick="window.open(this.href); return false;">aquí</a>,
                                en el directorio Z80, bajo el nombre "PRU.ASM". Como comprobaréis los pocos comentarios
                                que hay no son demasiado explicativos, así que vamos a dedicar este artículo
                                a destripar su funcionamiento al completo. El fundamento teórico de la
                                compresión lo tenéis en el artículo anterior, y es necesario que lo leáis y
                                comprendáis si queréis entender bien lo que se os avecina.
                            </p>
                            <p><b>ANÁLISIS DE LA RUTINA DESCOMPRESORA DE TAPC</b></p>
                            <p>
                                La primera rutina que voy a explicar es LEEB, que se encarga de leer los bits
                                uno a uno conforme vamos avanzando al descomprimir los datos. Dicha rutina es
                                la siguiente:
                            </p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td>
                                        <table class="codigo">

                                            <tr>
                                                <td width="60">DORA</td>
                                                <td>DEC</td>
                                                <td>IX</td>
                                            </tr>
                                            <tr>
                                                <td> </td>

                                                <td>DEFB</td>
                                                <td>$30</td>
                                            </tr>
                                            <tr>
                                                <td>LEEB</td>
                                                <td>AND</td>
                                                <td>A</td>

                                            </tr>
                                            <tr>
                                                <td> </td>
                                                <td>RL</td>
                                                <td>(IX)</td>
                                            </tr>
                                            <tr>
                                                <td> </td>

                                                <td>JR</td>
                                                <td>Z, DORA</td>
                                            </tr>
                                            <tr>
                                                <td> </td>
                                                <td>RET</td>
                                                <td> </td>

                                            </tr>
                                    </td>
                                </tr>
                            </table>
            </table>
            <p>
                El punto de entrada está en LEEB, así que de momento olvidaos de las dos primeras
                instrucciones.
            </p>
            <p>
                Lo primero que nos encontramos es un AND A, instrucción que nos sirve
                para borrar el flag de acarreo (Carry).
            </p>
            <p>
                En la siguiente instrucción rotamos hacia la izquierda el contenido de memoria al
                que apunta IX, que es donde están los bits que queremos leer. El bit
                leido pasa al Carry, y al mismo tiempo el contenido antiguo del carry
                (en este caso un 0), pasa al bit menos significativo de (IX), es decir,
                que entra un 0 por la derecha.
            </p>
            <p>
                ¿Que sucede cuando hemos extraido los 8 bits del byte al que
                apunta IX? Que hemos metido 8 bits 0 por la derecha, con lo que el resultado
                de la operación es 0, se activa el flag Z y saltamos a DORA en la siguiente
                instrucción.
            </p>

            <p>
                Si no estamos extrayendo el octavo bit, el salto no se produce y retornamos
                de la rutina con el RET, y la información del bit recién extraido
                está en el flag Carry.
            </p>
            <p>
                En DORA decrementamos el puntero IX para que apunte al siguiente byte
                (decrementamos porque el archivo está comprimido hacia detrás).
            </p>
            <p>
                La siguiente instrucción resulta que no es una instrucción completa, sino
                sólo media, por eso está escrita en forma de dato, de forma que ese dato
                junto con la siguiente instrucción (el AND A) forman la instrucción
                completa. El código 30h = 48 decimal es el primer byte de
                JR NC, desp . Sabemos seguro que el Carry está a uno (ya que el
                último bit que sale antes de que el byte pase a valer 0 tiene que ser
                un uno seguro), así que no se provocará ningún salto y logramos pasar directamente al
                RL (IX) sin que llegue a ejecutarse la instrucción AND A (que se usó
                como distancia de salto de la instrucción JR).
            </p>
            <p>
                Al volver a ejecutar RL (IX), leemos el primer bit del siguiente byte, de nuevo
                en el indicador de acarreo, pero en esta ocasión introducimos un 1 por la derecha.
                Este uno no es un dato, sino el "bit marcador" (marker bit), que
                indicará el final del byte cuando hayamos leido otra vez 8 bits y toque pasar al
                siguiente. Si os dais cuenta, el último bit que se sacará de cada byte siempre será
                el marker bit. Esta técnica es importante porque permite prescindir de contadores
                que habrían sido necesarios para controlar la lectura de 8 en 8 bits si
                no la hubiesemos utilizado. La segunda vez que pasemos por
                el salto condicional JR Z, DORA sabemos seguro que el salto no va a producirse,
                porque aunque los datos del siguiente byte fueran todo ceros, el bit-marker
                asegura que hasta que no hagamos otras 8 lecturas, el contenido de (IX) no
                volverá a valer 0. Por lo tanto, retornamos en el RET y listos.
            </p>
            <p>
                Vayamos con la siguiente subrutina, que se usa para leer un número fijo de bits:
            </p>
            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                <tr>
                    <td>
                        <table class="codigo">

                            <tr>
                                <td width="60">LOLO</td>
                                <td>CALL</td>
                                <td>LEEB</td>
                            </tr>
                            <tr>
                                <td> </td>

                                <td>RL</td>
                                <td>C</td>
                            </tr>
                            <tr>
                                <td> </td>
                                <td>JR</td>
                                <td>NC, LOLO</td>

                            </tr>
                            <tr>
                                <td> </td>
                                <td>LD</td>
                                <td>L, C</td>
                            </tr>
                            <tr>
                                <td> </td>

                                <td>RET</td>
                                <td> </td>
                            </tr>
                    </td>
                </tr>
            </table>
</table>
<p>
    En la primera instrucción leemos un bit, bit que introducimos en el
    registro C por la derecha, al realizar la rotación a la izquierda. Este
    proceso lo repetimos hasta que sale un bit 1 por la izquierda. Ese bit que
    sale por la izquierda no es un dato, sino otro marker-bit, que a la entrada
    de la rutina sirve para indicar cuantos bits queremos leer. Por ejemplo,
    para C=00000001b, se leerán un total de 8 bits, mientras que para C=00010000b tan
    sólo se leerán 4.
</p>
<p>
    Cuando se hayan leido los bits necesarios, el contenido de C se copia en el
    registro L, y regresamos.
</p>
<p>

    Por último vamos a ver la subrutina que lee un número variable de bits codificados
    con la técnica de gamma encoding:
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">DOND</td>
                    <td>INC</td>
                    <td>B</td>
                </tr>

                <tr>
                    <td>DONE</td>
                    <td>CALL</td>
                    <td>LEEB</td>
                </tr>
                <tr>
                    <td> </td>

                    <td>RL</td>
                    <td>B</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>CALL</td>
                    <td>LEEB</td>

                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>
                    <td>C, DONE</td>
                </tr>
                <tr>
                    <td> </td>

                    <td>RET</td>
                    <td> </td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    A esta rutina se entra por DONE con B=1, o bien por DOND cuando tenemos B=0, ya
    que necesitamos un 1, pues los códigos variables que usamos tienen al menos el
    primer bit a 1.
</p>
<p>
    Nada más comenzar leemos un bit y lo colocamos en B (como siempre, haciendo
    que entre por la derecha), y a continuación leemos el siguiente pero su valor no
    lo almacenamos sino que lo usamos para ver si queremos seguir leyendo. En
    el momento en que tengamos un bit a 0, salimos de la subrutina.
</p>
<p>

    Ahora ya estamos listos para comenzar a examinar la rutina descompresora desde
    el principio:
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">#define</td>
                    <td>DEFB</td>
                    <td>.BYTE</td>
                </tr>

                <tr>
                    <td>#define</td>
                    <td>DEFW</td>
                    <td>.WORD</td>
                </tr>
                <tr>
                    <td>#define</td>

                    <td>EQU</td>
                    <td>.EQU</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Estas son pseudo-instrucciones del ensamblador TASM, que es el que ha
    utilizado Antonio en su código. Se pueden desechar si usamos otro ensamblador.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">

                <tr>
                    <td width="60"> </td>
                    <td>.ORG</td>
                    <td>$5D01</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>LD</td>

                    <td>IX, 0000</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>LD</td>
                    <td>DE, 0000</td>
                </tr>

        </td>
    </tr>
</table>
</table>
<p>
    El valor que se carga en IX no es en realidad 0, sino que el compresor sitúa
    en ese espacio el comienzo de la zona comprimida+1, ya que IX es de donde se
    leen los bits uno a uno. En el primer byte que se lee de (IX) almacena el
    valor 128, por lo que solo contiene un bit marcador y el primer bit que devuelve
    LEEB es por tanto ya de la zona comprimida. Igualmente, el compresor coloca en
    DE el comienzo de la zona donde vamos a descomprimir los datos. Al decir
    comienzo, hemos de recordar que la descompresión la realizamos hacia atrás, así
    que el valor inicial de DE estará por el final de la memoria y el de IX dependerá
    del nivel de compresión alcanzado con cada archivo en concreto.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>
                    <td>LD</td>
                    <td>B, C</td>

                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Esta instrucción carga en B el valor 1. Si nos fijamos en el bloque
    anterior la rutina comienza en 5D01, y al invocarla con USR, BC almacena el
    valor de la dirección de ejecución.
</p>
<p>
    El valor 1 para B es necesario para el caso del patrón 0, que es el
    primero que se ejecuta, sin necesidad de decodificar el campo de patrón. Esto es
    así porque no tiene sentido esperar que se repita ningún dato antes de que
    existan dichos datos. El único cuidado que hay que tener es que el primer
    dato que se extrae no sea 0, porque para el patrón 0, el dato 00000000
    significa el final del archivo. El compresor se encarga de que esto no
    suceda, añadiendo un dato basura distinto de 0 si fuera necesario.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">REOT</td>

                    <td>CALL</td>
                    <td>LOLO</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JP</td>
                    <td>Z, $0000</td>

                </tr>
                <tr>
                    <td>LI00</td>
                    <td>LD</td>
                    <td>A, C</td>
                </tr>
        </td>
    </tr>
</table>

</table>
<p>
    Aquí entramos ya sea la primera vez desde arriba o bien más tarde desde abajo
    hasta la etiqueta REOT, con B=1 y C=1. El hecho de que C sea 1 sirve para que la
    llamada a LOLO lea un byte completo (el dato sin comprimir). Si el dato leido
    fuera un 0, hemos alcanzado el final de la compresión, y saltamos a la dirección
    de ejecución del programa descomprimido (de nuevo, este campo no es 0,
    sino que será rellenado convenientemente por el programa compresor).
</p>
<p>
    En A metemos el dato que hemos leido ahora mismo, que será el siguiente en
    ser colocado en su sitio. Si venimos desde abajo entrando por LI00, estaremos
    introduciendo un 0 proviniente del subcaso 0000 del patrón 110.
</p>
<p>
    Sigamos...
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">RAVE</td>

                    <td>LD</td>
                    <td>(DE), A</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>DEC</td>
                    <td>HL</td>

                </tr>
                <tr>
                    <td> </td>
                    <td>DEC</td>
                    <td>DE</td>
                </tr>
                <tr>
                    <td> </td>

                    <td>DJNZ</td>
                    <td>RDAD</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    A RAVE llegamos con el siguiente byte que tenemos que escribir en el registro A,
    y con el número de bytes que quedan por copiar de una zona de memoria en el
    registro B. Si no estamos copiando de una zona de memoria, B valdrá 1 y no
    buscará por lo tanto nuevos bytes. En caso de que nos queden bytes por copiar,
    se saltará a RDAD para tomar el siguiente byte antes de volver a RAVE.
</p>
<p>
    Justo aquí acabamos de procesar un código LZ y vamos a comenzar a
    leer el siguiente en este código:
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">BUKX</td>
                    <td>LD</td>
                    <td>H, B</td>
                </tr>
                <tr>

                    <td> </td>
                    <td>LD</td>
                    <td>BC, $0501</td>
                </tr>
                <tr>
                    <td>RENU</td>
                    <td>CALL</td>

                    <td>LEEB</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>
                    <td>NC, REXU</td>
                </tr>

                <tr>
                    <td> </td>
                    <td>DJNZ</td>
                    <td>RENU</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Sabemos que B vale 0 porque venimos de un DJNZ, así que la primera instrucción pone
    a 0 el registro H.

</p>
<p>
    En la siguiente instrucción de este bloque metemos un 5 en B, que hará de
    contador, y en C aprovechamos para renovar el bit marcador para un uso futuro.
</p>
<p>
    Ahora comenzamos a leer bits, y en cuanto encontramos un bit a 0 significará que
    ya tenemos nuestro patrón. Si leemos 5 bits y aún no hemos encontrado el patrón,
    es que hemos leido el patrón 11111, por lo que seguimos adelante. Si lo
    encontramos antes, salimos hacia la etiqueta REXU, con un valor en B que depende del
    patrón que hemos encontrado, teniendo los valores B=5, 4, 3, 2 ó 1 para los
    patrones 0,10,110,1110 ó 11110 respectivamente.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>
                    <td>LD</td>

                    <td>HL, RUTA+1</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>PUSH</td>
                    <td>HL</td>
                </tr>

        </td>
    </tr>
</table>
</table>
<p>
    Aquí estamos en el caso del patrón 11111. Recordemos que para este patrón
    necesitamos leer la longitud de copia, que tiene un número variable de
    bits. Para ello podríamos llamar a la subrutina decodificadora gamma que
    vimos anteriormente, entrando por DOND, pero el caso es que luego nos interesa
    dar un salto a otra posición, por lo que en lugar de hacer CALL DOND, JR RUTA+1
    lo que hacemos es guardar en la pila la dirección a donde queremos saltar,
    que quedará como un retorno ficticio cuando ejecutemos el siguiente RET, y
    colocamos la subrutina gamma justo a continuación:
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">DOND</td>
                    <td>INC</td>

                    <td>B</td>
                </tr>
                <tr>
                    <td>DONE</td>
                    <td>CALL</td>
                    <td>LEEB</td>
                </tr>

                <tr>
                    <td> </td>
                    <td>RL</td>
                    <td>B</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>CALL</td>

                    <td>LEEB</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>
                    <td>C, DONE</td>
                </tr>

                <tr>
                    <td> </td>
                    <td>RET</td>
                    <td> </td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Ésta ya la hemos visto y no requiere más comentarios.
</p>

<p>
    Ahora dejemos el patrón 11111 para más adelante (cuando alcancemos la
    etiqueta RUTA), y veamos lo que pasa si el patrón era cualquier otro.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">REXU</td>
                    <td>LD</td>
                    <td>A, B</td>

                </tr>
                <tr>
                    <td> </td>
                    <td>SUB</td>
                    <td>3</td>
                </tr>
        </td>
    </tr>
</table>
</table>

<p>
    Al restar 3 al número de patrón que estaba en B, se obtienen los siguientes casos (NZ quiere decir flag Zero = 0, Z
    flag Zero = 1, y lo mismo para el carry):
</p>
<table border="0" class="texto">
    <tr>
        <td>* patrón 0:</td>
        <td> A =</td>
        <td> 2</td>
        <td>, NC</td>
        <td>, NZ</td>
    </tr>
    <tr>
        <td>* patrón 10:</td>
        <td> A =</td>
        <td> 1</td>
        <td>, NC</td>
        <td>, NZ</td>
    </tr>

    <tr>
        <td>* patrón 110:</td>
        <td> A =</td>
        <td> 0</td>
        <td>, NC</td>
        <td>, Z</td>
    </tr>
    <tr>
        <td>* patrón 1110:</td>
        <td> A =</td>
        <td> -1</td>
        <td>, C</td>
        <td>, NZ</td>
    </tr>
    <tr>
        <td>* patrón 11110:</td>
        <td> A =</td>
        <td> -2</td>
        <td>, C</td>
        <td>, NZ</td>
    </tr>

</table>
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>
                    <td>JR</td>
                    <td>NZ, NLTR</td>
                </tr>

        </td>
    </tr>
</table>
</table>
<p>
    Si no estamos en el patrón 110, saltamos a probar los siguientes
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>
                    <td>LD</td>
                    <td>BC, ALAE</td>

                </tr>
                <tr>
                    <td> </td>
                    <td>PUSH</td>
                    <td>BC</td>
                </tr>
                <tr>
                    <td> </td>

                    <td>LD</td>
                    <td>BC, $0110</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Al igual que en el caso anterior, introducimos una dirección de retorno en la pila
    y el bit marcador del registro C lo introducimos en esta ocasión en el bit 4 del
    byte -los bits se numeran del 7 (más significativo) al 0 (menos significativo)-, con
    lo que en la siguiente rutina leemos 4 bits (tal y como requiere el patrón).
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>

                    <td width="60">LOLO</td>
                    <td>CALL</td>
                    <td>LEEB</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>RL</td>

                    <td>C</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>
                    <td>NC, LOLO</td>
                </tr>

                <tr>
                    <td> </td>
                    <td>LD</td>
                    <td>L, C</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>RET</td>

                    <td> </td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Esta rutina también la hemos visto, y pasemos ahora a los patrones que no hemos
    tocado aún, es decir, todos menos el 11111 y el 110.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">NLTR</td>

                    <td>JR</td>
                    <td>NC, LE23</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Si no hay carry estamos en los casos 0 o 10, saltamos a otro sitio para procesarlos.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">

                <tr>
                    <td width="60"> </td>
                    <td>CPL</td>
                    <td> </td>
                </tr>
                <tr>
                    <td> </td>
                    <td>LD</td>

                    <td>B, A</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>INC</td>
                    <td>C</td>
                </tr>

                <tr>
                    <td> </td>
                    <td>JR</td>
                    <td>KXKX</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Este código se ejecuta para los patrones 1110 y 11110. Ambos casos son
    muy parecidos, tan sólo se diferencian en las distancias (2 y 3 respectivamente),
    por lo que comparten el mismo código sin necesidad de seguir bifurcando.

</p>
<p>
    La primera instrucción CPL es equivalente a XOR 255. Cambia todos los
    bits del acumulador, obteniendose A=0 para el patrón 1110 y A=1 para el
    patrón 11110. Este valor se copia a B en la siguiente instrucción.
</p>
<p>
    A continuación INC C pasa el valor de 1 a 2, con lo que el marker bit se mueve
    un lugar y solo se leerán 7 bits fijos en lugar de 8 para la distancia.
</p>
<p>
    Por último saltamos a otra zona del código, por lo que, al igual que
    con los patrones vistos anteriormente: continuará...
</p>
<p>
    Retomamos aquí el caso de los patrones 0 y 10, en ese caso tras restar 3 el valor de
    A para estos casos era 2 y 1 respectivamente.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>

                    <td width="60">LE23</td>
                    <td>LD</td>
                    <td>B, A</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>DJNZ</td>

                    <td>REOT</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Primero copiamos el valor de A en B, para a continuación hacer la última
    bifurcación usando la instrucción DJNZ.
</p>
<p>
    Para el patrón 0, al decrementar B, está toma el valor 1, y salta a la
    etiqueta REOT, que está arriba del todo y ya hemos visto. Recordemos que el valor
    de C que fue renovado entre las etiquetas BUKX y RENO, es 1, y no ha sido
    tocado, por lo que todo va como debería.
</p>
<p>
    Para el caso 10, seguimos ejecutando código...
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>
                    <td>CALL</td>
                    <td>DOND</td>
                </tr>
                <tr>
                    <td> </td>

                    <td>DEC</td>
                    <td>B</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>DEC</td>
                    <td>B</td>

                </tr>
                <tr>
                    <td> </td>
                    <td>LD</td>
                    <td>H, B</td>
                </tr>
                <tr>
                    <td> </td>

                    <td>LD</td>
                    <td>B, A</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>CALL</td>
                    <td>DONE</td>

                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    La primera llamada a la subrutina gamma, lee la parte alta de la distancia, le
    resta 2 y la guarda en H. A continuación, vuelve a fijar el registro B a 1
    (A conservaba ese valor desde la resta de 3 al interpretar el patrón), y llamamos de
    nuevo a la subrutina para leer la longitud que se va a copiar, longitud que
    quedará guardada en B.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">KXKX</td>
                    <td>CALL</td>

                    <td>LOLO</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    En esta etiqueta nos encontramos con el salto que se ejecutaba para los patrones 1110
    y 11110, por lo que esta llamada a LOLO (la subrutina que lee un número fijo de
    bits), lee 8 bits para el patrón 10 y 7 bits para los otros 2 casos. Tras
    este salto, para los 3 patrones tenemos la distancia de la zona que queremos copiar
    en HL, porque en LOLO se copia el resultado en L, y para el patrón 10 acabamos
    de guardar la parte alta en H, cuyo valor lo habíamos puesto a 0 anteriormente, y
    sigue valiendo 0 para los otros dos patrones que consideramos hasta ahora.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>

                    <td>POP</td>
                    <td>AF</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Este código se usa para desechar la distancia del caso anterior, que se guarda
    en la pila. La primera vez el valor desechado es el de retorno al BASIC,
    pero nos da igual porque no vamos a retornar a él de todas formas.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">

                <tr>
                    <td width="60"> </td>
                    <td>XOR</td>
                    <td>A</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>CP</td>

                    <td>H</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>
                    <td>NZ, RUTA</td>
                </tr>

                <tr>
                    <td> </td>
                    <td>BIT</td>
                    <td>7, L</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>

                    <td>NZ, RUTA</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>INC</td>
                    <td>B</td>
                </tr>
                <tr>

                    <td> </td>
                    <td>INC</td>
                    <td>B</td>
                </tr>
                <tr>
                    <td>RUTA</td>
                    <td> </td>
                    <td> </td>

                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Este trozo de código es algo complicado. Básicamente, comprueba si la distancia
    total es menor de 128, y si es así le sumamos 2 a la longitud de la
    coincidencia. Con esto logramos por una parte, ajustar el valor de B en los
    patrones 1110 y 11110 (recordemos que B valía 0 y 1 respectivamente), y por otra
    parte, para el patrón 10 logramos que la longitud mínima cuando la distancia es
    pequeña sea de 4 (ya que si tuvieramos 2 o 3 habríamos usado los patrones 1110
    ó 11110). Para lograr esto, ponemos el valor de A a 0 (mediante la instrucción
    XOR A), y lo comparamos con H. Si no coinciden, es que la distancia es grande
    y no hace falta incrementar. Si coinciden, miramos el valor del bit 7 (el
    más significativo) de L, con una instrucción de bit. Si está activo significa que
    L > 128, entonces no se activa el flag Z, por lo que se produce el salto y
    tampoco se incrementa la longitud.
</p>
<p>
    Sigamos...
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">RUTA</td>

                    <td>OR</td>
                    <td>225</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Si entramos mediante RUTA+1 (que es la dirección de retorno que pusimos en
    la pila para el patrón 11111), la instrucción que se ejecuta es 225 = POP HL.
    Con esto recuperamos la distancia anterior de la pila, en lugar de desecharla
    como hicimos con los patrones que estabamos viendo hasta ahora en el POP
    AF de arriba. Desde más arriba, lo que conseguimos con la instrucción OR es poner
    el flag Z a 0, lo cual asegura que no se producirá salto condicional que aparece
    un poco más abajo.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">

                <tr>
                    <td width="60"> </td>
                    <td>PUSH</td>
                    <td>HL</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Con esto guardamos la distancia para el próximo patrón. Esta distancia podrá
    ser la que acabamos de sacar o una que acabemos de calcular, y en
    la próxima iteración podrá ser ignorada, desechada o recuparada.

</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">ALAE</td>
                    <td>JR</td>
                    <td>Z, LI00</td>
                </tr>

        </td>
    </tr>
</table>
</table>
<p>
    Aquí entra el último patrón que teníamos por ahí perdido: el 110. Este
    patrón acababa de leer 4 bits, y si resultan ser todos 0 es un byte 0
    que tiene que meter, por lo que salta por arriba del todo. En
    el patrón 11111 este salto no se producirá seguro porque viene de leer la longitud,
    que es distinta de cero, y los demás patrones acaban de ejecutar la instrucción OR
    255, por lo que tampoco saltarán.
</p>
<p>
    Llegados a este punto, es que hemos comenzado un proceso de copia de bytes anteriores.
    En este momento tenemos en HL la distancia que separa la posición actual de la
    que queremos comenzar a copiar, y en B tenemos el número de bytes que se van a copiar.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>
                    <td>ADD</td>

                    <td>HL, DE</td>
                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Se suma a la distancia la posición actual de destino, obteniendo la posición
    de origen de la copia en HL.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">RDAD</td>

                    <td>LD</td>
                    <td>A, (HL)</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>
                    <td>RAVE</td>

                </tr>
        </td>
    </tr>
</table>
</table>
<p>
    Se coge un byte y se va a RAVE a colocarlo. Esto se repetirá hasta que B sea 0 y se comienze por lo tanto a
    decodificar un nuevo patrón.
</p>
<p>
    Por último viene la rutina de leer bits, que fue la primera en ser comentada.
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60">DORA</td>

                    <td>DEC</td>
                    <td>IX</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>DEFB</td>
                    <td>$30</td>

                </tr>
                <tr>
                    <td>LEEB</td>
                    <td>AND</td>
                    <td>A</td>
                </tr>
                <tr>

                    <td> </td>
                    <td>RL</td>
                    <td>(IX)</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>JR</td>

                    <td>Z, DORA</td>
                </tr>
                <tr>
                    <td> </td>
                    <td>RET</td>
                    <td> </td>
                </tr>
        </td>
    </tr>
</table>
</table>

<p>
    Y eso es todo. Con
</p>
<table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
    <tr>
        <td>
            <table class="codigo">
                <tr>
                    <td width="60"> </td>
                    <td>.END</td>
                    <td> </td>
                </tr>

        </td>
    </tr>
</table>
</table>
<p>
    Se le indica al ensamblador TASM que estamos al final del archivo.
</p>
<p><b>CONCLUSIONES</b></p>
<p>
    Acabamos de revisar una obra maestra de la optimización en tamaño. Tal vez
    sea posible ahorrar algún byte extra por algún lado, pero en ese caso os
    aseguro que no sería nada fácil encontrar dónde. La optimización no sólo se
    basa en las distintas técnicas (como el bit marcador) y trucos (como los datos
    de una instrucción que constituyen otra instrucción en si misma, o el guardar
    una dirección de retorno falsa en la pila) que hemos visto, sino sobre
    todo en la reutilización de código (los distintos patrones comparten partes del
    código, en lugar de tener cada uno su apartado), y en el control y la
    sabia utilización de los registros, que han permitido implementar la descompresión
    sin necesidad de usar ninguna variable extra aparte de los registros normales y la pila.
</p>
<p>
    Es de esperar que en los próximos artículos los programas analizados sean
    algo más simples, y no incidiremos tanto en la optimización de espacio, sino
    algo más en la de velocidad, o en un equilibrio entre ambos aspectos, ya
    que en un ordenador como el Spectrum tanto memoria como velocidad
    escasean, y la velocidad suele ser el factor determinante que permita o no
    realizar una tarea crítica a tiempo para conseguir un movimiento suave y
    sin parpadeos, por ejemplo.
</p>
<p>
    Nos vemos próximamente.

</p>
<div align="left">
    <p>
        <b>LINKS</b>
    </p>
    <ul>
        <li><a href="http://www.speccy.org/bacteria/tapc.zip" onClick="window.open(this.href); return false;">http://www.speccy.org/bacteria/tapc.zip</a>
        </li>
        <li><a href="http://www.speccy.org/bacteria/tapc_source.zip" onClick="window.open(this.href); return false;">http://www.speccy.org/bacteria/tapc_source.zip</a>
        </li>
        <li><a href="http://www.speccy.org/bacteria/tapc_soloejecutable.zip"
               onClick="window.open(this.href); return false;">http://www.speccy.org/bacteria/tapc_soloejecutable.zip</a>
        </li>
    </ul>

</div>
</div>
</td>
</tr>
<tr>
    <td align="right"><br><br>METALBRAIN</td>
</tr>
</table>
</td>
</tr>

<tr>
    <td> </td>
</tr>
<tr>
    <td>
        <script language="JavaScript">
          function RecargarPie(url) {
            document.location = url;
          }
        </script>
        <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
            <form name="selector_secciones">
                <tr>
                    <td align="left">
                        <input type="button" onclick="RecargarCabecera('zona-www.html');" name="anterior" value="<"/>
                        <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">

                            <option value="index.html">Portada</option>
                            <option value="editorial.html">Índice - Editorial</option>
                            <option value="panorama.html">Panorama</option>
                            <option value="analisis.html">Análisis</option>
                            <option value="al-descubierto.html">Al Descubierto</option>
                            <option value="hardware.html">Hardware</option>

                            <option value="emulacion.html">Emulación</option>
                            <option value="zona-www.html">Zona WWW</option>
                            <option value="ensamblador.html" selected>Programación Ensamblador</option>
                            <option value="input.html">INPUT</option>
                        </select>
                        <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                    </td>

                    <td align="right" class="texto">
                        <a href="#arriba">Volver arriba</a>
                    </td>
                </tr>
                <tr>
                    <td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                        DE REVISTAS</b></a> <
                    </td>
                </tr>
            </form>

        </table>
    </td>
</tr>
<tr>
    <td>
        <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
            <tr align="center" valign="center">
                <td>2003-2009 Magazine ZX</td>
            </tr>

        </table>
        <script type="text/javascript">
          var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
          document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>
        <script type="text/javascript">
          try {
            var pageTracker = _gat._getTracker("UA-8018503-4");
            pageTracker._trackPageview();
          } catch (err) {
          }</script>
    </td>
</tr>
</table>

</body>
</html>
