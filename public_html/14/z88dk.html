<!doctype html>
<html lang="es">
<head>
    <title>Programación Z88DK - Magazine ZX número 14 - Diciembre 2006</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/magazine.css" type="text/css">
</head>
<body>
<table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
    <tr>
        <td>
            <a name="arriba"></a>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
                <tr align="center" valign="center">
                    <td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0"/></a></td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarCabecera(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>
                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('hardware.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>

                                <option value="hardware.html">Hardware</option>
                                <option value="z88dk.html" selected>Programación Z88DK</option>
                                <option value="input.html">INPUT</option>
                                <option value="ensamblador.html">Programación Ensamblador</option>
                            </select>
                            <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                        </td>

                        <td align="center" class="texto">Número 14 - Diciembre 2006</td>
                        <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX"
                                             onClick="window.open(this.href); return false;"><img
                                src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0"
                                alt="ZX Certified webmaster"></a> <a href="http://www.speccy.org/"
                                                                     onClick="window.open(this.href); return false;"><img
                                src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a>
                        </td>
                    </tr>
                </form>
            </table>
            </a>
        </td>
    </tr>
    <tr>
        <td> </td>
    </tr>

    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
                <tr>
                    <td>
                        <div align="justify">
                            <p align="center"><font size="5">LA LIBRERIA SPRITE PACK (II)</font></p>
                            <p><b>INTRODUCCIÓN</b></p>
                            <p>En la entrega anterior de la revista comenzamos a examinar la librería <a
                                    href="http://www.geocities.com/aralbrec/spritepack/programmer-intro.htm">Sprite
                                Pack</a> y aprendimos a dibujar elementos gráficos sobre la pantalla. También aprendimos
                                que la pantalla estaba dividida en 32x24 "celdas", cada una de las cuales podía contener
                                un <i>tile</i> (cada uno de los elementos que forman parte del fondo) y/o uno o más
                                sprites (gráficos que representaban los diferentes personajes o elementos de nuestro
                                juego). Incluso llegamos a crear un sprite que se movía al azar por la pantalla.</p>

                            <p>En esta ocasión vamos a añadir un par de sencillos detalles más antes de comenzar a
                                escribir nuestro propio juego; un código que luego podrá formar parte de un producto más
                                elaborado. En concreto veremos cómo hacer reaccionar nuestro programa ante la pulsación
                                de teclas por parte del usuario, y cómo mover un sprite utilizando este dispositivo de
                                entrada. También aprenderemos como añadir color a los sprites. Para nuestras
                                explicaciones haremos uso como base del código <i>sprite2.c</i> que se creó en la
                                anterior entrega, y en el que se definía un sprite de tamaño 2x1 que se desplazaba al
                                azar.</p>
                            <p><b>MOVIENDO LOS SPRITES CON EL TECLADO</b></p>
                            <p>Si queremos mover un sprite por la pantalla utilizando el teclado, lo primero que
                                deberemos hacer en nuestro programa es declarar una estructura del siguiente tipo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
struct sp_UDK keys;
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p>La variable <i>keys</i> nos permitirá asociar teclas de nuestro teclado con los
                                diferentes controles de un joystick virtual haciendo uso de la función
                                <i>sp_Lookup_Key</i>, tal como se puede observar a continuación:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
           keys.up = sp_LookupKey('q');
           keys.down = sp_LookupKey('a');
           keys.right = sp_LookupKey('p');
           keys.left = sp_LookupKey('o');
           keys.fire = sp_LookupKey(' ');
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p>Según este ejemplo, cada vez que pulsáramos 'q' en el teclado es como si estuviéramos
                                moviendo el joystick hacia arriba, al pulsar 'a' simulamos la dirección de abajo del
                                joystick, y así sucesivamente. Varias de estas teclas podrían ser pulsadas
                                simultáneamente sin ningún problema.</p>
                            <p>La función <i>sp_JoyKeyboard</i> devuelve una máscara de bits indicándonos qué controles
                                del joystick están accionados en ese momento debido a que sus correspondientes teclas
                                están pulsadas. La forma de interpretar el valor devuelto por esta función es igual que
                                con cualquier máscara de bits en C, y se puede contemplar en el siguiente ejemplo, que
                                consiste en el archivo <i>sprite2.c</i> de la anterior entrega modificado de tal forma
                                que movamos el sprite precisamente con la combinación de teclas indicada anteriormente.
                                Para ello realizamos movimientos relativos del sprite, cambiando cómo desplazamos el
                                sprite en x y en y (dx y dy respectivamente) según los controles de nuestro joystick
                                virtual que estén siendo accionados. El código nuevo respecto a la versión anterior del
                                archivo se muestra en rojo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
#include <spritepack.h>

#include <stdlib.h>
#pragma output STACKPTR=61440

extern struct sp_Rect *sp_ClipStruct;
#asm
LIB SPCClipStruct
._sp_ClipStruct         defw SPCClipStruct
#endasm

extern uchar bicho1[];
extern uchar bicho2[];
extern uchar bicho3[];
<font color="red">struct sp_UDK keys;</font>

uchar hash[] = {0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa};

void *my_malloc(uint bytes)
{
	   return sp_BlockAlloc(0);
}

void *u_malloc = my_malloc;
void *u_free = sp_FreeBlock;

main()
{
	   char dx,dy,i
	   struct sp_SS *spriteBicho;


	    #asm
	    di
	    #endasm
	    sp_InitIM2(0xf1f1);
	    sp_CreateGenericISR(0xf1f1);
	    #asm
	    ei
	    #endasm

	   sp_TileArray(' ', hash);
	   sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');
	   sp_Border(BLUE);
	   sp_AddMemory(0, 255, 14, 0xb000);
           <font color="red">
           keys.up = sp_LookupKey('q');
	   keys.down = sp_LookupKey('a');
	   keys.right = sp_LookupKey('p');
	   keys.left = sp_LookupKey('o');
	   keys.fire = sp_LookupKey(' ');
	   </font>
           spriteBicho = sp_CreateSpr(sp_MASK_SPRITE, 3, bicho1, 1, TRANSPARENT);
           sp_AddColSpr(spriteBicho, bicho2, TRANSPARENT);
	   sp_AddColSpr(spriteBicho, bicho3, TRANSPARENT);
           sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);

           while(1) {
  	         sp_UpdateNow();
<font color="red">
                 i  = sp_JoyKeyboard(&keys);
                 if ((i & sp_FIRE) == 0) {
	              dx = dy = 1;
		 } else {
		      dx = dy = 8;
		 }
           	 if ((i & sp_LEFT) == 0)
		      dx = -dx;
	         else if ((i & sp_RIGHT) != 0)
		      dx = 0;
	         if ((i & sp_UP) == 0)
	              dy = -dy;
                 else if ((i & sp_DOWN) != 0)
                      dy = 0;

</font>
                 sp_MoveSprRel(spriteBicho, sp_ClipStruct, 0, 0, 0, dx, dy);
	   }
}

#asm

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho1
defb @00000011, @11111100
defb @00000100, @11111000
defb @00001000, @11110000
defb @00001011, @11110000
defb @00001011, @11110000
defb @00001000, @11110000
defb @00001000, @11110000
defb @00000100, @11111000

defb @00000011, @11111100
defb @00001100, @11110011
defb @00001100, @11110011
defb @00011000, @11100111
defb @00011000, @11100111
defb @01111100, @10000011
defb @01111100, @10000011
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho2
defb @11100000, @00011111
defb @00010000, @00001111
defb @00001000, @00000111
defb @01101000, @00000111
defb @01101000, @00000111
defb @00001000, @00000111
defb @10001000, @00000111
defb @10010000, @00001111

defb @11100000, @00011111
defb @00011000, @11100111
defb @00011000, @11100111
defb @00001100, @11110011
defb @00001100, @11110011
defb @00111110, @11000001
defb @00111110, @11000001
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho3
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

#endasm
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Al probar el ejemplo nos habremos encontrado con un problema bastante grave: al no
                                controlar cuándo el sprite sobrepasa los límites de la pantalla, es posible desplazar
                                nuestro "bicho" al exterior y perder totalmente su control. Una forma de solucionarlo
                                sería añadir un nuevo control de tal forma que al accionarlo volviéramos a colocar a
                                nuestro bicho en el centro de la pantalla. Esto se puede conseguir realizando mapeados
                                adicionales de teclado a los del joystick virtual. Mediante <i>sp_LookupKey</i> se puede
                                asociar una tecla a una variable <i>uint</i>, de tal forma que más adelante, mediante el
                                uso de otra función adicional llamada <i>sp_KeyPressed</i> podremos saber si dicha tecla
                                está siendo pulsada en este momento.</p>


                            <table border="0" cellspacing="0" cellpadding="2" width="640">
                                <tr align="right">
                                    <td><img src="img/z88dk9_1.png" width="640" height="504"
                                             alt="¡Ya podemos mover a nuestro bicho con el teclado!"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">¡Ya podemos mover a nuestro bicho con el
                                        teclado!
                                    </td>
                                </tr>
                            </table>


                            <p>El código anterior se ha modificado para añadir dos nuevas funcionalidades. Al pulsar la
                                tecla <i>r</i>, nuestro "bicho" volverá al centro de la pantalla. Por otra parte, la
                                tecla <i>b</i> va a permitir que cambiemos el color del borde. Las modificaciones se
                                muestran en rojo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
#include <spritepack.h>
#include <stdlib.h>

#pragma output STACKPTR=61440

extern struct sp_Rect *sp_ClipStruct;
#asm
LIB SPCClipStruct
._sp_ClipStruct         defw SPCClipStruct
#endasm

extern uchar bicho1[];
extern uchar bicho2[];
extern uchar bicho3[];
struct sp_UDK keys; //NUEVO (TECLAS)

uchar hash[] = {0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa};

void *my_malloc(uint bytes)
{
	   return sp_BlockAlloc(0);
}

void *u_malloc = my_malloc;
void *u_free = sp_FreeBlock;

main()
{
	   char dx,dy,i
	   struct sp_SS *spriteBicho;
	   <font color="red">uint reset,cambioBorde;
	   int borde = 1;</font>


	    #asm
	    di
	    #endasm
	    sp_InitIM2(0xf1f1);
	    sp_CreateGenericISR(0xf1f1);
	    #asm
	    ei
	    #endasm

	   sp_TileArray(' ', hash);
	   sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');
	   sp_Border(BLUE);
	   sp_AddMemory(0, 255, 14, 0xb000);

           keys.up = sp_LookupKey('q');
	   keys.down = sp_LookupKey('a');
	   keys.right = sp_LookupKey('p');
	   keys.left = sp_LookupKey('o');
	   keys.fire = sp_LookupKey(' ');
	   <font color="red">reset = sp_LookupKey('r');
	   cambioBorde = sp_LookupKey('b'); </font>

           spriteBicho = sp_CreateSpr(sp_MASK_SPRITE, 3, bicho1, 1, TRANSPARENT);
           sp_AddColSpr(spriteBicho, bicho2, TRANSPARENT);
	   sp_AddColSpr(spriteBicho, bicho3, TRANSPARENT);
           sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);

           while(1) {
  	         sp_UpdateNow();

		 		 // TODO DENTRO DE ESTE WHILE ES NUEVO (TECLADO) MENOS EL UPDATE
                 i  = sp_JoyKeyboard(&keys);
                 if ((i & sp_FIRE) == 0) {
	              dx = dy = 1;
		 } else {
		      dx = dy = 8;
		 }
           	 if ((i & sp_LEFT) == 0)
		      dx = -dx;
	         else if ((i & sp_RIGHT) != 0)
		      dx = 0;
	         if ((i & sp_UP) == 0)
	              dy = -dy;
                 else if ((i & sp_DOWN) != 0)
                      dy = 0;
                 <font color="red">if (sp_KeyPressed(reset))
	             sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);
      		 else
	             sp_MoveSprRel(spriteBicho, sp_ClipStruct, 0, 0, 0, dx, dy);
		 if (sp_KeyPressed(cambioBorde))
	             if (borde == 1)
		     {
			     borde = 2;
			     sp_Border(RED);
		     }
		     else
		     {
			     borde = 1;
			     sp_Border(BLUE);
		     }</font>

	   }
}

#asm

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho1
defb @00000011, @11111100
defb @00000100, @11111000
defb @00001000, @11110000
defb @00001011, @11110000
defb @00001011, @11110000
defb @00001000, @11110000
defb @00001000, @11110000
defb @00000100, @11111000

defb @00000011, @11111100
defb @00001100, @11110011
defb @00001100, @11110011
defb @00011000, @11100111
defb @00011000, @11100111
defb @01111100, @10000011
defb @01111100, @10000011
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho2
defb @11100000, @00011111
defb @00010000, @00001111
defb @00001000, @00000111
defb @01101000, @00000111
defb @01101000, @00000111
defb @00001000, @00000111
defb @10001000, @00000111
defb @10010000, @00001111

defb @11100000, @00011111
defb @00011000, @11100111
defb @00011000, @11100111
defb @00001100, @11110011
defb @00001100, @11110011
defb @00111110, @11000001
defb @00111110, @11000001
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho3
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

#endasm
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Como veremos más adelante, deberemos implementar algún mecanismo para limitar la zona por
                                donde nuestros sprites se van a desplazar. La forma de hacer esto es mediante simples
                                comparaciones, comprobando que el lugar al que vamos a desplazar el sprite no este fuera
                                de la pantalla (o de la zona donde queremos que permanezca).</p>
                            <p><b>AÑADIENDO COLOR</b></p>
                            <p>Un paso importante para poder tener como resultado un videojuego vistoso y que entre por
                                los ojos es aprovechar los colores de nuestro Spectrum y disponer de una combinación
                                agradable de cromaticidad en los sprites de nuestro juego. Los colores también
                                permitirán distinguir con mayor facilidad nuestro personaje de los enemigos y el resto
                                de elementos de la pantalla. Ya vimos en entregas anteriores que en el caso de los tiles
                                era bastante sencillo modificar la tonalidad de la tinta y el papel:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
sp_TileArray(' ', hash);
sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>pero en el caso de los sprites la cosa se complica un poco más y vamos a tener que dar
                                unas cuantas "vueltas" para llegar a nuestro objetivo. En concreto, deberemos hacer uso
                                de una función llamada <i>sp_IterateSprChar</i>, que recibe como parámetro una variable
                                de tipo <i>struct sp_SS</i>, que representa el sprite que queremos modificar, y el
                                nombre de una función que habremos definido anteriormente. Dicha función, al ser
                                llamada, obtendrá como parámetro una variable de tipo <i>struct sp_CS</i>, una
                                estructura muy interesante que nos va a permitir modificar diversas características del
                                sprite, entre ellas el color.</p>
                            <p>El siguiente código muestra, en color rojo, las modificaciones realizadas al programa
                                anterior para poder añadirle color al sprite de nuestro bicho, y que pasaremos a
                                explicar a continuación:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
#include <spritepack.h>
#include <stdlib.h>
#pragma output STACKPTR=61440

extern struct sp_Rect *sp_ClipStruct;
#asm
LIB SPCClipStruct
._sp_ClipStruct         defw SPCClipStruct
#endasm

<font color="red">extern uchar *sp_NullSprPtr;
#asm
LIB SPNullSprPtr
._sp_NullSprPtr         defw SPNullSprPtr
#endasm </font>

extern uchar bicho1[];
extern uchar bicho2[];
extern uchar bicho3[];
struct sp_UDK keys;

uchar hash[] = {0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa};

void *my_malloc(uint bytes)
{
	   return sp_BlockAlloc(0);
}

void *u_malloc = my_malloc;
void *u_free = sp_FreeBlock;

<font color="red">
uchar n;
void addColour(struct sp_CS *cs)
{
	   if (n == 0) // Se rellena de arriba a abajo y de izquierda
	   			   // a derecha, incluyendo partes vacias del sprite
	        cs->colour = INK_BLACK | PAPER_WHITE;
	   else if (n == 1)
	        cs->colour = INK_BLUE | PAPER_BLACK;
	   else if (n == 2)
		 cs->colour = INK_RED | PAPER_GREEN;
	   else if (n == 3)
		 cs->colour = INK_YELLOW | PAPER_BLACK;
	   else if (n == 4)
		 cs->colour = INK_GREEN | PAPER_WHITE;
	   else
	         cs->colour = TRANSPARENT;
	   if (n > 5)
	         cs->graphic = sp_NullSprPtr;
	   n++;
	   return;
}
</font>

main()
{
	   char dx,dy,i
	   struct sp_SS *spriteBicho;
	   uint reset,cambioBorde;
	   int borde = 1;


	    #asm
	    di
	    #endasm
	    sp_InitIM2(0xf1f1);
	    sp_CreateGenericISR(0xf1f1);
	    #asm
	    ei
	    #endasm

	   sp_TileArray(' ', hash);
	   sp_Initialize(INK_WHITE | PAPER_BLACK, ' ');
	   sp_Border(BLUE);
	   sp_AddMemory(0, 255, 14, 0xb000);

           keys.up = sp_LookupKey('q');
	   keys.down = sp_LookupKey('a');
	   keys.right = sp_LookupKey('p');
	   keys.left = sp_LookupKey('o');
	   keys.fire = sp_LookupKey(' ');
	   reset = sp_LookupKey('r');
	   cambioBorde = sp_LookupKey('b');

           spriteBicho = sp_CreateSpr(sp_MASK_SPRITE, 3, bicho1, 1, TRANSPARENT);
           sp_AddColSpr(spriteBicho, bicho2, TRANSPARENT);
	   sp_AddColSpr(spriteBicho, bicho3, TRANSPARENT);
	   <font color="red">sp_IterateSprChar(spriteBicho, addColour); </font>

           sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);

           while(1) {
  	         sp_UpdateNow();


                 i  = sp_JoyKeyboard(&keys);
                 if ((i & sp_FIRE) == 0) {
	              dx = dy = 1;
		 } else {
		      dx = dy = 8;
		 }
           	 if ((i & sp_LEFT) == 0)
		      dx = -dx;
	         else if ((i & sp_RIGHT) != 0)
		      dx = 0;
	         if ((i & sp_UP) == 0)
	              dy = -dy;
                 else if ((i & sp_DOWN) != 0)
                      dy = 0;
                 if (sp_KeyPressed(reset))
	             sp_MoveSprAbs(spriteBicho, sp_ClipStruct, 0, 10, 15, 0, 0);
      		 else
	             sp_MoveSprRel(spriteBicho, sp_ClipStruct, 0, 0, 0, dx, dy);
		 if (sp_KeyPressed(cambioBorde))
	             if (borde == 1)
		     {
			     borde = 2;
			     sp_Border(RED);
		     }
		     else
		     {
			     borde = 1;
			     sp_Border(BLUE);
		     }
	   }
}

#asm

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho1
defb @00000011, @11111100
defb @00000100, @11111000
defb @00001000, @11110000
defb @00001011, @11110000
defb @00001011, @11110000
defb @00001000, @11110000
defb @00001000, @11110000
defb @00000100, @11111000

defb @00000011, @11111100
defb @00001100, @11110011
defb @00001100, @11110011
defb @00011000, @11100111
defb @00011000, @11100111
defb @01111100, @10000011
defb @01111100, @10000011
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho2
defb @11100000, @00011111
defb @00010000, @00001111
defb @00001000, @00000111
defb @01101000, @00000111
defb @01101000, @00000111
defb @00001000, @00000111
defb @10001000, @00000111
defb @10010000, @00001111

defb @11100000, @00011111
defb @00011000, @11100111
defb @00011000, @11100111
defb @00001100, @11110011
defb @00001100, @11110011
defb @00111110, @11000001
defb @00111110, @11000001
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._bicho3
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

#endasm
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Como se puede comprobar, tras crear el sprite del bicho, hacemos uso de la siguiente
                                instrucción:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
sp_IterateSprChar(spriteBicho, addColour);
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Esto significa que vamos a usar una función llamada <i>addColour</i>, y que deberemos
                                haber definido anteriormente dentro del archivo con el código, para modificar las
                                propiedades de <i>spriteBicho</i>. Aunque la instrucción sólo aparece una vez, es como
                                si estuviéramos llamando a la función <i>addColour</i> una vez por cada bloque de 8x8
                                que forma el sprite del bicho (recordemos que el sprite de nuestro bicho está formado
                                por 3 columnas de 3 bloques de 8x8, por lo que la función <i>addColour</i> será llamada
                                un total de 9 veces). La forma que tiene está función es la siguiente:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
uchar n;
void addColour(struct sp_CS *cs)
{
           if (n == 0) // Se rellena de arriba a abajo y de izquierda
           			   // a derecha, incluyendo partes vacias del sprite
                cs->colour = INK_BLACK | PAPER_WHITE;
           else if (n == 1)
                cs->colour = INK_BLUE | PAPER_BLACK;
           else if (n == 2)
                 cs->colour = INK_RED | PAPER_GREEN;
           else if (n == 3)
                 cs->colour = INK_YELLOW | PAPER_BLACK;
           else if (n == 4)
                 cs->colour = INK_GREEN | PAPER_WHITE;
           else
                 cs->colour = TRANSPARENT;
           if (n > 5)
                 cs->graphic = sp_NullSprPtr;
           n++;
           return;
}
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Justo antes se define una variable global llamada <i>n</i>, y que no será más que un
                                contador que nos permitirá saber en cuál de las nueve llamadas a la función
                                <i>addColour</i> nos encontramos. Ya dentro de dicho método se observa como su valor se
                                incrementa de uno en uno en cada llamada.</p>
                            <p>Como hemos repetido varias veces, la función <i>addColour</i> será llamada una vez por
                                cada bloque 8x8 que forme nuestro sprite, recibiendo como parámetro un struct de tipo
                                sp_CS que nos va a permitir modificar diversas características de dicho bloque del
                                sprite. Uno de los campos de ese struct es <i>colour</i>, que como su propio nombre
                                indica, es el indicado para añadir color. Gracias al valor de <i>n</i>, podremos conocer
                                en cuál de todos los bloques del sprite nos encontramos (empezando por el 0, los bloques
                                están ordenados de arriba a abajo y de izquierda a derecha, por lo que en el caso de
                                nuestro bicho, aun estando compuesto por 3x3 bloques, sólo nos interesará colorear
                                aquellos para los que n vale 0,1,3 y 4, que son los que no están vacíos) y asignarle un
                                color de tinta y papel modificando el valor del campo <i>colour</i> del <i>struct
                                    sp_CS</i>, tal como se puede observar en el código anterior.</p>

                            <p>Sólo deberemos colorear los bloques 0,1,3 y 4 de nuestro bicho, pues el bloque 2 se
                                corresponde con el último de la primera columna (que está vacío), el bloque 5 con el
                                último de la segunda columna (que también está vacío) y los bloques 6,7 y 8 con la
                                última columna de todas, también vacía, y que se añadió para que no hubiera problemas al
                                desplazar el sprite. En el caso de los bloques 2 y 5 lo más correcto hubiera sido
                                utilizar el valor <i>TRANSPARENT</i> para el campo <i>colour</i> (aunque en nuestro
                                ejemplo hemos sido un poco transgresores y el bloque 2 no lo hemos hecho transparente).
                                Para la última columna (bloques para los que <i>n</i> vale más que 5), sin embargo,
                                asignamos el valor <i>sp_NullSprPtr</i> al campo <i>colour</i>. Este valor, que ha sido
                                definido anteriormente en el programa de la siguiente forma:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

                                <tr>
                                    <td><p class="codigo">
                                        <pre>
extern uchar *sp_NullSprPtr;
#asm
LIB SPNullSprPtr
._sp_NullSprPtr         defw SPNullSprPtr
#endasm
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>evitará que esa columna vacía "moleste" al resto de los sprites con los que nuestro bicho
                                entre en contacto.</p>
                            <p>Y ya está, ya le hemos dado color a nuestro bicho (eso sí, una combinación bastante
                                psicodélica). Cada vez que queramos hacer lo mismo con cualquier otro sprite, tan solo
                                deberemos seguir la receta anterior, pues es algo mecánico.</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="640">
                                <tr align="right">
                                    <td><img src="img/z88dk9_2.png" width="640" height="508"
                                             alt="Nuestro sprite a color. Evidentemente, la combinación de colores puede ser mejorada"/>

                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Nuestro sprite a color. Evidentemente, la
                                        combinación de colores puede ser mejorada
                                    </td>
                                </tr>
                            </table>

                            <p><b>UN NUEVO JUEGO</b></p>
                            <p>A continuación, y empleando el conocimiento adquirido tanto en este número como en el
                                número anterior del magazine, vamos a comenzar a desarrollar nuestro propio juego. Al
                                hacerlo nos encontraremos con una serie de problemas que iremos resolviendo en próximos
                                artículos. En nuestro juego controlaremos los movimientos de un esquiador que deberá
                                descender una montaña esquivando todas las rocas que se interpongan en su camino. El
                                esquiador estará situado en la parte superior de la pantalla y podrá desplazarse a
                                izquierda y derecha. Las rocas subirán desde la parte inferior de la pantalla, simulando
                                el descenso por la pendiente nevada de la montaña.</p>


                            <table border="0" cellspacing="0" cellpadding="2" width="640">
                                <tr align="right">
                                    <td><img src="img/z88dk9_3.png" width="640" height="508"
                                             alt="Aspecto final del juego"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Aspecto final del juego</td>
                                </tr>
                            </table>


                            <p>El código completo, que comentaremos a lo largo de esta sección (aunque no en detalle,
                                sólo aquellas partes que difieran de lo visto hasta ahora o introduzcan conceptos
                                nuevos), es el siguiente:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
#include <spritepack.h>
#include <stdlib.h>
#pragma output STACKPTR=61440

#define NUM_ROCAS 8

extern struct sp_Rect *sp_ClipStruct;
#asm
LIB SPCClipStruct
._sp_ClipStruct         defw SPCClipStruct
#endasm

extern uchar *sp_NullSprPtr;
#asm
LIB SPNullSprPtr
._sp_NullSprPtr         defw SPNullSprPtr
#endasm

extern uchar roca1[];
extern uchar roca2[];
extern uchar roca3[];
extern uchar banderin1[];
extern uchar banderin2[];
extern uchar skiCentrado1[];
extern uchar skiCentrado2[];
extern uchar skiIzquierda1[];
extern uchar skiIzquierda2[];
extern uchar skiDerecha1[];
extern uchar skiDerecha2[];
struct sp_UDK keys;

void *my_malloc(uint bytes)
{
	   return sp_BlockAlloc(0);
}

void *u_malloc = my_malloc;
void *u_free = sp_FreeBlock;

uchar n;
void addColourRoca(struct sp_CS *cs)
{
	   if (n >= 0 && n <= 5)
		 cs->colour = INK_RED | PAPER_WHITE;
	   else
	         cs->colour = TRANSPARENT;
	   if (n > 5)
	         cs->graphic = sp_NullSprPtr;
	   n++;
	   return;
}

void addColourSki(struct sp_CS *cs)
{
	if (n == 0)
		cs->colour = INK_BLUE | PAPER_WHITE;
	else if (n == 2)
		cs->colour = INK_BLUE | PAPER_WHITE;
	else
		cs->colour = TRANSPARENT;
	if (n>2)
		cs->graphic = sp_NullSprPtr;
	n++;
	return;
}

main()
{
	   char dx,dy,i
	   struct sp_SS *spriteRoca[NUM_ROCAS], *spriteSkiCentrado,
	   	*spriteSkiIzquierda, *spriteSkiDerecha, *ski;
	   short int posicion = 0;
	   int roca = 0;


	    #asm
	    di
	    #endasm
	    sp_InitIM2(0xf1f1);
	    sp_CreateGenericISR(0xf1f1);
	    #asm
	    ei
	    #endasm

	   sp_Initialize(INK_BLACK | PAPER_WHITE, ' ');
	   sp_Border(WHITE);
	   sp_AddMemory(0, 255, 14, 0xb000);

	   keys.up = sp_LookupKey('q');
	   keys.down = sp_LookupKey('a');
	   keys.fire = sp_LookupKey(' ');
	   keys.right = sp_LookupKey('p');
	   keys.left = sp_LookupKey('o');

	   for (i=0;i<NUM_ROCAS;i++)
	   {
              n = 0;
              spriteRoca[i] = sp_CreateSpr(sp_OR_SPRITE, 3, roca1, 1, TRANSPARENT);
              sp_AddColSpr(spriteRoca[i], roca2, TRANSPARENT);
	      sp_AddColSpr(spriteRoca[i], roca3, TRANSPARENT);
	      sp_IterateSprChar(spriteRoca[i], addColourRoca);
	      sp_MoveSprAbs(spriteRoca[i],sp_ClipStruct,0,0,-20,-20,0);
	   }

	   n = 0;
	   spriteSkiCentrado = sp_CreateSpr(sp_MASK_SPRITE, 2, skiCentrado1, 1, TRANSPARENT);
	   sp_AddColSpr(spriteSkiCentrado, skiCentrado2, TRANSPARENT);
	   sp_IterateSprChar(spriteSkiCentrado, addColourSki);

	   n = 0;
	   spriteSkiIzquierda = sp_CreateSpr(sp_MASK_SPRITE, 2, skiIzquierda1, 1, TRANSPARENT);
	   sp_AddColSpr(spriteSkiIzquierda, skiIzquierda2, TRANSPARENT);
	   sp_IterateSprChar(spriteSkiIzquierda, addColourSki);

	   n = 0;
	   spriteSkiDerecha = sp_CreateSpr(sp_MASK_SPRITE, 2, skiDerecha1, 1, TRANSPARENT);
	   sp_AddColSpr(spriteSkiDerecha, skiDerecha2, TRANSPARENT);
	   sp_IterateSprChar(spriteSkiDerecha, addColourSki);

	   ski = spriteSkiCentrado;

           sp_MoveSprAbs(ski, sp_ClipStruct, 0, 0, 15, 0, 0);


           while(1) {
  	         sp_UpdateNow();

		 i = sp_JoyKeyboard(&keys);
		 dx = 0;
		 dy = 0;
		 if ((i & sp_LEFT) == 0 && ski->col > 0)
		 {
		    if (posicion != -1)
		    {
		    	sp_MoveSprAbs(spriteSkiIzquierda,sp_ClipStruct,0,ski->row,ski->col,0,0);
		    	sp_MoveSprAbs(ski,sp_ClipStruct,0,0,-10,0,0);
		    	ski = spriteSkiIzquierda;
			posicion = -1;
		    }
		    dx = -3;
		 }
		 else if ((i & sp_RIGHT) == 0 && ski->col < 30)
		 {
	            if (posicion != 1)
		    {
			sp_MoveSprAbs(spriteSkiDerecha,sp_ClipStruct,0,ski->row,ski->col,0,0);
			sp_MoveSprAbs(ski,sp_ClipStruct,0,0,-10,0,0);
			ski = spriteSkiDerecha;
			posicion = 1;
		    }
		    dx = 3;
		 }
		 else
		 {
		    if (posicion != 0)
		    {
			    sp_MoveSprAbs(spriteSkiCentrado,sp_ClipStruct,0,ski->row,ski->col,0,0);
		            sp_MoveSprAbs(ski,sp_ClipStruct,0,0,-10,0,0);
		    	    ski = spriteSkiCentrado;
			    posicion = 0;
		    }
		 }
	         if (dx != 0) sp_MoveSprRel(ski, sp_ClipStruct, 0, 0, 0, dx, dy);

		 if (spriteRoca[roca]->row != -10)
		 {
		    dx = 0;
		    dy = -4;
		    sp_MoveSprRel(spriteRoca[roca],sp_ClipStruct,0,0,0,dx,dy);
		 }
		 else
		    if (rand()%100>98)
		    {
			sp_MoveSprAbs(spriteRoca[roca],sp_ClipStruct,0,23,rand()%29+1,0,4);
		    }
 		 roca ++;
		 if (roca >= NUM_ROCAS)
	            roca = 0;
	   }
}

#asm

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._roca1
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000001, @11111110
defb @00000011, @11111100
defb @00000011, @11111100
defb @00000111, @11111000

defb @00001111, @11110000
defb @00001111, @11110000
defb @00011111, @11100000
defb @00111111, @11000000
defb @00111111, @11000000
defb @00111110, @11000000
defb @01111110, @10000000
defb @01111110, @10000000

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._roca2
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @01100000, @10011111
defb @11110000, @00001111
defb @11111000, @00000111
defb @11111000, @00000111
defb @10111000, @00000111

defb @10111100, @00000011
defb @10111100, @00000011
defb @10111100, @00000011
defb @01111110, @00000001
defb @01111110, @00000001
defb @11111110, @00000001
defb @11111111, @00000000
defb @11111111, @00000000

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._roca3
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._skiCentrado1
defb @00111110, @11000001
defb @01101011, @10000000
defb @00111110, @11000001
defb @00011100, @11100011
defb @00010100, @11101011
defb @00100010, @11011101
defb @00100010, @11011101
defb @01000001, @10111110

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._skiCentrado2
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._skiIzquierda1
defb @00011111, @11100000
defb @00110101, @11000000
defb @00011111, @11100000
defb @00001110, @11110001
defb @00010010, @11101101
defb @00100100, @11011011
defb @01001000, @10110111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._skiIzquierda2
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._skiDerecha1
defb @11111000, @00000111
defb @10101100, @00000011
defb @11111000, @00000111
defb @01110000, @10001111
defb @01001000, @10110111
defb @00100100, @11011011
defb @00010010, @11101101
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

._skiDerecha2
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111
defb @00000000, @11111111

#endasm

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Se han definido un total de cuatro sprites. El sprite de tipo <i>roca</i> (dividido en
                                tres columnas denominadas <i>roca1, roca2</i> y <i>roca3</i>) será el que representará
                                los obstáculos que encontrará nuestro intrépido esquiador en su descenso. Para el
                                protagonista de nuestro juego se han definido tres sprites divididos cada uno de ellos
                                en dos columnas: <i>skiCentrado</i> que será el que se mostrará cuando el esquiador esté
                                descendiendo sin que lo movamos a izquierda o derecha, <i>skiIzquierda</i> que
                                representa nuestro esquiador desplazándose hacia la izquierda, y <i>skiDerecha</i> que a
                                su vez representa al mismo esquiador desplazándose a la derecha.</p>

                            <p>Como debemos reservar memoria para los sprites que vayamos a mostrar por pantalla, lo
                                haremos para cada una de las tres posiciones del esquiador (de tal forma que mostraremos
                                la adecuada según el movimiento del jugador) y un número fijo de rocas. Es probable que
                                no todas las rocas sean visibles simultáneamente durante el juego, pero hacerlo de esta
                                forma simplifica en gran medida el diseño, sin tener que hacer grandes esfuerzos para
                                reservar o liberar memoria cuando sea necesario. En concreto, la constante NUM_ROCAS es
                                la que vamos a usar para indicar el número de rocas que se van a crear. Se define un
                                array llamado <i>spriteRoca</i> con tantas posiciones como las indicadas por la
                                constante anteriormente mencionada, y en cada posición de dicho array se reserva memoria
                                para un sprite de tipo roca que es coloreado con su correspondiente función
                                <i>addColour</i>:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 for (i=0;i<NUM_ROCAS;i++)
 {
    n = 0;
    spriteRoca[i] = sp_CreateSpr(sp_OR_SPRITE, 3, roca1, 1, TRANSPARENT);
    sp_AddColSpr(spriteRoca[i], roca2, TRANSPARENT);
    sp_AddColSpr(spriteRoca[i], roca3, TRANSPARENT);
    sp_IterateSprChar(spriteRoca[i], addColourRoca);
    sp_MoveSprAbs(spriteRoca[i],sp_ClipStruct,0,0,-20,-20,0);
 }
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p>Un par de comentarios sobre la definición de los sprites en este programa: como primer
                                parámetro para los sprites de tipo roca en la función <i>sp_CreateSpr</i> se pasa el
                                valor <i>sp_OR_SPRITE</i> en lugar de <i>sp_MASK_SPRITE</i>. Esto permite mayor
                                velocidad en el dibujado de las rocas por la pantalla a cambio de renunciar a que el
                                sprite pueda tener píxeles transparentes en su interior. Por otra parte, antes de llamar
                                a la correspondiente función addColour para cada sprite se vuelve a dar a la variable
                                global <i>n</i> el valor 0, de tal forma que se pueda iterar de nuevo por todos los
                                bloques de cada nuevo sprite que queramos colorear. Esto se puede ver también en el caso
                                de los tres sprites para el esquiador.</p>
                            <p>Una vez creados los sprites se utilizan las siguientes instrucciones:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

                                <tr>
                                    <td><p class="codigo">
                                        <pre>
	i = spriteSkiCentrado;

        sp_MoveSprAbs(ski, sp_ClipStruct, 0, 0, 15, 0, 0);
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>El puntero <i>ski</i> apuntará en todo momento al sprite del esquiador que deba ser
                                mostrado por pantalla. El esquiador comenzará mirando hacia abajo, ya que no se está
                                moviendo ni a izquierda ni a derecha; por lo tanto, <i>ski</i> apuntará al sprite <i>spriteSkiCentrado</i>,
                                que es el que deberá ser visualizado. Cada vez que el esquiador se mueva a izquierda o
                                derecha, <i>ski</i> apuntará, respectivamente, a <i>spriteSkiIzquierda</i> y <i>spriteSkiDerecha</i>.
                            </p>

                            <p>En el bucle principal iniciado por la sentencia <i>while(1)</i> y que se ejecutará de
                                forma infinita, vemos como se resuelve el tema de la animación del protagonista, la
                                limitación de sus movimientos por la pantalla, y el movimiento de las rocas. Comencemos
                                por la primera parte de dicho bucle, que es donde encontramos el código referido al
                                movimiento del esquiador:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
		 i = sp_JoyKeyboard(&keys);
		 dx = 0;
		 dy = 0;
		 if ((i & sp_LEFT) == 0 && ski->col > 0)
		 {
		    if (posicion != -1)
		    {
		    	sp_MoveSprAbs(spriteSkiIzquierda,sp_ClipStruct,0,ski->row,ski->col,0,0);
		    	sp_MoveSprAbs(ski,sp_ClipStruct,0,0,-10,0,0);
		    	ski = spriteSkiIzquierda;
			posicion = -1;
		    }
		    dx = -3;
		 }
		 else if ((i & sp_RIGHT) == 0 && ski->col < 30)
		 {
	            if (posicion != 1)
		    {
			sp_MoveSprAbs(spriteSkiDerecha,sp_ClipStruct,0,ski->row,ski->col,0,0);
			sp_MoveSprAbs(ski,sp_ClipStruct,0,0,-10,0,0);
			ski = spriteSkiDerecha;
			posicion = 1;
		    }
		    dx = 3;
		 }
		 else
		 {
		    if (posicion != 0)
		    {
			    sp_MoveSprAbs(spriteSkiCentrado,sp_ClipStruct,0,ski->row,ski->col,0,0);
		            sp_MoveSprAbs(ski,sp_ClipStruct,0,0,-10,0,0);
		    	    ski = spriteSkiCentrado;
			    posicion = 0;
		    }
		 }
	         if (dx != 0) sp_MoveSprRel(ski, sp_ClipStruct, 0, 0, 0, dx, dy);

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Cada vez que el esquiador cambia de posición, se debe hacer apuntar a <i>ski</i> hacia el
                                sprite adecuado. Esto sólo se debe hacer en la primera iteración en la que estemos
                                moviéndonos en esa dirección. Para ello se observa que se utiliza una variable <i>posicion</i>,
                                inicializada a cero, y que valdrá precisamente 0 si el sprite a mostrar por pantalla
                                debe ser <i>spriteSkiCentrado</i>, y -1 o 1 si se debe mostrar el esquiador
                                desplazándose hacia la izquierda o la derecha, respectivamente. Este valor nos va a
                                permitir saber cuándo debemos hacer que el puntero <i>ski</i> apunte hacia otro sprite
                                diferente del que lo estaba haciendo hasta ese momento.</p>
                            <p>Veámoslo con un ejemplo. Supongamos que el esquiador se está deslizando ladera abajo, sin
                                que el jugador lo mueva a izquierda o derecha. En este caso, <i>ski</i> apunta a <i>spriteSkiCentrado</i>,
                                y <i>posicion</i> vale 0. A continuación, el jugador pulsa la tecla de la derecha y la
                                mantiene presionada. En la primera iteración en la que esto sucede, se realizan las
                                siguientes acciones:</p>

                            <ul>
                                <li>Se mueve <i>spriteSkiDerecha</i>, que representa al esquiador desplazándose en esa
                                    dirección, a la misma posición de la pantalla donde se encuentra el sprite del
                                    esquiador centrado, que es el que se estaba mostrando hasta ahora. Para conocer esa
                                    posición se hace uso de los campos <i>row</i> y <i>col</i> de la estructura
                                    <i>ski</i>.
                                </li>
                                <li>A continuación, el sprite apuntado por <i>ski</i> se mueve fuera de la pantalla,
                                    pues no va a ser mostrado más.
                                </li>

                                <li>La variable <i>ski</i> apunta a <i>spriteSkiDerecha</i>, para poder mostrarlo por la
                                    pantalla.
                                </li>
                                <li>Se cambia el valor de <i>posicion</i> a 1, indicando que ya hemos estado al menos
                                    una iteración desplazándonos hacia la derecha y que no es necesario repetir todas
                                    estas operaciones en el caso en el que sigamos moviéndonos en esta dirección.
                                </li>
                            </ul>
                            <p>Sólo podremos desplazarnos hacia la izquierda o la derecha siempre que nos encontremos
                                dentro de los límites de la pantalla. Esto se controla de la siguiente forma:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
if ((i & sp_LEFT) == 0 <font color="red">&& ski->col > 0</font>)

else if ((i & sp_RIGHT) == 0 <font color="red">&& ski->col < 30</font>)
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Con respecto a las rocas, moveremos tan solo una en cada iteración del bucle principal.
                                Esto no es más que una medida preliminar para conseguir un mínimo de velocidad y algo de
                                sincronización, pero es evidente que deberemos modificar este apartado del código más
                                adelante. Para poder desplazar tan solo una roca en cada iteración, hacemos uso de la
                                variable <i>roca</i>, inicializada a cero, que nos va a indicar cual de todas las rocas
                                va a ser movida. Esta variable se incrementa en 1 cada vez, volviéndole a asignar el
                                valor 0 cuando almacena un entero superior al valor indicado por NUM_ROCAS. Finalmente,
                                y como se puede observar en el código siguiente, esta variable <i>roca</i> se utiliza
                                como indice del array de sprites de tipo roca, determinando qué roca se mueve.</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
		 if (spriteRoca[roca]->row != -10)
		 {
		    dx = 0;
		    dy = -4;
		    sp_MoveSprRel(spriteRoca[roca],sp_ClipStruct,0,0,0,dx,dy);
		 }
		 else
		    if (rand()%100>98)
		    {
			sp_MoveSprAbs(spriteRoca[roca],sp_ClipStruct,0,23,rand()%29+1,0,4);
		    }
 		 roca ++;
		 if (roca >= NUM_ROCAS)
	            roca = 0;
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Cada roca se desplazará hacia arriba en la pantalla usando un valor de desplazamiento <i>dy
                                = -4</i>, hasta llegar a un valor de -10 en su coordenada y. En ese momento, la roca ya
                                habrá desaparecido de la pantalla por su parte superior. Si una roca está fuera de la
                                pantalla, volveremos a sacarla por debajo de nuevo en una posición x al azar (como si
                                fuera otra roca distinta) con una probabilidad del 98% (para que una roca que ha salido
                                por la parte superior de la pantalla no vuelva a aparecer inmediatamente por la parte
                                inferior y que efectivamente parezca una roca diferente). Se podría modificar el valor
                                de la constante <i>NUM_ROCAS</i> para cambiar el número de obstáculos, pero se ha
                                escogido un valor que hace que el juego no vaya demasiado lento.</p>

                            <p>Una vez que compilamos y ejecutamos nuestro juego, nos encontramos con tres problemas,
                                que trataremos de resolver en artículos sucesivos:</p>
                            <ul>
                                <li>No hay colisiones. Nuestro esquiador parece un fantasma, pues puede atravesar las
                                    rocas sin que éstas le afecten. Eso es porque no hemos establecido un control de
                                    colisiones.
                                </li>
                                <li>No hay sincronización. Esto quiere decir que la velocidad del juego es diferente
                                    según el número de rocas que se estén mostrando en determinado momento por la
                                    pantalla. Haciendo uso de las interrupciones podremos conseguir que haya el número
                                    de rocas que haya, la velocidad de descenso se mantenga constante.
                                </li>
                                <li>Colour clash. Cuando nuestro esquiador y las rocas entran en contacto, se produce un
                                    choque de atributos bastante desagradable (los colores de los sprites parecen
                                    "mezclarse"). Esto también se puede medio resolver.
                                </li>
                            </ul>
                            <p>Por último, un apunte sobre la liberación de memoria. Como hemos visto, cada vez que
                                queremos mostrar un sprite por pantalla, debemos reservar memoria para el mismo. En el
                                caso en el que un sprite no vaya a ser mostrado nunca más, lo más adecuado es liberar la
                                memoria correspondiente, <b>tras</b> haber movido dicho sprite fuera de la pantalla para
                                evitar efectos no deseados.</p>
                            <p><b>Y EN EL PRÓXIMO NUMERO</b></p>

                            <p>¡La programación de nuestro juego ha comenzado! Sin embargo, nos encontramos con varios
                                problemas, tal como se ha comentado anteriormente; problemas que intentaremos resolver
                                en sucesivas entregas del curso centrándonos en tres aspectos: cómo solucionar el
                                problema conocido como colour clash, el uso de IM2 (interrupciones), y la intersección
                                de rectángulos para detección de colisiones. Gracias a estos elementos nuestro juego
                                quedará mucho más completo y jugable. Con unos pocos añadidos más podría incluso
                                compararse a las grandes producciones comerciales de 1983 ;).</p>
                            <b>LINKS</b>
                            </p>
                            <ul>
                                <li><a href="revistas/14/src/z88dk9_codigo.tar.gz"
                                       onClick="window.open(this.href); return false;">Código fuente</a></li>
                            </ul>
                        </div>
                    </td>
                </tr>
                <tr>

                    <td align="right"><br><br>SIEW</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td> </td>
    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarPie(url) {
                document.location = url;
              }

            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('hardware.html');" name="anterior"
                                   value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>

                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>
                                <option value="hardware.html">Hardware</option>
                                <option value="z88dk.html" selected>Programación Z88DK</option>
                                <option value="input.html">INPUT</option>
                                <option value="ensamblador.html">Programación Ensamblador</option>

                            </select>
                            <input type="button" onclick="RecargarCabecera('input.html');" name="siguiente" value=">"/>
                        </td>
                        <td align="right" class="texto">
                            <a href="#arriba">Volver arriba</a>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/lista-revistas.html"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>
                </form>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
                <tr align="center" valign="center">
                    <td>2003-2009 Magazine ZX</td>
                </tr>
            </table>
        </td>
    </tr>
</table>
</body>
</html>
