<!doctype html>
<html lang="es">
<head>
    <title>Programación Ensamblador - Magazine ZX número 14 - Diciembre 2006</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/magazine.css" type="text/css">
</head>
<body>
<table bgcolor="#F9F9FF" border="0" cellspacing="0" cellpadding="0" width="720">
    <tr>
        <td>
            <a name="arriba"></a>
            <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE">
                <tr align="center" valign="center">
                    <td><a href="/"><img src="../img/logo_grande.gif" width="174" height="87" border="0"/></a></td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <script type="text/javascript">
              function RecargarCabecera(url) {
                document.location = url;
              }
            </script>
            <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
                <form name="selector_secciones">
                    <tr>
                        <td colspan="4" align="center" bgcolor="#FFFFFF" class="texto">> <a href="/"><b>ÍNDICE
                            DE REVISTAS</b></a> <
                        </td>
                    </tr>
                    <tr>
                        <td align="left">
                            <input type="button" onclick="RecargarCabecera('input.html');" name="anterior" value="<"/>
                            <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                                <option value="index.html">Portada</option>
                                <option value="editorial.html">Índice - Editorial</option>
                                <option value="panorama.html">Panorama</option>
                                <option value="analisis.html">Análisis</option>

                                <option value="hardware.html">Hardware</option>
                                <option value="z88dk.html">Programación Z88DK</option>
                                <option value="input.html">INPUT</option>
                                <option value="ensamblador.html" selected>Programación Ensamblador</option>
                            </select>
                            <input type="button" onclick="return false;" name="siguiente" value=">" disabled/>
                        </td>

                        <td align="center" class="texto">Número 14 - Diciembre 2006</td>
                        <td align="right"><a href="http://www.worldofspectrum.org/viewcert.cgi?candidate=Magazine+ZX"
                                             onClick="window.open(this.href); return false;"><img
                                src="https://www.worldofspectrum.org/pics/zxcert.png" width="87" height="30" border="0"
                                alt="ZX Certified webmaster"></a> <a href="http://www.speccy.org/"
                                                                     onClick="window.open(this.href); return false;"><img
                                src="../img/logo_speccyorg.gif" border="0" width="121" height="30" alt="speccy.org"></a>
                        </td>
                    </tr>
                </form>
            </table>
            </a>
        </td>
    </tr>
    <tr>
        <td> </td>
    </tr>

    <tr>
        <td>
            <table border="0" cellspacing="0" cellpadding="8" width="720" class="texto">
                <tr>
                    <td>
                        <div align="justify">
                            <p align="center"><font size="5">Lenguaje Ensamblador del Z80 (I)</font></p>
                            <p><strong>LA ARQUITECTURA DEL SPECTRUM</strong></p>
                            <p>En esta tercera entrega del curso explicaremos la sintaxis utilizada en los programas en
                                ensamblador. Para ello comenzaremos con una definición general de la sintaxis del
                                lenguaje para el ensamblador Pasmo, que será el "traductor" que usaremos entre el
                                lenguaje ensamblador y el código máquina del Z80.</p>
                            <p>Posteriormente veremos en detalle los registros: qué registros hay disponibles, cómo se
                                agrupan, y el registro especial de Flags, enlazando el uso de estos registros con las
                                instrucciones de carga, de operaciones aritméticas, y de manejo de bits, que serán las
                                que trataremos hoy.</p>

                            <p>Esta entrega del curso es delicada y complicada: por un lado, tenemos que explicar las
                                normas y sintaxis del ensamblador cruzado PASMO antes de que conozcamos la sintaxis del
                                lenguaje ensamblador en sí, y por el otro, no podremos utilizar PASMO hasta que
                                conozcamos la sintaxis del lenguaje.</p>
                            <p>Además, el lenguaje ensamblador tiene disponibles muchas instrucciones diferentes, y nos
                                resultaría imposible explicarlas todas en un mismo capítulo, lo que nos fuerza a
                                explicar las instrucciones del microprocesador en varias entregas. Esto implica que
                                hablaremos de PASMO comentando reglas, opciones de instrucciones y directivas que
                                todavía no conocemos.</p>
                            <p>Es por esto que recomendamos al lector que, tras releer los capítulos 1 y 2 de nuestro
                                curso, se tome esta entrega de una manera especial, leyéndola 2 veces. La "segunda
                                pasada" sobre el texto permitirá enlazar todos los conocimientos dispersos en el mismo,
                                y que no pueden explicarse de una manera lineal porque están totalmente
                                interrelacionados. Además, la parte relativa a la sintaxis de PASMO será una referencia
                                obligada para posteriores capítulos (mientras continuemos viendo diferentes
                                instrucciones ASM y ejemplos).</p>
                            <p>Así pues, os recomendamos leer este capítulo dos veces, una para absorber las normas de
                                PASMO, y otra para absorber la sintaxis del lenguaje y las instrucciones que
                                explicaremos (terminando de comprender conceptos de la primera lectura).</p>
                            <p><strong>SINTAXIS DEL LENGUAJE EN PASMO</strong></p>
                            <p>En la primera parte de curso se introdujo PASMO, el ensamblador cruzado que recomendamos
                                para el desarrollo de programas para Spectrum. Este ensamblador traduce nuestros
                                ficheros de texto .asm con el código fuente de programa (en lenguaje ensamblador) a
                                ficheros .bin (o .tap/.tzx) que contendrán el código máquina directamente ejecutable por
                                el Spectrum. Suponemos que ya tenéis instalado PASMO (ya sea la versión Windows o la de
                                Linux) en vuestro sistema y que sabéis utilizarlo (os recomiendo que releáis la primera
                                entrega de nuestro curso si no recordáis su uso), y que podéis ejecutarlo dentro del
                                directorio de trabajo que habéis elegido (por ejemplo: /home/usuario/z80asm o
                                C:\z80asm).</p>
                            <p>El ciclo de desarrollo con PASMO será el siguiente:</p>
                            <ul>
                                <li>Con un editor de texto, tecleamos nuestro programa en un fichero .ASM con la
                                    sintaxis que veremos a continuación.
                                </li>

                                <li>Salimos del editor de texto y ensamblamos el programa con: "pasmo ejemplo1.asm
                                    ejemplo1.bin".
                                </li>
                                <li>El fichero bin contiene el código máquina resultante, que podemos POKEar en memoria,
                                    cargar como un bloque CM (LOAD "" CODE) tras nuestro programa BASIC, o bien si el
                                    programa está realizado enteramente en ensamblador, hacer un pequeño cargador (o
                                    usar bin2tap o --bastap) y cargar directamente el programa en el Spectrum.
                                </li>
                            </ul>
                            <p>Todo esto se mostró bastante detalladamente en su momento en el número 1 de nuestro
                                curso.</p>
                            <p>Con esto, sabemos ensamblar programas creados adecuadamente, de modo que la pregunta es:
                                ¿cómo debo escribir mi programa para que PASMO pueda ensamblarlo? Es sencillo,
                                escribiremos nuestro programa en un fichero de texto con extensión (por ejemplo) .asm.
                                En este fichero de texto se ignorarán las líneas en blanco y los comentarios, que en ASM
                                de Z80 se introducen con el símbolo ";" (punto y coma), de forma que todo lo que el
                                ensamblador encuentre a la derecha de un ; será ignorado (siempre que no forme parte de
                                una cadena). Ese fichero de texto será ensamblado por PASMO y convertido en código
                                binario.</p>
                            <p>Lo que vamos a ver a continuación son las normas que debe cumplir un programa para poder
                                ser ensamblado en PASMO. Es necesario explicar estas reglas para que el lector pueda
                                consultarlas en el futuro, cuando esté realizando sus propios programas. No te preocupes
                                si no entiendes alguna de las reglas, cuando llegues al momento de implementar tus
                                primeras rutinas, las siguientes normas te serán muy útiles:</p>
                            <ul>
                                <li><p>Normas para las instrucciones:</p>
                                    <ul>
                                        <li>Pondremos una sóla instrucción de ensamblador por línea.</li>

                                        <li>Como existen diferencias entre los "fin de línea" entre Linux y Windows, es
                                            recomendable que los programas se ensamblen con PASMO en la misma plataforma
                                            de S.O. en que se han escrito. Si PASMO intenta compilar en Windows un
                                            programa ASM escrito en un editor de texto de Linux (con retornos de carro
                                            de Linux) es posible que obtengamos errores de compilación (aunque no es
                                            seguro). Si os ocurre al compilar los ejemplos que os proporcionamos (están
                                            escritos en Linux) y usáis Windows, lo mejor es abrir el fichero .ASM con
                                            notepad y grabarlo de nuevo (lo cual lo salvará con formato de retornos de
                                            carro de Windows). El fichero "regrabado" con Notepad podrá ser ensamblado
                                            sin problemas.
                                        </li>
                                        <li>Además de una instrucción por línea podremos añadir etiquetas (para
                                            referenciar a dicha línea, algo que veremos posteriormente) y comentarios
                                            (con ';').
                                        </li>
                                    </ul>
                                </li>
                                <li><p>Normas para los valores numéricos:</p>
                                    <ul>
                                        <li>Todos los valores numéricos se considerarán, por defecto, escritos en
                                            decimal.
                                        </li>
                                        <li>Para introducir valores números en hexadecimal los precederemos del carácter
                                            "$", y para escribir valores numéricos en binario lo haremos mediante el
                                            carácter "%".
                                        </li>

                                        <li>Podremos también especificar la base del literal poniendoles como prefijo
                                            las cadena &H ó 0x (para hexadecimal) o &O (para octal).
                                        </li>
                                        <li>Podemos especificar también los números mediante sufijos: Usando una "H"
                                            para hexadecimal, "D" para decimal, "B" para binario u "O" para octal (tanto
                                            mayúsculas como minúsculas).
                                        </li>
                                    </ul>
                                </li>
                                <li><p>Normas para cadenas de texto:</p>
                                    <ul>

                                        <li>Podemos separar las cadenas de texto mediante comillas simples o dobles.
                                        </li>
                                        <li>El texto encerrado entre comillas simples no recibe ninguna interpretación,
                                            excepto si se encuentran 2 comillas simples consecutivas, que sirven para
                                            introducir una comilla simple en la cadena.
                                        </li>
                                        <li>El texto encerrado entre comillas dobles permite introducir caracteres
                                            especiales al estilo de C/C++ como \n, \r o \t (nueva línea, retorno de
                                            carro, tabulador...).
                                        </li>
                                        <li>El texto encerrado entre comillas dobles también admite \xNN para introducir
                                            el carácter correspondiente a un número hexadecimal NN.
                                        </li>
                                        <li>Una cadena de texto de longitud 1 (un carácter) puede usarse como una
                                            constante (valor ASCII del carácter) en expresiones como, por ejemplo,
                                            'C'+10h.
                                        </li>
                                    </ul>

                                </li>
                                <li><p>Normas para los nombres de ficheros:</p>
                                    <ul>
                                        <li>Si vemos que nuestro programa se hace muy largo, podemos partir el fichero
                                            en varios ficheros e incluirlos mediante directivas INCLUDE (para incluir
                                            ficheros ASM) o INCBIN (para incluir código máquina ya compilado). Al
                                            especificar nombres de ficheros, deberán estar entre dobles comillas o
                                            simples comillas.
                                        </li>
                                    </ul>
                                </li>
                                <li><p>Normas para los identificadores:</p>
                                    <ul>
                                        <li>Los identificadores son los nombres usados para etiquetas y símbolos
                                            definidos mediante EQU y DEFL.
                                        </li>

                                        <li>Podemos utilizar cualquier cadena de texto, excepto los nombres de las
                                            palabras reservadas de ensamblador.
                                        </li>
                                    </ul>
                                </li>
                                <li><p>Normas para las etiquetas:</p>
                                    <ul>
                                        <li>Una etiqueta es un identificador de texto que ponemos poner al principio de
                                            cualquier línea de nuestro programa.
                                        </li>
                                        <li>Podemos añadir el tradicional sufijo ":" a las etiquetas, pero también es
                                            posible no incluirlo si queremos compatibilidad con otros ensambladores que
                                            no lo soporten (por si queremos ensamblar nuestro programa con otro
                                            ensamblador que no sea pasmo).
                                        </li>
                                        <li>Para PASMO, cualquier referencia a una etiqueta a lo largo del programa se
                                            convierte en una referencia a la posición de memoria donde se ensambla la
                                            instrucción o dato donde hemos colocado la etiqueta. Podemos utilizar así
                                            etiquetas para hacer referencia a nuestros gráficos, variables, datos,
                                            funciones, lugares a donde saltar, etc.
                                        </li>

                                    </ul>
                                </li>
                                <li><p>Directivas:</p>
                                    <ul>
                                        <li>Tenemos a nuestra disposición una serie de directivas para facilitarnos la
                                            programación, como DEFB o DB para introducir datos en crudo en nuestro
                                            programa, END para finalizar el programa, IF/ELSE/ENDIF en tiempo de
                                            compilación, INCLUDE e INCBIN, MACRO y REPT.
                                        </li>
                                        <li>Una de las directivas más importantes es ORG, que indica la posición origen
                                            donde almacenar el código que la sigue. Podemos utilizar diferentes
                                            directivas ORG en un mismo programa.
                                        </li>
                                        <li>Iremos viendo el significado de las directivas conforme las vayamos usando,
                                            pero es aconsejable consultar el <a
                                                    href="http://www.arrakis.es/~ninsesabe/pasmo/pasmodoc.html#directives">manual
                                                de PASMO</a> para conocer más sobre ellas.
                                        </li>

                                    </ul>
                                </li>
                                <li><p><a href="http://www.arrakis.es/~ninsesabe/pasmo/pasmodoc.html#operators">Operadores</a>:
                                </p>
                                    <ul>
                                        <li>Podemos utilizar los operadores típicos +, -, *. /, así como otros
                                            operadores de desplazamiento de bits como >> y <<.
                                        </li>
                                        <li>Tenemos disponibles operadores de comparación como EQ, NE, LT, LE, GT, GE o
                                            los clásicos =, !=, <, >, <=, >=.
                                        </li>

                                        <li>Existen también operadores lógicos como AND, OR, NOT, o sus variantes &, |,
                                            !.
                                        </li>
                                        <li>Los operadores sólo tienen aplicación en tiempo de ensamblado, es decir, no
                                            podemos multiplicar o dividir en tiempo real en nuestro programa usando * o
                                            /. Estos operadores están pensados para que podamos poner expresiones como
                                            ((32*10)+12), en lugar del valor numérico del resultado, por ejemplo.
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <p><strong>ASPECTO DE UN PROGRAMA EN ENSAMBLADOR</strong></p>
                            <p>Veamos un ejemplo de programa en ensamblador que muestra el uso de algunas de estas
                                normas, para que las podamos entender fácilmente mediante los comentarios incluidos:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
; Programa de ejemplo para mostrar el aspecto de
; un programa típico en ensamblador para PASMO.
; Copia una serie de bytes a la videomemoria con
; instrucciones simples (sin optimizar).
ORG 40000

valor     EQU  1
destino   EQU  18384

  ; Aqui empieza nuestro programa que copia los
  ; 7 bytes desde la etiqueta "datos" hasta la
  ; videomemoria ([16384] en adelante).

  LD HL, destino     ; HL = destino (VRAM)
  LD DE, datos       ; DE = origen de los datos
  LD B, 6            ; numero de datos a copiar

bucle:               ; etiqueta que usaremos luego

  LD A, (DE)         ; Leemos un dato de [DE]
  ADD A, valor       ; Le sumamos 1 al dato leído
  LD (HL), A         ; Lo grabamos en el destino [HL]
  INC DE             ; Apuntamos al siguiente dato
  INC HL             ; Apuntamos al siguiente destino

  DJNZ bucle         ; Equivale a:
                     ; B = B-1
                     ; if (B>0) goto Bucle
  RET

datos DEFB 127, %10101010, 0, 128, $FE, %10000000, FFh

END
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Algunos detalles a tener en cuenta:</p>
                            <ul>
                                <li>Como veis, se pone una instrucción por línea.</li>
                                <li>Los comentarios pueden ir en sus propias líneas, o dentro de líneas de instrucciones
                                    (tras ellas).
                                </li>
                                <li>Podemos definir "constantes" con EQU para hacer referencia a ellas luego en el
                                    código. Son constantes, no variables, es decir, se definen en tiempo de ensamblado y
                                    no se cambian con la ejecución del programa. Su uso está pensado para poder escribir
                                    código más legible y que podamos cambiar los valores asociados posteriormente de una
                                    forma sencilla (es más fácil cambiar el valor asignado en el EQU, que cambiar un
                                    valor en todas sus apariciones en el código).
                                </li>

                                <li>Podemos poner etiquetas (como "bucle" y "datos" -con o sin dos puntos, son
                                    ignorados-) para referenciar a una posición de memoria. Así, la etiqueta "bucle" del
                                    programa anterior hace referencia a la posición de memoria donde se ensamblaría la
                                    siguiente instrucción que aparece tras ella. Las etiquetas se usan para poder saltar
                                    a ellas (en los bucles y condiciones) mediante un nombre en lugar de tener que
                                    calcular nosotros la dirección del salto a mano y poner direcciones de memoria. Es
                                    más fácil de entender y programar un "DJNZ bucle" que un "DJNZ 40008", por ejemplo.
                                    En el caso de la etiqueta "datos", nos permite referenciar la posición en la que
                                    empiezan los datos que vamos a copiar.
                                </li>
                                <li>Los datos definidos con DEFB pueden estar en cualquier formato numérico, como se ha
                                    mostrado en el ejemplo: decimal, binario, hexadecimal tanto con prefijo "$" como con
                                    sufijo "h", etc.
                                </li>
                            </ul>
                            <p>Podéis ensamblar el ejemplo anterior mediante:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
pasmo --tapbas ejemplo.asm ejemplo.tap
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p>Una vez cargado y ejecutado el TAP en el emulador de Spectrum, podréis ejecutar el código
                                máquina en BASIC con un "RANDOMIZE USR 40000", y deberéis ver una pantalla como la
                                siguiente:</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="319">
                                <tr align="right">
                                    <td><img src="img/ejemplo1.gif" width="319" height="239"
                                             alt="Salida del ejemplo 1"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Salida del ejemplo 1</td>

                                </tr>
                            </table>

                            <p>Los píxeles que aparecen en el centro de la pantalla se corresponden con los valores
                                numéricos que hemos definido en "datos", ya que los hemos copiado desde "datos" hasta la
                                videomemoria. No os preocupéis por ahora si no entendéis alguna de las instrucciones
                                utilizadas, las iremos viendo poco a poco y al final tendremos una visión global y
                                concreta de todas ellas.</p>
                            <p><strong>LOS REGISTROS</strong></p>
                            <p>Como ya vimos en la anterior entrega, todo el "trabajo de campo" lo haremos con los
                                registros de la CPU, que no son más que variables de 8 y 16 bits integradas dentro del
                                Z80 y que por tanto son muy rápidos para realizar operaciones con ellos.</p>
                            <p>El Z80 tiene una serie de registros de 8 bits con nombres específicos:</p>
                            <ul>
                                <li>A: El Registro A (de 8 bits) es el acumulador. Es un registro que se utiliza
                                    generalmente como destino de muchas operaciones aritméticas y de comparaciones y
                                    testeos.
                                </li>
                                <li>B, C, D, E, H, L: Registros de propósito general, utilizables para gran cantidad de
                                    operaciones, almacenamiento de valores, etc.
                                </li>

                                <li>I: Registro de interrupción, no lo utilizaremos en nuestros primeros programas. No
                                    debemos modificar su valor, aunque en el futuro veremos su uso en las interrupciones
                                    del Spectrum.
                                </li>
                                <li>R: Registro de Refresco de memoria: lo utiliza internamente la CPU para saber cuándo
                                    debe refrescar la RAM. Su valor cambia sólo conforme el Z80 va ejecutando
                                    instrucciones, de modo que podemos utilizarlo (leerlo) para obtener valores
                                    pseudo-aleatorios entre 0 y 255.
                                </li>
                            </ul>
                            <p>Además, podemos agrupar algunos de estos registros en pares de 16 bits para determinadas
                                operaciones:</p>
                            <ul>
                                <li>AF: Formado por el registro A como byte más significativo (Byte alto) y por F como
                                    byte menos significativo (Byte bajo). Si A vale FFh y B vale 00h, AF valdrá
                                    automáticamente "FF00h".
                                </li>
                                <li>BC: Agrupación de los registros B y C que se puede utilizar en bucles y para acceder
                                    a puertos. También se utiliza como "repetidor" o "contador" en las operaciones de
                                    acceso a memoria (LDIR, LDDR, etc.).
                                </li>
                                <li>DE, HL: Registros de 16 bits formados por D y E por un lado y H y L por otro.
                                    Utilizaremos generalmente estos registros para leer y escribir en memoria en una
                                    operación única, así como para las operaciones de acceso a memoria como LDIR, LDDR,
                                    etc.
                                </li>

                            </ul>
                            <p>Aparte de estos registros, existen otra serie de registros de 16 bits:</p>
                            <ul>
                                <li>IX, IY: Dos registros de 16 bits pensados para acceder a memoria de forma indexada.
                                    Gracias a estos registros podemos realizar operaciones como: "LD
                                    (IX+desplazamiento), VALOR". Este tipo de registros se suele utilizar pues para
                                    hacer de índices dentro de tablas o vectores. El desplazamiento es un valor numérico
                                    de 8 bits en complemento a 2, lo que nos permite un rango desde -128 a +127 (puede
                                    ser negativo para acceder a posiciones de memoria anteriores a IX).
                                </li>
                                <li>SP: Puntero de pila, como veremos en su momento apunta a la posición actual de la
                                    "cabeza" de la pila.
                                </li>
                                <li>PC: Program Counter o Contador de Programa. Como ya vimos en la anterior entrega,
                                    contiene la dirección de la instrucción actual a ejecutar. No modificaremos PC
                                    directamente moviendo valores a este registro, sino que lo haremos mediante
                                    instrucciones de salto (JP, JR, CALL...).
                                </li>
                            </ul>
                            <p>Por último, tenemos disponible un banco alternativo de registros, conocidos como Shadow
                                Registers o Registros Alternativos, que se llaman igual que sus equivalentes principales
                                pero con una comilla simple detrás: A', F', B', C', D'. E', H' y L'.</p>
                            <p>En cualquier momento podemos intercambiar el valor de los registros A, B, C, D, E, F, H y
                                L con el valor de los registros A', B', C', D', E', F', H' y L' mediante la instrucción
                                de ensamblador "EXX", como veremos más adelante. La utilidad de estos Shadow Registers
                                es almacenar valores temporales y proporcionarnos más registros para operar: podremos
                                intercambiar el valor de los registros actuales con los temporales, realizar operaciones
                                con los registros sin perder los valores originales (que al hacer el EXX se quedarán en
                                los registros Shadow), y después recuperar los valores originales volviendo a ejecutar
                                un EXX.</p>

                            <p>Ya conocemos los registros disponibles, veamos ahora ejemplos de operaciones típicas que
                                podemos realizar con ellos:</p>
                            <ul>
                                <li>Meter valores en registros (ya sean valores numéricos directos, de memoria, o de
                                    otros registros).
                                </li>
                                <li>Incrementar o decrementar los valores de los registros.</li>
                                <li>Realizar operaciones (tanto aritméticas como lógicas) entre los registros.</li>
                                <li>Acceder a memoria para escribir o leer.</li>
                            </ul>
                            <p>Por ejemplo, las siguientes instrucciones en ensamblador serían válidas:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
  LD C, $00       ; C vale 0
  LD B, $01       ; B vale 1
                  ; con esto, BC = $0100
  LD A, B         ; A ahora vale 1
  LD HL, $1234    ; HL vale $1234 o 4660d
  LD A, (HL)      ; A contiene el valor de (4660)
  LD A, (16384)   ; A contiene el valor de (16384)
  LD (16385), A   ; Escribimos en (16385) el valor de A
  ADD A, B        ; Suma: A = A + B
  INC B           ; Incrementamos B (B = 1+1 =2)
                  ; Ahora BC vale $0200
  INC BC          ; Incrementamos BC
                  ; (BC = $0200+1 = $0201)
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Dentro del ejemplo anterior queremos destacar el operador "()", que significa "el
                                contenido de la memoria apuntado por". Así, "LD A, (16384)" no quiere decir "mete en A
                                el valor 16384" (cosa que además no se puede hacer porque A es un registro de 8 bits),
                                sino "mete en A el valor de 8 bits que contiene la celdilla de memoria 16384"
                                (equivalente a utilizar en BASIC las funciones PEEK y POKE, como en LET A=PEEK
                                16384).</p>
                            <p>Cabe destacar un gran inconveniente del juego de instrucciones del Z80, y es que no es
                                ortogonal. Se dice que el juego de instrucciones de un microprocesador es ortogonal
                                cuando puedes realizar todas las operaciones sobre todos los registros, sin presentar
                                excepciones. En el caso del Z80 no es así, ya que hay determinadas operaciones que
                                podremos realizar sobre unos registros pero no sobre otros. </p>
                            <p>Así, si el Z80 fuera ortogonal, podríamos ejecutar cualquiera de estas operaciones:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

                                <tr>
                                    <td><p class="codigo">
                                        <pre>
  LD BC, 1234h
  LD HL, BC
  LD SP, BC
  EX DE, HL
  EX BC, DE
  ADD HL, BC
  ADD DE, BC
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Sin embargo, como el Z80 no tiene un juego de instrucciones (J.I. desde este momento)
                                ortogonal, hay instrucciones del ejemplo anterior que no son válidas, es decir, que no
                                tienen dentro de la CPU un microcódigo para que el Z80 sepa qué hacer con ellas:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
  LD SP, BC      ; NO: No se puede cargar el valor un registro en SP,
                 ; sólo se puede cargar un valor inmediato NN

  EX BC, DE      ; NO: Existe EX DE, HL, pero no EX BC, DE

  ADD DE, BC     ; NO: Sólo se puede usar HL como operando destino
                 ; en las sumas de 16 bytes con registros de propósito
                 ; general.

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Si el J.I. fuera ortogonal, se podría realizar cualquier operación con cualquier
                                registro, como por ejemplo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
  LD BC, DE
  LD DE, HL
  LD SP, BC      ; Se podría realizar
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Pero "LD SP, BC" es una excepción, y no existe como instrucción del Z80. Y como el caso
                                de "LD SP, BC" existen muchos otros de instrucciones que aceptan unos registros como
                                operandos pero no otros. </p>

                            <p>La única solución para programar sin tratar de utilizar instrucciones no permitidas es la
                                práctica: con ella acabaremos conociendo qué operaciones podemos realizar y sobre qué
                                registros se pueden aplicar, y realizaremos nuestros programas con estas limitaciones en
                                mente. Iremos viendo las diferentes excepciones caso a caso, pero podemos encontrar las
                                nuestras propias gracias a los errores que nos dará el ensamblador al intentar ensamblar
                                un programa con una instrucción que no existe para el Z80.</p>
                            <p>No os preocupéis: es sólo una cuestión de práctica. Tras haber realizado varios programas
                                en ensamblador ya conoceréis, prácticamente de memoria, qué instrucciones son válidas
                                para el microprocesador y cuáles no.</p>
                            <p><strong>EL REGISTRO DE FLAGS</strong></p>
                            <p>Hemos hablado del registro de 8 bits F como un registro especial. La particularidad de F
                                es que no es un registro de propósito general donde podamos introducir valores a
                                voluntad, sino que los diferentes bits del registro F tienen un significado propio que
                                cambia automáticamente según el resultado de operaciones anteriores.</p>
                            <p>Por ejemplo, uno de los bits del registro F, el bit nº 6, es conocido como "Zero Flag", y
                                nos indica si el resultado de la última operación (para determinadas operaciones, como
                                las aritméticas o las de comparación) es cero o no es cero. Si el resultado de la
                                anterior operación resultó cero, este FLAG se pone a uno. Si no resultó cero, el flag se
                                pone a cero.</p>
                            <p>¿Para qué sirve pues un flag así? Para gran cantidad de tareas, por ejemplo para bucles
                                (repetir X veces una misma tarea poniendo el registro BC al valor X, ejecutando el mismo
                                código hasta que BC sea cero), o para comparaciones (mayor que, menor que, igual
                                que).</p>
                            <p>Veamos los diferentes registros de flags (bits del registro F) y su utilidad:</p>

                            <table border="0" cellspacing="0" cellpadding="2" width="400">
                                <tr align="right">

                                    <td><img src="img/registrof.gif" width="400" height="300"
                                             alt="Los indicadores de flag del registro F"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="piefoto" align="right">Los indicadores de flag del registro F</td>
                                </tr>
                            </table>

                            <ul>
                                <li><p>Flag S (sign o signo): Este flag se pone a uno si el resultado de la operación
                                    realizada en complemento a dos es negativo (es una copia del bit más significativo
                                    del resultado). Si por ejemplo realizamos una suma entre 2 números en complemento a
                                    dos y el resultado es negativo, este bit se pondrá a uno. Si el resultado es
                                    positivo, se pondrá a cero. Es útil para realizar operaciones matemáticas entre
                                    múltiples registros: por ejemplo, si nos hacemos una rutina de multiplicación o
                                    división de números que permita números negativos, este bit nos puede ser útil en
                                    alguna parte de la rutina.</p></li>

                                <li><p>Flag Z (zero o cero): Este flag se pone a uno si el resultado de la última
                                    operación que afecte a los flags es cero. Por ejemplo, si realizamos una operación
                                    matemática y el resultado es cero, se pondrá a uno. Este flag es uno de los más
                                    útiles, ya que podemos utilizarlo para múltiples tareas. La primera es para los
                                    bucles, ya que podremos programar código como:</p>
                                    <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                        <tr>
                                            <td><p class="codigo">
                                                <pre>
        ; Repetir algo 100 veces
        LD B, 100
bucle:
        (...)        ; código

        DEC B        ; Decrementamos B (B=B-1)
        JR NZ bucle  ; Si el resultado de la operación anterior
                     ; no es cero (NZ = Non Zero), saltar a la
                     ; etiqueta bucle y continuar. DEC B hará
                     ; que el flag Z se ponga a 1 cuando B llegue
                     ; a cero, lo que afectará al JR NZ.
                     ; Como resultado, este trozo de código (..)
                     ; se ejecutará 100 veces.
</pre>
                                                </p></td>
                                        </tr>
                                    </table>
                                    <p>Como veremos en su momento, existe una instrucción equivalente a DEC B + JR NZ
                                        que es más cómoda de utilizar y más rápida que estas 2 instrucciones juntas
                                        (DJNZ), pero se ha elegido el ejemplo que tenéis arriba para que veáis cómo
                                        muchas operaciones (en este caso DEC) afectan a los flags, y la utilidad que
                                        estos tienen a la hora de programar.</p>
                                    <p>Además de para bucles, también podemos utilizarlo para comparaciones. Supongamos
                                        que queremos hacer en ensamblador una comparación de igualdad, algo como:</p>

                                    <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                        <tr>
                                            <td><p class="codigo">
                                                <pre>
 IF C = B THEN GOTO 1000
 ELSE          GOTO 2000
</pre>
                                                </p></td>
                                        </tr>
                                    </table>
                                    <p>Si restamos C y B y el resultado es cero, es que ambos registros contienen el
                                        mismo valor:</p>
                                    <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                        <tr>
                                            <td><p class="codigo">
                                                <pre>

 LD A, C              ; A = C
                      ; Tenemos que hacer esto porque no existe
                      ; una instruccion SUB B, C . Sólo se puede
                      ; restar un registro al registro A.

 SUB B                ; A = A-B
 JP Z, Es_Igual       ; Si A=B la resta es cero y Z=1
 JP NZ, No_Es_Igual   ; Si A<>B la resta no es cero y Z=0
 (...)

Es_Igual:
 (...)
No_Es_Igual:
 (...)
</pre>
                                                </p></td>
                                        </tr>
                                    </table>
                                </li>
                                <li><p>Flag H (Half-carry o Acarreo-BCD): Se pone a uno cuando en operaciones BCD existe
                                    un acarreo del bit 3 al bit 4. Es muy probable que no lleguemos a utilizarlo
                                    nunca.</p></li>
                                <li><p>Flag P/V (Parity/Overflow o Paridad/Desbordamiento): En las operaciones que
                                    modifican el bit de paridad, este bit vale 1 si el número de unos del resultado de
                                    la operación es par, y 0 si es impar. Si, por contra, el resultado de la operación
                                    realizada necesita más bits para ser representado de los que nos provee el registro,
                                    tendremos un desbordamiento, con este flag a 1. Este mismo bit sirve pues para 2
                                    tareas, y nos indicará una u otra (paridad o desbordamiento) según sea el tipo de
                                    operación que hayamos realizado. Por ejemplo, tras una suma, su utilidad será la de
                                    indicar el desbordamiento.</p>
                                    <p>El flag de desbordamiento se activará cuando en determinadas operaciones pasemos
                                        de valores 11111111b a 00000000b, por "falta de bits" para representar el
                                        resultado o viceversa . Por ejemplo, en el caso de INC y DEC con registros de 8
                                        bits, si pasamos de 0 a 255 o de 255 a 0.</p>

                                </li>
                                <li><p>Flag N (Substract o Resta): Se pone a 1 si la última operación realizada fue una
                                    resta. Se utiliza en operaciones aritméticas.</p></li>
                                <li><p>Flag C (Carry o Acarreo): Este flag se pone a uno si el resultado de la operación
                                    anterior no cupo en el registro y necesita un bit extra para ser representado. Este
                                    bit es ese bit extra. Veremos su uso cuando tratemos las operaciones aritméticas, en
                                    esta misma entrega.</p></li>
                            </ul>
                            <p>Así pues, resumiendo:</p>
                            <ul>
                                <li>El registro F es un registro especial cuyo valor no manejamos directamente, sino que
                                    cada uno de sus bits tiene un valor especial y está a 1 o a 0 según ciertas
                                    condiciones de la última operación realizada que afecte a dicho registro.
                                </li>
                                <li>Por ejemplo, si realizamos una operación y el resultado de la misma es cero, se
                                    pondrá a 1 el flag de Zero (Z) del registro F, que no es más que su bit número 6.
                                </li>

                                <li>No todas las operaciones afectan a los flags, iremos viendo qué operaciones afectan
                                    a qué flags conforme avancemos en el curso, en el momento en que se estudia cada
                                    instrucción.
                                </li>
                                <li>Existen operaciones que se pueden ejecutar con el estado de los flags como
                                    condición. Por ejemplo, realizar un salto a una dirección de memoria si un
                                    determinado flag está activo, o si no lo está.
                                </li>
                            </ul>
                            <p><strong>INSTRUCCIONES LD</strong></p>
                            <p>Las operaciones que más utilizaremos en nuestros programas en ensamblador serán sin duda
                                las operaciones de carga o instrucciones LD. Estas operaciones sirven para:</p>
                            <ul>
                                <li>Meter un valor en un registro.</li>
                                <li>Copiar el valor de un registro en otro registro.</li>

                                <li>Escribir en memoria (en una dirección determinada) un valor.</li>
                                <li>Escribir en memoria (en una dirección determinada) el contenido de un registro.</li>
                                <li>Asignarle a un registro el contenido de una dirección de memoria.</li>
                            </ul>
                            <p>La sintaxis de LD en lenguaje ensamblador es:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 LD DESTINO, ORIGEN

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Así, gracias a las operaciones LD podemos:</p>
                            <ul>
                                <li><p>Asignar a un registro un valor numérico directo de 8 o 16 bits.</p>
                                    <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                        <tr>
                                            <td><p class="codigo">
                                                <pre>
  LD A, 10         ; A = 10
  LD B, 200        ; B = 200
  LD BC, 12345     ; BC = 12345
</pre>

                                                </p></td>
                                        </tr>
                                    </table>
                                </li>
                                <li><p>Copiar el contenido de un registro a otro registro:</p>
                                    <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                        <tr>
                                            <td><p class="codigo">
                                                <pre>
  LD A, B          ; A = B
  LD BC, DE        ; BC = DE
</pre>
                                                </p></td>
                                        </tr>

                                    </table>
                                </li>
                                <li><p>Escribir en posiciones de memoria:</p>
                                    <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                        <tr>
                                            <td><p class="codigo">
                                                <pre>
  LD (12345), A    ; Memoria[12345] = valor en A
  LD (HL), 10      ; Memoria[valor de HL] = 10
</pre>
                                                </p></td>
                                        </tr>
                                    </table>
                                </li>

                                <li><p>Leer el contenido de posiciones de memoria:</p>
                                    <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                        <tr>
                                            <td><p class="codigo">
                                                <pre>
  LD A, (12345)    ; A = valor en Memoria[12345]
  LD B, (HL)       ; B = valor en Memoria[valor de HL]
</pre>
                                                </p></td>
                                        </tr>
                                    </table>
                                </li>
                            </ul>
                            <p>Nótese cómo el operador () nos permite acceder a memoria. En nuestros ejemplos, LD A,
                                (12345) no significa meter en A el valor 12345 (cosa imposible al ser un registro de 16
                                bits) sino almacenar en el registro A el valor que hay almacenado en la celdilla número
                                12345 de la memoria del Spectrum.</p>

                            <p>En un microprocesador con un juego de instrucciones ortogonal, se podría usar cualquier
                                origen y cualquier destino sin distinción. En el caso del Z80 no es así. El listado
                                completo de operaciones válidas con LD es el siguiente:</p>
                            <p>Leyenda:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 N  = valor numérico directo de 8 bits (0-255)
 NN = valor numérico directo de 16 bits (0-65535)
 r  = registro de 8 bits (A, B, C, D, E, H, L)
 rr = registro de 16 bits (BC, DE, HL, SP)
 ri = registro índice (IX o IY).
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Listado:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 ; Carga de valores en registros
 LD r, N
 LD rr, NN
 LD ri, NN

 ; Copia de un registro a otro
 LD r, r
 LD rr, rr

 ; Acceso a memoria
 LD r, (HL)
 LD (NN), A
 LD (HL), N
 LD A, (rr)      ; (excepto rr=SP)
 LD (rr), A      ; (excepto rr=SP)
 LD A, (NN)
 LD rr, (NN)
 LD ri, (NN)
 LD (NN), rr
 LD (NN), ri

 ; Acceso indexado a memoria
 LD (ri+N), r
 LD r, (ri+N)
 LD (ri+N), N
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Además, tenemos una serie de casos "especiales":</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 ; Manipulación del puntero de pila (SP)
 LD SP, ri
 LD SP, HL

 ; Para manipular el registro I
 LD A, I
 LD I, A

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Veamos ejemplos válidos y cuál sería el resultado de su ejecución:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 ; Carga de valores en registros
 ; registro_destino = valor
 LD A, 100          ; LD r, N
 LD BC, 12345       ; LD rr, NN

 ; Copia de registros en registros
 ; registro_destino = registro_origen
 LD B, C            ; LD r, r
 LD A, B            ; LD r, r
 LD BC, DE          ; LD rr, rr

 ; Acceso a memoria
 ; (Posicion_memoria) = VALOR o bien
 ;  Registro = VALOR en (Posicion de memoria)
 LD A, (HL)         ; LD r, (rr)
 LD (BL), B         ; LD (rr), r
 LD (12345), A      ; LD (NN), A
 LD A, (HL)         ; LD r, (rr)
 LD (DE), A         ; LD (rr), r
 LD (BC), 1234h     ; LD (BC), NN
 LD (12345), DE     ; LD (NN), rr
 LD IX, (12345)     ; LD ri, (NN)
 LD (34567), IY     ; LD (NN), ri

 ; Acceso indexado a memoria
 ; (Posicion_memoria) = VALOR o VALOR = (Posicion_memoria)
 ; Donde la posicion es IX+N o IY+N:
 LD (IX+10), A      ; LD (ri+N), r
 LD A, (IY+100)     ; LD r, (ri+N)
 LD (IX-30), 100    ; LD (ri+N), N
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Haré hincapié de nuevo en el mismo detalle: debido a que el juego de instrucciones del
                                Z80 no es ortogonal, en ocasiones no podemos ejecutar ciertas operaciones que podrían
                                sernos útiles con determinados registros. En ese caso tendremos que buscar una solución
                                mediante los registros y operaciones válidas de que disponemos.</p>

                            <p>Un detalle muy importante respecto a las instrucciones de carga: en el caso de las
                                operaciones LD, el registro F no ve afectado ninguno de sus indicadores o flags en
                                relación al resultado de la ejecución de las mismas (salvo en el caso de "LD A, I" y "LD
                                A, R").</p>
                            <p>Esto quiere decir que una operación como "LD A, 0", por ejemplo, no activará el flag de
                                Zero del registro F.</p>
                            <p><strong>CPU Z80: LOW ENDIAN</strong></p>
                            <p>Un detalle más sobre nuestra CPU: a la hora de trabajar con datos de 16 bits (por
                                ejemplo, leer o escribir de memoria) conviene tener en cuenta que nuestro Z80 es una CPU
                                del tipo LOW-ENDIAN, es decir, que si almacenamos en la posición de memoria 0000h el
                                valor "1234h", el contenido de las celdillas de memoria sería:</p>
                            <table>
                                <tr>
                                    <th style="border-bottom: 1px solid #000;">Posición</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                </tr>
                                <tr>
                                    <td>0000h</td>
                                    <td>34h</td>
                                </tr>

                                <tr>
                                    <td>0001h</td>
                                    <td>12h</td>
                                </tr>
                            </table>
                            <p>En otro tipo de procesadores del tipo Big-Endian, los bytes aparecerían escritos en
                                memoria de la siguiente forma:</p>
                            <table>
                                <tr>
                                    <th style="border-bottom: 1px solid #000;">Posición</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                </tr>
                                <tr>
                                    <td>0000h</td>
                                    <td>12h</td>
                                </tr>
                                <tr>
                                    <td>0001h</td>
                                    <td>34h</td>
                                </tr>

                            </table>
                            <p>Debemos tener en cuenta este dato a la hora de escribir valores de 16 bits en memoria y
                                recuperarlos posteriormente mediante operaciones de acceso a la memoria.</p>
                            <p><strong>INCREMENTOS Y DECREMENTOS</strong></p>
                            <p>Entre las operaciones disponibles, tenemos la posibilidad de incrementar (INC) y
                                decrementar (DEC) en 1 unidad el contenido de determinados registros de 8 y 16 bits, así
                                como de posiciones de memoria apuntadas por HL o por IX/IY más un offset (desplazamiento
                                de 8 bits).</p>
                            <p>Por ejemplo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 LD A, 0      ; A = 0
 INC A        ; A = A+1 = 1
 LD B, A      ; B = A = 1
 INC B        ; B = B+1 = 2
 INC B        ; B = B+1 = 3
 LD  BC, 0
 INC BC       ; BC = 0001h
 INC B        ; BC = 0101h (ya que B=B+1 y es la parte alta)
 DEC A        ; A = A-1 = 0
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p>Veamos las operaciones INC y DEC permitidas:</p>
                            <ul>
                                <li><p>INC r</p></li>
                                <li><p>DEC r</p></li>
                                <li><p>INC rr</p></li>
                                <li><p>DEC rr</p>
                                    <p>Donde r puede ser A, B, C, D, E, H o L, y 'rr' puede ser BC, DE, HL, SP, IX o IY.
                                        Esta instrucción incrementa o decrementa el valor contenido en el registro
                                        especificado.</p>

                                </li>
                                <li><p>INC (HL)</p></li>
                                <li><p>DEC (HL)</p>
                                    <p>Incrementa o decrementa el byte que contiene la dirección de memoria apuntada por
                                        HL.</p>
                                </li>
                                <li><p>INC (IX+N)</p></li>
                                <li><p>DEC (IX+N)</p></li>

                                <li><p>INC (IY+N)</p></li>
                                <li><p>DEC (IY+N)</p>
                                    <p>Incrementa o decrementa el byte que contiene la dirección de memoria resultante
                                        de sumar el valor del registro IX o el registro IY con un valor numérico de 8
                                        bits en complemento a dos.</p>
                                </li>
                            </ul>
                            <p>Por ejemplo, las siguientes instrucciones serían válidas:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
 INC A          ; A = A+1
 DEC B          ; B = B-1
 INC DE         ; DE = DE+1
 DEC IX         ; IX = IX-1
 INC (HL)       ; (HL) = (HL)+1
 INC (IX-5)     ; (IX-5) = (IX-5)+1
 DEC (IY+100)   ; (IY+100) = (IY+100)+1
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Unos apuntes sobre la afectación de los flags ante el uso de INC y DEC:</p>
                            <ul>
                                <li>Si un registro de 8 bits vale 255 (FFh) y lo incrementamos, pasará a valer 0.</li>
                                <li>Si un registro de 16 bits vale 65535 (FFFFh)y lo incrementamos, pasará a valer 0.
                                </li>
                                <li>Si un registro de 8 bits vale 0 y lo decrementamos, pasará a valer 255 (FFh).</li>

                                <li>Si un registro de 16 bits vale 0 (0h) y lo decrementamos, pasará a valer 65535
                                    (FFh).
                                </li>
                                <li>En estos desbordamientos no se tomará en cuenta para nada el bit de Carry (acarreo)
                                    de los flags (registro F), ni tampoco lo afectarán tras ejecutarse.
                                </li>
                                <li>Las operaciones INC y DEC sobre registros de 16 bits (BC, DE, HL, IX, IY, SP) no
                                    afectan a los flags. Esto implica que no podemos usar como condición de flag zero
                                    para un salto el resultado de instrucciones como "DEC BC", por ejemplo.
                                </li>
                                <li>Las operaciones INC y DEC sobre registros de 8 bits y sobre la memoria no afectan al
                                    flag de acarreo, pero sí que pueden afectar al flag de Zero (Z), al de
                                    Paridad/Overflow (P/V), al de Signo (S) y al de Half-Carry (H).
                                </li>
                            </ul>
                            <p>Lo siguiente que vamos a ver es una tabla de afectación de flags (que podréis ver en
                                muchas tablas de instrucciones del Z80, y a las que conviene que os vayáis
                                acostumbrando). Esta tabla indica cómo afecta cada instrucción a cada uno de los
                                flags:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   INC r             |* * * V 0 -|
   INC [HL]          |* * * V 0 -|
   INC [ri+N]        |* * * V 0 -|
   INC rr            |- - - - - -|
   DEC r             |* * * V 1 -|
   DEC rr            |- - - - - -|

 Donde:
 r = registro de 8 bits
 rr = registro de 16 bits (BC, DE, HL, IX, IY)
 ri = registro índice (IX, IY)
 N = desplazamiento de 8 bits (entre -128 y +127).

 Y respecto a los flags:
 - = El flag NO se ve afectado por la operación.
 * = El flag se ve afectado por la operación acorde al resultado.
 0 = El flag se pone a cero.
 1 = El flag se pone a uno.
 V = El flag se comporta como un flag de Overflow acorde al resultado.
 ? = El flag toma un valor indeterminado.
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p><strong>OPERACIONES MATEMATICAS</strong></p>
                            <p>Las operaciones aritméticas básicas para nuestro Spectrum son la suma y la resta, tanto
                                con acarreo como sin él. A partir de ellas deberemos crearnos nuestras propias rutinas
                                para multiplicar, dividir, etc.</p>
                            <h4>Suma: ADD (Add)</h4>
                            <p>Nuestro microprocesador Z80 puede realizar sumas de 8 y 16 bits internamente. La
                                instrucción utilizada para ello es "ADD" y el formato es:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
 ADD DESTINO, ORIGEN
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Las instrucciones disponibles para realizar sumas se reducen a:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 ADD A, s
 ADD HL, ss
 ADD ri, rr

 Donde:

 s:  Cualquier registro de 8 bits (A, B, C, D, E, H, L),
     cualquier valor inmediato de 8 bits (en el rango 0-255 o -128+127
     en complemento a dos), cualquier dirección de memoria apuntada por HL,
     y cualquier dirección de memoria apuntada por un registro índice con
     desplazamiento de 8 bits.
 ss: Cualquier registro de 16 bits de entre los siguientes: BC, DE, HL, SP.
 ri: Uno de los 2 registros índices (IX o IY).
 rr: Cualquier registro de 16 bits de entre los siguientes excepto el mismo
     registro índice origen: BC, DE, HL, IX, IY, SP.
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p>Esto daría la posibilidad de ejecutar cualquiera de las siguientes instrucciones:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 ; ADD A, s
 ADD A, B        ; A = A + B
 ADD A, 100      ; A = A + 100
 ADD A, [HL]     ; A = A + [HL]
 ADD A, [IX+10]  ; A = A + [IX+10]

 ; ADD HL, ss
 ADD HL, BC      ; HL = HL + BC
 ADD HL, SP      ; HL = HL + SP

 ; ADD ri, rr
 ADD IX, BC      ; IX = IX + BC
 ADD IY, DE      ; IY = IY + DE
 ADD IY, IX      ; IY = IY + IX
 ADD IX, IY      ; IX = IX + IY
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Por contra, estas instrucciones no serían válidas:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
 ADD B, C      ; Sólo A puede ser destino
 ADD BC, DE    ; Sólo puede ser destino HL
 ADD IX, IX    ; No podemos sumar un registro índice a él mismo
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>La afectación de los flags ante las operaciones de sumas es la siguiente:</p>
                            <ul>
                                <li>Para "ADD A, s", el registro N (Substraction) se pone a 0 (lógicamente, ya que sólo
                                    se pone a uno cuando se ha realizado una resta). El registro P/V se comporta como un
                                    registro de Overflow e indica si ha habido overflow (desbordamiento) en la
                                    operación. El resto de flags (Sign, Zero, Half-Carry y Carry) se verán afectados de
                                    acuerdo al resultado de la operación de suma.
                                </li>
                                <li>Para "ADD HL, ss" y "ADD ri, rr", se pone a 0 el flag N, y sólo se verá afectado el
                                    flag de acarreo (C) de acuerdo al resultado de la operación.
                                </li>
                            </ul>

                            <p>O, en forma de tabla de afectación:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
 ADD A, s            |* * * V 0 *|
 ADD HL, ss          |- - ? - 0 *|
 ADD ri, rr          |- - ? - 0 *|
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Las sumas realizadas por el Spectrum se hacen a nivel de bits, empezando por el bit de
                                más a la derecha y yendo hacia la izquierda, según las siguientes reglas:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
 0 + 0 = 0
 0 + 1 = 1
 1 + 0 = 1
 1 + 1 = 10 (=0 con acarreo)
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Al sumar el último bit, se actualizará el flag de acarreo si es necesario.</p>
                            <p>Por ejemplo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
       *
   00000100
 + 00000101
  -----------
   00001001

  (* = acarreo de la suma del bit anterior, 1+1=10)

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Si la suma del último bit (bit 7) requiere un bit extra, se utilizará el Carry Flag del
                                registro F para almacenarlo. Supongamos que ejecutamos el siguiente código:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 LD A, %10000000
 LD B, %10000000
 ADD A, B
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>El resultado de la ejecución de esta suma sería: A=128+128=256. Como 256 (100000000b)
                                tiene 9 bits, no podemos representar el resultado con los 8 bits del registro A, de modo
                                que el resultado de la suma sería realmente: A = 00000000 y CarryFlag = 1.</p>

                            <h4>Resta: SUB (Substract)</h4>
                            <p>En el caso de las restas, sólo es posible realizar (de nuevo gracias a la no
                                ortogonalidad del J.I.) la operación "A=A-origen", donde "origen" puede ser cualquier
                                registro de 8 bits, valor inmediato de 8 bits, contenido de la memoria apuntada por
                                [HL], o contenido de la memoria apuntada por un registro índice más un desplazamiento.
                                El formato de la instrucción no requiere 2 operandos, ya que el registro destino sólo
                                puede ser A:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 SUB ORIGEN
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Concretamente:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 SUB r        ; A = A - r
 SUB N        ; A = A - N
 SUB [HL]     ; A = A - [HL]
 SUB [rr+d]   ; A = A - [rr+d]
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Por ejemplo:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>

 SUB B        ; A = A - B
 SUB 100      ; A = A - 100
 SUB [HL]     ; A = A - [HL]
 SUB [IX+10]  ; A = A - [IX+10]
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Es importante recordar que en una operación "SUB X", la operación realizada es "A=A-X" y
                                no "A=X-A".</p>
                            <p>Por otra parte, con respecto a la afectación de flags, tenemos la siguiente:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 Flags:      S Z H P N C
 -----------------------
 Afectación: * * * V 1 *
</pre>

                                        </p></td>
                                </tr>
                            </table>
                            <p>Es decir, el flag de N (substraction) se pone a 1, para indicar que hemos realizado una
                                resta. El flag de P/V (Parity/Overflow) se convierte en indicar de Overflow y queda
                                afectado por el resultado de la resta. El resto de flags (Sign, Zero, Half-Carry y
                                Carry) quedarán afectados de acuerdo al resultado de la misma (por ejemplo, si el
                                resultado es Cero, se activará el Flag Z).</p>
                            <h4>Suma con acarreo: ADC (Add with carry)</h4>
                            <p>Sumar con acarreo dos elementos significa realizar la suma de uno con el otro y,
                                posteriormente, sumarle el estado del flag de Carry. Es decir:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 "ADC A, s"    equivale a    "A = A + s + CarryFlag"
 "ADC HL, ss"  equivale a    "HL = HL + ss + CarryFlag"

 ("s" y "ss" tienen el mismo significado que en ADD y SUB).
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p> La tabla de afectación de flags sería la siguiente:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
 ADC A,s            |* * * V 0 *|
 ADC HL,ss          |* * ? V 0 *|
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>La suma con acarreo se utiliza normalmente para sumar las partes altas de palabras de 16
                                bytes. Se suma la parte baja con ADD y luego la parte alta con ADC para tener en cuenta
                                el acarreo de la suma de la parte baja.</p>
                            <h4>Resta con acarreo: SBC (Substract with carry)</h4>

                            <p>Al igual que en el caso de la suma con acarreo, podemos realizar restas con acarreo, que
                                no son más que realizar una resta de los 2 operandos, tras lo cual restamos además el
                                valor del bit de Carry Flag:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 "SBC A, s"    equivale a    "A = A - s - CarryFlag"
 "SBC HL, ss"  equivale a    "HL = HL - ss - CarryFlag"
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>La tabla de afectación de flags (en este caso con N=1, ya que es una resta):</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
 SBC A,s            |* * * V 1 *|
 SBC HL,ss          |* * ? V 1 *|
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p><strong>COMPLEMENTO A DOS</strong></p>
                            <p>A lo largo del presente texto hemos hablado de números en complemento a dos. Complemento
                                a dos es una manera de representar números negativos en nuestros registros de 8 bits,
                                utilizando para ello como signo el bit más significativo (bit 7) del byte.</p>
                            <p>Si dicho bit está a 0, el número es positivo, y si está a 1 es negativo. Así:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>

 01111111    (+127)
 01111110    (+126)
 01111101    (+125)
 01111100    (+124)
 (...)
 00000100    (+4)
 00000011    (+3)
 00000010    (+2)
 00000001    (+1)
 00000000    (0)
 11111111    (-1)
 11111110    (-2)
 11111101    (-3)
 11111100    (-4)
 (...)
 10000011    (-125)
 10000010    (-126)
 10000001    (-127)
 10000000    (-128)
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Podemos averiguar cuál es la versión negativa de cualquier número positivo (y viceversa),
                                invirtiendo el estado de los bits y sumando uno:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 +17  = 00010001

 -17 =  11101110   (Invertimos unos y ceros)
     =        +1   (Sumamos 1)
     =  11101111   (-17 en complemento a dos)
</pre>
                                        </p></td>
                                </tr>

                            </table>
                            <p>Como veremos en unos minutos, se eligió este sistema para representar los números
                                negativos para que las operaciones matemáticas estándar funcionaran directamente sobre
                                los números positivos y negativos. ¿Por qué no utilizamos directamente la inversión de
                                los bits para representar los números negativos y estamos sumando además 1 para
                                obtenerlos? Sencillo: si no sumáramos uno y simplemente invirtiéramos los bits,
                                tendríamos 2 ceros (00000000 y 11111111) y además las operaciones matemáticas no
                                cuadrarían (por culpa de los dos ceros). La gracia del complemento a dos es que las
                                sumas y restas binarias lógicas (ADD, ADC, SUB y SBC) funcionan:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 Sumemos -17 y 32:

  -17 = 11101111
+ +32 = 00100000
 -----------------
      1 00001111
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>El resultado es 00001111, es decir, 15, ya que 32-17=15. El flag de carry se pone a 1,
                                pero lo podemos ignorar, porque el flag que nos indica realmente el desbordamiento (como
                                veremos a continuación) en operaciones de complemento a dos es el flag de Overflow.</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
 Sumemos ahora +17 y -17:

  +17 = 00010001
+ -17 = 11101111
 ----------------------
      1 00000000
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Como podéis ver, al sumar +17 y -17 el resultado es 0. Si representáramos los números
                                negativos simplemente como la inversa de los positivos, esto no se podría hacer:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
  +17 = 00010001
+ -17 = 11101110    <--- (solo bits invertidos)
 ----------------------
      1 11111111    <--- Nos da todo unos, el "cero" alternativo.

</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>En complemento a dos, las sumas y restas de números se pueden realizar a nivel lógico
                                mediante las operaciones estándar del Z80. En realidad para el Z80 no hay más que
                                simples operaciones de unos y ceros, y somos nosotros los que interpretamos la
                                información de los operandos y del resultado de una forma que nos permite representar
                                números negativos.</p>
                            <p>En otras palabras: cuando vemos un uno en el bit más significativo de un resultado, somos
                                nosotros los que tenemos que interpretar si ese bit representa un signo negativo o no:
                                si sabemos que estamos operando con números 0-255, podemos tratarlo como un resultado
                                positivo. Si estábamos operando con números en complemento a dos, podemos tratarlo como
                                un resultado en complemento a dos. Para el microprocesador, en cambio, no hay más que
                                unos y ceros.</p>
                            <p>Para acabar, veamos cuál es la diferencia entre el Flag de Carry (C) y el de Overflow (V)
                                a la hora de realizar sumas y restas. El primero (C) se activará cuando se produzca un
                                desbordamiento físico a la hora de sumar o restar 2 números binarios (cuando necesitemos
                                un bit extra para representarlo). El segundo (V), se utilizará cuando se produzca
                                cualquier sobrepasamiento operando con 2 números en complemento a dos.</p>
                            <p>Como acabamos de ver, en complemento a dos el último bit (el bit 7) nos indica el signo,
                                y cuando operamos con 2 números binarios que nosotros interpretamos como números en
                                complemento a dos no nos basta con el bit de Carry. Es el bit de Overflow el que nos
                                dará información sobre el desbordamiento a un nivel lógico.</p>
                            <p>En pocas palabras, el bit de Carry se activará si pasamos de 255 a 0 o de 0 a 255
                                (comportándose como un bit de valor 2 elevado a 8, o 256), y el bit de overflow lo hará
                                si el resultado de una operación en complemento a dos requiere más de 7 bits para ser
                                representado.</p>
                            <p>Mediante ejemplos:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">

                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 255+1:

   11111111
+  00000001
  -----------
 1 00000000

   C=1 (porque hace falta un bit extra)
   V=0


 127+1:

   01111111
+  00000001
  -----------
   10000000

   C=0 (no es necesario un bit extra en el registro)
   V=1 (en complemento a dos, no podemos representar +128)
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>En el ejemplo anterior, V se activa porque no ha habido desbordamiento físico (no es
                                necesario un bit extra para representar la operación), pero sí lógico: no podemos
                                representar +128 con 7 bits+signo en complemento a dos.</p>
                            <p><strong>INSTRUCCIONES DE INTERCAMBIO</strong></p>
                            <p>Como ya se ha explicado, disponemos de un banco de registros alternativos (los Shadow
                                Registers), y podemos conmutar los valores entre los registros estándar y los
                                alternativos mediante unas determinadas instrucciones del Z80.</p>
                            <p>El Z80 nos proporciona una serie de registros de propósito general (así como un registro
                                de flags), de nombres A, B, C, D, E, F, H y L. El micro dispone también de unos
                                registros extra (set alternativo conocido como Shadow Registers) de nombre A', B', C',
                                D', E', F', H' y L', que aprovecharemos en cualquier momento de nuestro programa. No
                                obstante, no podremos hacer uso directo de estos registros en instrucciones en
                                ensamblador. No es posible, por ejemplo, ninguna de las siguientes instrucciones:</p>

                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">
                                        <pre>
 LD B', $10
 INC A'
 LD HL', $1234
 LD A', ($1234)
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>La manera de utilizar estos registros alternativos es conmutar sus valores con los
                                registros estándar mediante la instrucción "EXX", cuyo resultado es el intercambio de B
                                por B', C por C', D por D', E por E', H por H' y L por L'. Supongamos que tenemos los
                                siguientes valores en los registros:</p>
                            <table>
                                <tr>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                </tr>

                                <tr>
                                    <td>B</td>
                                    <td>A0h</td>
                                    <td>B'</td>
                                    <td>00h</td>
                                </tr>
                                <tr>
                                    <td>C</td>
                                    <td>55h</td>
                                    <td>C'</td>
                                    <td>00h</td>
                                </tr>
                                <tr>
                                    <td>D</td>
                                    <td>01h</td>
                                    <td>D'</td>
                                    <td>00h</td>
                                </tr>
                                <tr>
                                    <td>E</td>
                                    <td>FFh</td>
                                    <td>E'</td>
                                    <td>00h</td>
                                </tr>

                                <tr>
                                    <td>H</td>
                                    <td>00h</td>
                                    <td>H'</td>
                                    <td>00h</td>
                                </tr>
                                <tr>
                                    <td>L</td>
                                    <td>31h</td>
                                    <td>L'</td>
                                    <td>00h</td>
                                </tr>
                            </table>
                            <p>En el momento en que realicemos un EXX, los registros cambiarán de valor por la
                                "conmutación" de bancos:</p>
                            <table>
                                <tr>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                </tr>

                                <tr>
                                    <td>B</td>
                                    <td>00h</td>
                                    <td>B'</td>
                                    <td>A0h</td>
                                </tr>
                                <tr>
                                    <td>C</td>
                                    <td>00h</td>
                                    <td>C'</td>
                                    <td>55h</td>
                                </tr>
                                <tr>
                                    <td>D</td>
                                    <td>00h</td>
                                    <td>D'</td>
                                    <td>01h</td>
                                </tr>
                                <tr>
                                    <td>E</td>
                                    <td>00h</td>
                                    <td>E'</td>
                                    <td>FFh</td>
                                </tr>

                                <tr>
                                    <td>H</td>
                                    <td>00h</td>
                                    <td>H'</td>
                                    <td>00h</td>
                                </tr>
                                <tr>
                                    <td>L</td>
                                    <td>00h</td>
                                    <td>L'</td>
                                    <td>31h</td>
                                </tr>
                            </table>
                            <p>Si realizamos de nuevo EXX, volveremos a dejar los valores de los registros en sus
                                "posiciones" originales. EXX (mnemónico ensamblador derivado de EXchange), simplemente
                                intercambia los valores entre ambos bancos.</p>
                            <p>Aparte de la instrucción EXX, disponemos de una instrucción EX AF, AF' , que, como el
                                lector imagina, intercambia los valores de los registros AF y AF'. Así, pasaríamos
                                de:</p>
                            <table>
                                <tr>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                </tr>

                                <tr>
                                    <td>A</td>
                                    <td>01h</td>
                                    <td>A'</td>
                                    <td>00h</td>
                                </tr>
                                <tr>
                                    <td>F</td>
                                    <td>10h</td>
                                    <td>F'</td>
                                    <td>00h</td>
                                </tr>
                            </table>
                            <p>a:</p>
                            <table>
                                <tr>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                    <th style="border-bottom: 1px solid #000;">Registro</th>
                                    <th style="border-bottom: 1px solid #000;">Valor</th>
                                </tr>

                                <tr>
                                    <td>A</td>
                                    <td>00h</td>
                                    <td>A'</td>
                                    <td>01h</td>
                                </tr>
                                <tr>
                                    <td>F</td>
                                    <td>00h</td>
                                    <td>F'</td>
                                    <td>10h</td>
                                </tr>
                            </table>
                            <p>Realizando de nuevo un EX AF, AF' volveríamos a los valores originales en ambos
                                registros.</p>
                            <p>De esta forma podemos disponer de un set de registros extra con los que trabajar. Por
                                ejemplo, supongamos que programamos una porción de código donde queremos hacer una serie
                                de cálculos entre registros y después dejar el resultado en una posición de memoria,
                                pero no queremos perder los valores actuales de los registros (ni tampoco hacer uso de
                                la pila, que veremos en su momento). En ese caso, podemos hacer:</p>
                            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                                <tr>
                                    <td><p class="codigo">

                                        <pre>
; Una rutina a la que saltaremos gracias a la
; etiqueta que definimos aquí:
MiRutina:

    ; Cambiamos de banco de registros:
    EXX
    EX AF, AF'

    ; Hacemos nuestras operaciones
    LD A, (1234h)
    LD B, A
    LD A, (1235h)
    INC A
    ADD A, B
    ; (...etc...)
    ; (...aquí más operaciones...)

    ; Grabamos el resultado en memoria
    LD (1236h), A

    ; Recuperamos los valores de los registros
    EX AF, AF'
    EXX

    ; Volvemos al lugar de llamada de la rutina
    RET
</pre>
                                        </p></td>
                                </tr>
                            </table>
                            <p>Aparte de EXX y EX AF, AF' tenemos disponibles 3 instrucciones de intercambio más que no
                                trabajan con los registros alternativos, sino entre la memoria y registros, y la pila (o
                                memoria en general) y los registros HL, IX e IY.</p>
                            <table>
                                <tr>
                                    <th style="border-bottom: 1px solid #000;">Instrucción</th>
                                    <th style="border-bottom: 1px solid #000;">Resultado</th>
                                </tr>
                                <tr>
                                    <td>EX DE, HL</td>
                                    <td>Intercambiar los valores de DE y HL.</td>
                                </tr>
                                <tr>
                                    <td>EX (SP), HL</td>
                                    <td>Intercambiar el valor de HL con el valor de 16 bits de la posición de memoria
                                        apuntada por el registro SP (por ejemplo, para intercambiar el valor de HL con
                                        el del último registro que hayamos introducido en la pila).
                                </tr>
                </tr>

                <tr>
                    <td>EX (SP), IX</td>
                    <td>Igual que el anterior, pero con IX.</td>
                </tr>
                <tr>
                    <td>EX (SP), IY</td>
                    <td>Igual que el anterior, pero con IY.
                </tr>
            </table>
            <p>La primera de estas instrucciones nos puede ser muy útil en nuestros programas en ensamblador, ya que nos
                permite intercambiar los valores de los registros DE y HL. Las 3 instrucciones restantes permiten
                intercambiar el valor apuntado por SP (en memoria) por el valor de los registros HL, IX o IY.</p>
            <p>Como ya hemos comentado cuando hablamos del carácter Low-Endian de nuestra CPU, al escribir en memoria
                (también en la pila) primero se escribe el Byte Bajo y luego el Byte Alto. Posteriormente lo leeremos de
                la misma forma, de tal modo que si los bytes apuntados en la pila (en memoria) son "FF 00h", al hacer el
                EX (SP), HL, el registro HL valdrá "00FFh".</p>
            <p>Nótese que aprovechando la pila (como veremos en su momento) también podemos intercambiar los valores de
                los registros mediante:</p>
            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                <tr>
                    <td><p class="codigo">
                        <pre>

 PUSH BC
 PUSH DE
 POP BC
 POP DE
</pre>
                        </p></td>
                </tr>
            </table>
            <p>Si queréis comprobarlo, podéis hacerlo mediante el siguiente programa:</p>
            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                <tr>
                    <td><p class="codigo">
                        <pre>
 ; Ejemplo que muestra el intercambio de registros
 ; mediante el uso de la pila (PUSH/POP).
 ORG 40000

 ; Cargamos en DE el valor 12345 y
 ; realizamos un intercambio de valores
 ; con BC, mediante la pila:
 LD DE, 12345
 LD BC, 0

 PUSH DE
 PUSH BC
 POP DE
 POP BC

 ; Volvemos, ahora BC=DE y DE=BC
 RET
</pre>
                        </p></td>
                </tr>
            </table>
            <p>Lo ensamblamos:</p>
            <table border="0" cellspacing="0" cellpadding="4" width="100%" bgcolor="#EAE8A9">
                <tr>
                    <td><p class="codigo">
                        <pre>
 pasmo --tapbas cambio.asm cambio.tap
</pre>
                        </p></td>
                </tr>
            </table>
            <p>Tras esto lo cargamos en un emulador de Spectrum (como un fichero TAP), nos vamos al BASIC y tecleamos
                "PRINT AT 10, 10; USR 40000". En pantalla aparecerá el valor "12345", ya que las rutinas llamadas desde
                BASIC devuelven sus resultados en BC, y nosotros hemos hecho un intercambio mediante la pila, entre DE y
                BC.</p>
            <p>En su momento veremos cómo funciona la pila, por ahora basta con saber que tenemos la posibilidad de
                intercambiar registros mediante el uso de la misma. Podríamos haber optado por no explicar este pequeño
                truco hasta haber hablado de la pila, pero nos parece más conveniente el hecho de tener toda la
                información sobre ensamblador agrupada de forma que cuando en el futuro (una vez terminado el curso
                completo) busquéis información sobre instrucciones para intercambiar valores de registros, podáis
                encontrarla toda junta, como un libro o una guía de referencia. Como hemos comentado al principio de
                esta entrega, resulta muy complicado explicar un lenguaje tan interrelacionado de forma que no se
                solapen diferentes áreas, de modo que la comprensión total de muchos de los conceptos se alcanzará con
                una segunda lectura del curso completo.</p>

            <p><strong>EN RESUMEN</strong></p>
            <p>En esta entrega hemos visto la sintaxis de los programas en ensamblador (o, al menos, la sintaxis general
                de PASMO, el ensamblador que recomendamos), así como una descripción completa del juego de registros del
                Z80, incluyendo entre ellos el registro de flags F.</p>
            <p>Además, hemos comenzado a ver nuestras primeras instrucciones del lenguaje ensamblador, en especial las
                instrucciones de carga, incremento y decremento, y aritméticas.</p>
            <p>En la próxima entrega continuaremos detallando las diferentes instrucciones del Z80, ejemplos de uso y su
                efecto sobre los flags del registro F. Hasta entonces, os recomiendo la lectura del fichero
                "progcard.txt" adjunto con este artículo, donde encontraréis una gran referencia de instrucciones y
                flags.</p>
            <p><strong>FICHEROS</strong></p>
            <ul>
                <li><a href="revistas/14/src/ejemplo.asm" onClick="window.open(this.href); return false;">Ejemplo de
                    programa en ASM</a></li>
                <li><a href="revistas/14/tap/ejemplo.tap" onClick="window.open(this.href); return false;">Fichero tap
                    del ejemplo ejemplo.asm</a></li>

                <li><a href="revistas/14/info/progcard.txt" onClick="window.open(this.href); return false;">Referencia
                    del juego de instrucciones del Z80 y cómo su ejecución afecta a los flags</a></li>
                <li><a href="revistas/14/src/cambio.asm" onClick="window.open(this.href); return false;">Programa en ASM
                    que muestra el uso de la pila para el intercambio de registros</a></li>
                <li><a href="revistas/14/tap/cambio.tap" onClick="window.open(this.href); return false;">Fichero tap del
                    ejemplo cambio.asm</a></li>
            </ul>
            <p><strong>LINKS</strong></p>
            <ul>
                <li><a href="http://www.worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt28.html"
                       onClick="window.open(this.href); return false;">Juego de caracteres</a></li>
                <li><a href="http://www.z80.info/" onClick="window.open(this.href); return false;">Web del Z80</a></li>

                <li><a href="http://www.worldofspectrum.org/faq/reference/z80reference.htm"
                       onClick="window.open(this.href); return false;">Z80 Reference de WOS</a></li>
                <li><a href="http://ti86.acz.org/z80_ref.htm" onClick="window.open(this.href); return false;">Z80
                    Reference de TI86</a></li>
                <li><a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm"
                       onClick="window.open(this.href); return false;">Microfichas de CM de MicroHobby</a></li>
                <li><a href="http://www.ticalc.org/pub/text/z80/" onClick="window.open(this.href); return false;">Tablas
                    de ensamblado y t-estados (pulsar en z80.txt, z80_reference.txt, z80time.txt)</a></li>
                <li><a href="http://www.worldofspectrum.org/faq/reference/Z80reference.htm"
                       onClick="window.open(this.href); return false;">Z80 Reference de WOS</a></li>
                <li><a href="http://www.z80.info/lesson1.htm" onClick="window.open(this.href); return false;">Curso de
                    ensamblador de z80.info</a></li>

                <li><a href="http://www.arrakis.es/~ninsesabe/pasmo/" onClick="window.open(this.href); return false;">Pasmo
                </li>
            </ul>
            </div>
        </td>
    </tr>
    <tr>
        <td align="right"><br><br>SROMERO</td>
    </tr>
</table>

</td>
</tr>
<tr>
    <td> </td>
</tr>
<tr>
    <td>
        <script type="text/javascript">
          function RecargarPie(url) {
            document.location = url;
          }
        </script>
        <table border="0" cellspacing="0" cellpadding="6" width="720" class="texto" bgcolor="#DDDDDD">
            <form name="selector_secciones">
                <tr>

                    <td align="left">
                        <input type="button" onclick="RecargarCabecera('input.html');" name="anterior" value="<"/>
                        <select onChange="RecargarCabecera(this.options[this.selectedIndex].value);">
                            <option value="index.html">Portada</option>
                            <option value="editorial.html">Índice - Editorial</option>
                            <option value="panorama.html">Panorama</option>
                            <option value="analisis.html">Análisis</option>

                            <option value="hardware.html">Hardware</option>
                            <option value="z88dk.html">Programación Z88DK</option>
                            <option value="input.html">INPUT</option>
                            <option value="ensamblador.html" selected>Programación Ensamblador</option>
                        </select>
                        <input type="button" onclick="return false;" name="siguiente" value=">" disabled/>
                    </td>

                    <td align="right" class="texto">
                        <a href="#arriba">Volver arriba</a>
                    </td>
                </tr>
                <tr>
                    <td colspan="2" align="center" bgcolor="#FFFFFF" class="texto">> <a href="../mapa-web.html"><b>MAPA WEB</b></a> <</td>
                </tr>
            </form>

        </table>
    </td>
</tr>
<tr>
    <td>
        <table border="0" cellspacing="0" cellpadding="4" width="720" bgcolor="#EEEEEE" class="texto">
            <tr align="center" valign="center">
                <td>2003-2009 Magazine ZX</td>
            </tr>
        </table>
    </td>
</tr>
</table>
</body>
</html>
